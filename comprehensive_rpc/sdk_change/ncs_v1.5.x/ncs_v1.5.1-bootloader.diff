diff --git a/boot/bootutil/src/loader.c b/boot/bootutil/src/loader.c
index 716e3ed..ce6ae48 100644
--- a/boot/bootutil/src/loader.c
+++ b/boot/bootutil/src/loader.c
@@ -44,6 +44,8 @@
 #include "bootutil/security_cnt.h"
 #include "bootutil/boot_record.h"
 #include "bootutil/fault_injection_hardening.h"
+#include <storage/flash_map.h>
+#include <drivers/flash.h>
 
 #ifdef CONFIG_SOC_NRF5340_CPUAPP
 #include <dfu/pcd.h> 
@@ -57,6 +59,13 @@
 
 MCUBOOT_LOG_MODULE_DECLARE(mcuboot);
 
+#ifdef PM_MCUBOOT_SECONDARY_ADDRESS
+#define SECONDARY_OFFSET_ADDRESS PM_MCUBOOT_SECONDARY_ADDRESS
+#else
+#define SECONDARY_OFFSET_ADDRESS 
+#endif
+
+
 static struct boot_loader_state boot_data;
 
 #if (BOOT_IMAGE_NUMBER > 1)
@@ -579,6 +588,36 @@ boot_version_cmp(const struct image_version *ver1,
 }
 #endif
 
+#if defined(MCUBOOT_DIRECT_XIP)
+/**
+ * Check if image in slot has been set with specific ROM address to run from
+ * and whether the slot starts at that address.
+ *
+ * @returns 0 if IMAGE_F_ROM_FIXED flag is not set;
+ *          0 if IMAGE_F_ROM_FIXED flag is set and ROM address specified in
+ *            header matches the slot address;
+ *          1 if IMF_F_ROM_FIXED flag is set but ROM address specified in header
+ *          does not match the slot address.
+ */
+static bool
+boot_rom_address_check(struct boot_loader_state *state, size_t slot)
+{
+    const struct image_header *hdr = boot_img_hdr(state, slot);
+    uint32_t f_off = boot_img_slot_off(state, slot);
+    if (hdr->ih_flags & IMAGE_F_ROM_FIXED && hdr->ih_load_addr != f_off) {
+        BOOT_LOG_WRN("Image in %s slot at 0x%x has been built for offset 0x%x"\
+                     ", skipping", slot == 0 ? "primary" : "secondary", f_off,
+                     hdr->ih_load_addr);
+
+        /* If there is address mismatch, the image is not bootable from this
+         * slot.
+         */
+        return 1;
+    }
+    return 0;
+}
+#endif
+
 /*
  * Check that there is a valid image in a slot
  *
@@ -731,12 +770,35 @@ boot_validated_swap_type(struct boot_loader_state *state,
     bool upgrade_valid = false;
 
 #if defined(PM_S1_ADDRESS) || defined(CONFIG_SOC_NRF5340_CPUAPP)
-    const struct flash_area *secondary_fa =
-        BOOT_IMG_AREA(state, BOOT_SECONDARY_SLOT);
-    struct image_header *hdr = (struct image_header *)secondary_fa->fa_off;
+    const struct flash_area *secondary_fa;
+    struct image_header *hdr;
     uint32_t vtable_addr = 0;
     uint32_t *vtable = 0;
     uint32_t reset_addr = 0;
+    bool secondary_in_internal_flash;
+
+    secondary_fa = BOOT_IMG_AREA(state, BOOT_SECONDARY_SLOT);
+
+     if (strcmp(secondary_fa->fa_dev_name, "NRF_FLASH_DRV_NAME") == 0)
+    {
+        printk("=secondary slot in internal Flash=");
+        secondary_in_internal_flash = true;
+    }
+    else
+    {
+        printk("secondary slot in External Flash %x\n\r", secondary_fa->fa_off);
+        secondary_in_internal_flash = false;
+    }   
+    
+    if (secondary_in_internal_flash)
+    {
+        hdr = (struct image_header *)secondary_fa->fa_off;
+    }
+    else
+    {
+        hdr = boot_img_hdr(state, BOOT_SECONDARY_SLOT);
+    }
+   
     /* Patch needed for NCS. Since image 0 (the app) and image 1 (the other
      * B1 slot S0 or S1) share the same secondary slot, we need to check
      * whether the update candidate in the secondary slot is intended for
@@ -746,9 +808,23 @@ boot_validated_swap_type(struct boot_loader_state *state,
      */
 
     if (hdr->ih_magic == IMAGE_MAGIC) {
-        vtable_addr = (uint32_t)hdr + hdr->ih_hdr_size;
-        vtable = (uint32_t *)(vtable_addr);
-        reset_addr = vtable[1];
+        if (secondary_in_internal_flash)
+        {        
+            vtable_addr = (uint32_t)hdr + hdr->ih_hdr_size;
+            vtable = (uint32_t *)(vtable_addr);
+            reset_addr = vtable[1];
+            printk(" In vtable %x, reset addr %x ", vtable_addr, reset_addr); 
+        }
+        else
+        {                       
+            vtable_addr = hdr->ih_hdr_size;
+            int rc = flash_area_read(secondary_fa, vtable_addr+4, &reset_addr, sizeof(reset_addr));
+            if (rc != 0) {
+                return BOOT_SWAP_TYPE_FAIL;
+            }
+            vtable = (uint32_t *) (0x10000000 + SECONDARY_OFFSET_ADDRESS + vtable_addr); //0x10000000 is XIP base address
+            printk(" Ext vtable %x, reset addr %x \n\r", (uint32_t)vtable, reset_addr);             
+        }
 #ifdef PM_S1_ADDRESS
         const struct flash_area *primary_fa;
         int rc = flash_area_open(flash_area_id_from_multi_image_slot(
@@ -800,9 +876,14 @@ boot_validated_swap_type(struct boot_loader_state *state,
             if (rc != 0) {
                 swap_type = BOOT_SWAP_TYPE_FAIL;
             } else {
-                BOOT_LOG_INF("Done updating network core");
+                BOOT_LOG_INF("Done updating network core");       
+                
                 rc = swap_erase_trailer_sectors(state,
                         secondary_fa);
+                if (rc != 0) {
+                    printk("erasing image trailer err=%d\n\r", rc);
+                }
+
                 swap_type = BOOT_SWAP_TYPE_NONE;
             }
         }
@@ -1374,7 +1455,7 @@ boot_verify_dependencies(struct boot_loader_state *state)
         if (rc == 0) {
             /* All dependencies've been satisfied, continue with next image. */
             BOOT_CURR_IMG(state)++;
-        } else {
+	} else if (rc == BOOT_EBADIMAGE) {
             /* Cannot upgrade due to non-met dependencies, so disable all
              * image upgrades.
              */
@@ -1383,7 +1464,10 @@ boot_verify_dependencies(struct boot_loader_state *state)
                 BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_NONE;
             }
             break;
-        }
+	} else {
+	    /* Other error happened, images are inconsistent */
+		return rc;
+	}
     }
     return rc;
 }
@@ -1606,8 +1690,12 @@ boot_prepare_image_for_update(struct boot_loader_state *state,
                      " - too small?", BOOT_MAX_IMG_SECTORS);
         /* Unable to determine sector layout, continue with next image
          * if there is one.
-         */
+         */   
+
         BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_NONE;
+        (void) boot_read_image_header(state, BOOT_PRIMARY_SLOT,
+				      boot_img_hdr(state, BOOT_PRIMARY_SLOT),
+				      bs);        
         return;
     }
 
@@ -2415,11 +2503,20 @@ context_boot_go(struct boot_loader_state *state, struct boot_rsp *rsp)
                             continue;
                         }
                     }
+                    /* Check if image has IMAGE_F_ROM_FIXED flag set and
+                     * is in proper slot.
+                     */
+                    if (boot_rom_address_check(state, slot) != 0) {
+                        continue;
+                    }
                     selected_slot = slot;
                     selected_image_header = hdr;
                 }
             }
 
+            /* Reset rc since we use it above for boot_version_cmp */
+            rc = 0;
+
 #ifdef MCUBOOT_DIRECT_XIP_REVERT
             rc = boot_select_or_erase(&slot_state, selected_slot);
             if (rc != 0) {
