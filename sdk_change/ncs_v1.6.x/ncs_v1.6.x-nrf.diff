diff --git a/applications/nrf_desktop/configuration/nrf52840dk_nrf52840/app_ZDebugMCUBootDFU.conf b/applications/nrf_desktop/configuration/nrf52840dk_nrf52840/app_ZDebugMCUBootDFU.conf
new file mode 100644
index 000000000..15d2f8fc7
--- /dev/null
+++ b/applications/nrf_desktop/configuration/nrf52840dk_nrf52840/app_ZDebugMCUBootDFU.conf
@@ -0,0 +1,256 @@
+#
+# Copyright (c) 2020 Nordic Semiconductor ASA
+#
+# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
+#
+################################################################################
+# Application Configuration
+
+CONFIG_DESKTOP_INIT_LOG_MOTION_EVENT=n
+CONFIG_DESKTOP_INIT_LOG_HID_REPORT_EVENT=n
+CONFIG_DESKTOP_INIT_LOG_HID_REPORT_SENT_EVENT=n
+
+CONFIG_DESKTOP_HID_REPORT_DESC="configuration/common/hid_report_desc.c"
+
+CONFIG_DESKTOP_HID_MOUSE=y
+CONFIG_DESKTOP_HID_STATE_ENABLE=y
+
+CONFIG_DESKTOP_MOTION_BUTTONS_ENABLE=y
+CONFIG_DESKTOP_MOTION_UP_KEY_ID=0
+CONFIG_DESKTOP_MOTION_DOWN_KEY_ID=3
+CONFIG_DESKTOP_MOTION_LEFT_KEY_ID=2
+CONFIG_DESKTOP_MOTION_RIGHT_KEY_ID=1
+
+CONFIG_CAF=y
+CONFIG_CAF_PM_EVENTS=y
+
+CONFIG_CAF_BUTTONS=y
+CONFIG_CAF_BUTTONS_PM_EVENTS=y
+CONFIG_CAF_BUTTONS_POLARITY_INVERSED=y
+
+CONFIG_CAF_LEDS=y
+CONFIG_CAF_LEDS_PM_EVENTS=y
+
+CONFIG_CAF_BLE_STATE=y
+CONFIG_CAF_BLE_BOND_SUPPORTED=y
+
+CONFIG_CAF_BLE_SMP=y
+CONFIG_CAF_INIT_LOG_BLE_SMP_TRANSFER_EVENTS=n
+
+CONFIG_CAF_BLE_ADV=y
+CONFIG_CAF_BLE_ADV_PM_EVENTS=y
+CONFIG_CAF_BLE_ADV_DIRECT_ADV=n
+CONFIG_CAF_BLE_ADV_FAST_ADV=y
+CONFIG_CAF_BLE_ADV_SWIFT_PAIR=y
+
+CONFIG_DESKTOP_USB_ENABLE=y
+
+CONFIG_DESKTOP_POWER_MANAGER_ENABLE=y
+
+CONFIG_DESKTOP_BLE_USE_DEFAULT_ID=y
+
+CONFIG_DESKTOP_BLE_SECURITY_FAIL_TIMEOUT_S=10
+CONFIG_DESKTOP_BLE_LOW_LATENCY_LOCK=y
+
+CONFIG_DESKTOP_HFCLK_LOCK_ENABLE=y
+
+################################################################################
+# Zephyr Configuration
+
+CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=4096
+CONFIG_ISR_STACK_SIZE=1536
+CONFIG_MAIN_STACK_SIZE=768
+CONFIG_IDLE_STACK_SIZE=512
+CONFIG_BT_RX_STACK_SIZE=2048
+CONFIG_BT_HCI_TX_STACK_SIZE_WITH_PROMPT=y
+CONFIG_BT_HCI_TX_STACK_SIZE=1536
+
+CONFIG_BOOT_BANNER=n
+
+CONFIG_NUM_COOP_PRIORITIES=10
+CONFIG_NUM_PREEMPT_PRIORITIES=11
+
+CONFIG_HEAP_MEM_POOL_SIZE=8192
+
+CONFIG_SYS_CLOCK_TICKS_PER_SEC=1000
+CONFIG_SYSTEM_CLOCK_NO_WAIT=y
+
+CONFIG_PM_POLICY_APP=y
+
+CONFIG_HW_STACK_PROTECTION=y
+CONFIG_RESET_ON_FATAL_ERROR=n
+
+CONFIG_GPIO=y
+
+CONFIG_SERIAL=n
+CONFIG_CONSOLE=n
+CONFIG_UART_CONSOLE=n
+
+CONFIG_HWINFO=y
+
+CONFIG_FLASH=y
+CONFIG_FLASH_PAGE_LAYOUT=y
+CONFIG_FLASH_MAP=y
+#CONFIG_FCB=y
+
+CONFIG_SETTINGS=y
+#CONFIG_SETTINGS_FCB=y
+
+CONFIG_REBOOT=y
+
+#CONFIG_SPEED_OPTIMIZATIONS=y
+
+CONFIG_PWM=y
+
+CONFIG_LED=y
+CONFIG_LED_PWM=y
+
+CONFIG_USB=y
+CONFIG_USB_NRFX=y
+CONFIG_USB_DEVICE_STACK=y
+CONFIG_USB_DEVICE_MANUFACTURER="Nordic Semiconductor ASA"
+CONFIG_USB_DEVICE_PRODUCT="Mouse nRF52 Desktop"
+CONFIG_USB_DEVICE_VID=0x1915
+CONFIG_USB_DEVICE_PID=0x52DE
+CONFIG_USB_DEVICE_REMOTE_WAKEUP=y
+CONFIG_USB_DEVICE_HID=y
+CONFIG_USB_DEVICE_LOG_LEVEL_OFF=y
+CONFIG_USB_DRIVER_LOG_LEVEL_OFF=y
+CONFIG_USB_HID_POLL_INTERVAL_MS=1
+
+
+CONFIG_BT_L2CAP_TX_MTU=260
+CONFIG_BT_BUF_ACL_RX_SIZE=264
+
+
+CONFIG_BT=y
+CONFIG_BT_SETTINGS=y
+CONFIG_BT_SMP=y
+CONFIG_BT_SIGNING=y
+CONFIG_BT_MAX_PAIRED=2
+CONFIG_BT_ID_MAX=3
+CONFIG_BT_LL_SOFTDEVICE=y
+
+CONFIG_BT_DEVICE_NAME="Mouse nRF52 Desktop"
+CONFIG_BT_DEVICE_APPEARANCE=962
+
+CONFIG_BT_CTLR=y
+CONFIG_BT_CTLR_CONN_PARAM_REQ=n
+CONFIG_BT_CTLR_LLPM=y
+CONFIG_BT_CTLR_TX_PWR_0=y
+CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL=y
+CONFIG_BT_CONN_TX_MAX=4
+
+CONFIG_BT_DATA_LEN_UPDATE=n
+CONFIG_BT_AUTO_PHY_UPDATE=n
+
+CONFIG_BT_PERIPHERAL=y
+CONFIG_BT_PERIPHERAL_PREF_MIN_INT=6
+CONFIG_BT_PERIPHERAL_PREF_MAX_INT=6
+CONFIG_BT_PERIPHERAL_PREF_SLAVE_LATENCY=99
+CONFIG_BT_PERIPHERAL_PREF_TIMEOUT=400
+
+CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT=1000
+
+CONFIG_BT_WHITELIST=y
+
+CONFIG_BT_GATT_UUID16_POOL_SIZE=27
+CONFIG_BT_GATT_CHRC_POOL_SIZE=7
+CONFIG_BT_SETTINGS_CCC_STORE_ON_WRITE=y
+CONFIG_BT_SETTINGS_CCC_LAZY_LOADING=n
+
+CONFIG_BT_DIS=y
+CONFIG_BT_DIS_MANUF="Nordic Semiconductor ASA"
+CONFIG_BT_DIS_MODEL="Mouse nRF52 Desktop"
+CONFIG_BT_DIS_PNP=y
+CONFIG_BT_DIS_PNP_VID_SRC=2
+CONFIG_BT_DIS_PNP_VID=0x1915
+CONFIG_BT_DIS_PNP_PID=0x52DE
+CONFIG_BT_DIS_PNP_VER=0x0100
+
+CONFIG_BT_HIDS_INPUT_REP_MAX=1
+CONFIG_BT_HIDS_OUTPUT_REP_MAX=0
+CONFIG_BT_HIDS_FEATURE_REP_MAX=1
+CONFIG_BT_HIDS_ATTR_MAX=19
+CONFIG_BT_HIDS_DEFAULT_PERM_RW_ENCRYPT=y
+CONFIG_BT_CONN_CTX=y
+
+CONFIG_ENTROPY_CC3XX=n
+
+CONFIG_EVENT_MANAGER=y
+CONFIG_LINKER_ORPHAN_SECTION_PLACE=y
+
+################################################################################
+
+CONFIG_ASSERT=y
+CONFIG_ASSERT_LEVEL=2
+
+CONFIG_LOG=y
+CONFIG_LOG_DEFAULT_LEVEL=2
+CONFIG_LOG_BACKEND_RTT=y
+CONFIG_LOG_BACKEND_RTT_MODE_DROP=y
+CONFIG_LOG_MODE_OVERFLOW=y
+CONFIG_LOG_PRINTK=y
+CONFIG_LOG_PRINTK_MAX_STRING_LENGTH=256
+CONFIG_LOG_BUFFER_SIZE=4096
+CONFIG_LOG_BACKEND_RTT_MESSAGE_SIZE=256
+CONFIG_LOG_STRDUP_BUF_COUNT=64
+CONFIG_LOG_STRDUP_MAX_STRING=64
+CONFIG_LOG_BACKEND_SHOW_COLOR=n
+CONFIG_LOG_BACKEND_FORMAT_TIMESTAMP=n
+CONFIG_LOG_PROCESS_THREAD_STACK_SIZE=1024
+
+CONFIG_CONSOLE=y
+CONFIG_USE_SEGGER_RTT=y
+CONFIG_SEGGER_RTT_BUFFER_SIZE_UP=4096
+CONFIG_RTT_CONSOLE=y
+CONFIG_UART_CONSOLE=n
+
+CONFIG_LOG=y
+CONFIG_LOG_DEFAULT_LEVEL=3
+CONFIG_LOG_BACKEND_UART=y
+CONFIG_LOG_BACKEND_RTT=n
+CONFIG_LOG_BACKEND_RTT_MODE_DROP=y
+CONFIG_LOG_MODE_OVERFLOW=y
+CONFIG_LOG_PRINTK=y
+CONFIG_LOG_PRINTK_MAX_STRING_LENGTH=256
+CONFIG_LOG_BUFFER_SIZE=4096
+CONFIG_LOG_BACKEND_RTT_MESSAGE_SIZE=256
+CONFIG_LOG_STRDUP_BUF_COUNT=64
+CONFIG_LOG_STRDUP_MAX_STRING=64
+CONFIG_LOG_BACKEND_SHOW_COLOR=n
+CONFIG_LOG_BACKEND_FORMAT_TIMESTAMP=y
+CONFIG_CONSOLE=y
+CONFIG_USE_SEGGER_RTT=n
+CONFIG_SEGGER_RTT_BUFFER_SIZE_UP=4096
+CONFIG_RTT_CONSOLE=n
+CONFIG_UART_CONSOLE=y
+
+CONFIG_SERIAL=y
+
+CONFIG_BT_SETTINGS=y
+CONFIG_FLASH=y
+CONFIG_FLASH_PAGE_LAYOUT=y
+CONFIG_FLASH_MAP=y
+CONFIG_NVS=y
+CONFIG_SETTINGS=y
+
+CONFIG_BT_SMP_ALLOW_UNAUTH_OVERWRITE=y
+CONFIG_BT_USE_DEBUG_KEYS=y
+CONFIG_BT_STORE_DEBUG_KEYS=y
+CONFIG_BT_RX_STACK_SIZE=4096
+
+## thread monitor ##
+CONFIG_THREAD_ANALYZER=y
+CONFIG_THREAD_NAME=y
+
+################################################################################
+# Bootloader Configuration
+
+CONFIG_NRF_DFU=y
+CONFIG_NRF_DFU_LOG_LEVEL=3
+CONFIG_NRF_DFU_BT=y
+CONFIG_BOOTLOADER_MCUBOOT=y
+CONFIG_IMG_MANAGER=y
+CONFIG_MCUBOOT_IMG_MANAGER=y
+CONFIG_IMG_BLOCK_BUF_SIZE=4096
diff --git a/applications/nrf_desktop/configuration/nrf52840dk_nrf52840/mcuboot_ZDebugMCUBootDFU.conf b/applications/nrf_desktop/configuration/nrf52840dk_nrf52840/mcuboot_ZDebugMCUBootDFU.conf
new file mode 100644
index 000000000..8464e5ef1
--- /dev/null
+++ b/applications/nrf_desktop/configuration/nrf52840dk_nrf52840/mcuboot_ZDebugMCUBootDFU.conf
@@ -0,0 +1,39 @@
+#
+# Copyright (c) 2020 Nordic Semiconductor ASA
+#
+# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
+#
+CONFIG_SIZE_OPTIMIZATIONS=y
+
+# Disable memory guard to avoid false faults in application after boot
+CONFIG_HW_STACK_PROTECTION=n
+
+CONFIG_SYSTEM_CLOCK_DISABLE=y
+CONFIG_SYSTEM_CLOCK_NO_WAIT=y
+CONFIG_PM=n
+
+CONFIG_MAIN_STACK_SIZE=10240
+CONFIG_MBEDTLS_CFG_FILE="mcuboot-mbedtls-cfg.h"
+
+CONFIG_BOOT_MAX_IMG_SECTORS=256
+CONFIG_BOOT_BOOTSTRAP=n
+
+CONFIG_BOOT_ENCRYPT_RSA=n
+CONFIG_BOOT_SIGNATURE_TYPE_RSA=y
+CONFIG_BOOT_SIGNATURE_TYPE_ECDSA_P256=n
+CONFIG_BOOT_SIGNATURE_KEY_FILE="mcuboot_private.pem"
+
+# Flash
+CONFIG_FLASH=y
+CONFIG_BOOT_ERASE_PROGRESSIVELY=y
+#CONFIG_SOC_FLASH_NRF_EMULATE_ONE_BYTE_WRITE_ACCESS=y
+
+# Logger
+CONFIG_USE_SEGGER_RTT=y
+CONFIG_LOG=y
+CONFIG_LOG_DEFAULT_LEVEL=2
+CONFIG_LOG_MAX_LEVEL=3
+CONFIG_LOG_PRINTK=y
+CONFIG_LOG_MODE_IMMEDIATE=y
+CONFIG_LOG_BACKEND_SHOW_COLOR=n
+CONFIG_LOG_BACKEND_FORMAT_TIMESTAMP=n
diff --git a/applications/nrf_desktop/src/events/CMakeLists.txt b/applications/nrf_desktop/src/events/CMakeLists.txt
index 7f836dd79..65eb2c87f 100644
--- a/applications/nrf_desktop/src/events/CMakeLists.txt
+++ b/applications/nrf_desktop/src/events/CMakeLists.txt
@@ -25,3 +25,6 @@ target_sources_ifdef(CONFIG_DESKTOP_USB_ENABLE app
 
 target_sources_ifdef(CONFIG_DESKTOP_HIDS_ENABLE app
 			PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/hids_event.c)
+
+target_sources_ifdef(CONFIG_NRF_DFU app
+			PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/ble_nrf_dfu_event.c)
\ No newline at end of file
diff --git a/applications/nrf_desktop/src/events/ble_nrf_dfu_event.c b/applications/nrf_desktop/src/events/ble_nrf_dfu_event.c
new file mode 100644
index 000000000..0313097d6
--- /dev/null
+++ b/applications/nrf_desktop/src/events/ble_nrf_dfu_event.c
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) 2018-2021 Nordic Semiconductor ASA
+ *
+ * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
+ */
+
+#include <ble_nrf_dfu_event.h>
+
+
+EVENT_TYPE_DEFINE(ble_nrf_dfu_event,
+		  IS_ENABLED(CONFIG_NRF_DFU),
+		  NULL,
+		  NULL);
diff --git a/applications/nrf_desktop/src/events/ble_nrf_dfu_event.h b/applications/nrf_desktop/src/events/ble_nrf_dfu_event.h
new file mode 100644
index 000000000..a2527d316
--- /dev/null
+++ b/applications/nrf_desktop/src/events/ble_nrf_dfu_event.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2021 Nordic Semiconductor ASA
+ *
+ * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
+ */
+
+#ifndef _BLE_NRF_DFU_EVENT_H_
+#define _BLE_NRF_DFU_EVENT_H_
+
+/**
+ * @brief Bluetooth LE SMP Event
+ * @defgroup ble_smp_event Bluetooth LE SMP Event
+ * @{
+ */
+
+#include "event_manager.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @brief Bluetooth LE SMP transfer event. */
+struct ble_nrf_dfu_event {
+	struct event_header header;
+};
+EVENT_TYPE_DECLARE(ble_nrf_dfu_event);
+
+#ifdef __cplusplus
+}
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* _BLE_NRF_DFU_EVENT_H_ */
diff --git a/applications/nrf_desktop/src/modules/CMakeLists.txt b/applications/nrf_desktop/src/modules/CMakeLists.txt
index 2587405be..20245e403 100644
--- a/applications/nrf_desktop/src/modules/CMakeLists.txt
+++ b/applications/nrf_desktop/src/modules/CMakeLists.txt
@@ -51,6 +51,9 @@ target_sources_ifdef(CONFIG_DESKTOP_POWER_MANAGER_ENABLE
 
 target_sources_ifdef(CONFIG_DESKTOP_CONFIG_CHANNEL_DFU_ENABLE
 		     app PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/dfu.c)
+			 
+target_sources_ifdef(CONFIG_NRF_DFU
+		     app PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/nrf_dfu.c)			 
 
 target_sources_ifdef(CONFIG_DESKTOP_FN_KEYS_ENABLE
 		     app PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/fn_keys.c)
diff --git a/applications/nrf_desktop/src/modules/ble_latency.c b/applications/nrf_desktop/src/modules/ble_latency.c
index c7d5feeb3..40600a82d 100644
--- a/applications/nrf_desktop/src/modules/ble_latency.c
+++ b/applications/nrf_desktop/src/modules/ble_latency.c
@@ -12,6 +12,7 @@
 #include "ble_event.h"
 #include "config_event.h"
 #include <caf/events/power_event.h>
+#include "ble_nrf_dfu_event.h"
 
 #define MODULE ble_latency
 #include <caf/events/module_state_event.h>
@@ -288,6 +289,13 @@ static bool event_handler(const struct event_header *eh)
 		return false;
 	}
 
+	if (IS_ENABLED(CONFIG_NRF_DFU) &&
+	    is_ble_nrf_dfu_event(eh)) {
+		use_low_latency();
+
+		return false;
+	}
+
 	if (is_ble_peer_conn_params_event(eh)) {
 		conn_params_updated(cast_ble_peer_conn_params_event(eh));
 
@@ -331,6 +339,9 @@ EVENT_SUBSCRIBE(MODULE, ble_smp_transfer_event);
 #if CONFIG_DESKTOP_CONFIG_CHANNEL_ENABLE
 EVENT_SUBSCRIBE_EARLY(MODULE, config_event);
 #endif
+#if CONFIG_NRF_DFU
+EVENT_SUBSCRIBE(MODULE, ble_nrf_dfu_event);
+#endif
 #if CONFIG_DESKTOP_BLE_LOW_LATENCY_LOCK
 EVENT_SUBSCRIBE(MODULE, power_down_event);
 EVENT_SUBSCRIBE(MODULE, wake_up_event);
diff --git a/applications/nrf_desktop/src/modules/nrf_dfu.c b/applications/nrf_desktop/src/modules/nrf_dfu.c
new file mode 100644
index 000000000..daafdbf29
--- /dev/null
+++ b/applications/nrf_desktop/src/modules/nrf_dfu.c
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2019 Nordic Semiconductor ASA
+ *
+ * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
+ */
+
+#include <inttypes.h>
+
+#include <zephyr/types.h>
+#include <sys/byteorder.h>
+#include <storage/flash_map.h>
+#include <pm_config.h>
+
+#include "event_manager.h"
+#include "ble_nrf_dfu_event.h"
+#include <caf/events/ble_common_event.h>
+#include "nrf_dfu_settings.h"
+#include "nrf_dfu.h"
+
+#define MODULE nrf_dfu
+#include <caf/events/module_state_event.h>
+
+#include <logging/log.h>
+LOG_MODULE_REGISTER(MODULE, 3);
+
+static void submit_nrf_dfu_event(void)
+{
+	struct ble_nrf_dfu_event *event = new_ble_nrf_dfu_event();
+
+	EVENT_SUBMIT(event);        
+}
+
+/**@brief Function for handling DFU events.
+ */
+static void dfu_observer(nrf_dfu_evt_type_t evt_type)
+{
+    switch (evt_type)
+    {
+        case NRF_DFU_EVT_DFU_STARTED:
+        case NRF_DFU_EVT_OBJECT_RECEIVED:
+             submit_nrf_dfu_event();
+            break;
+        case NRF_DFU_EVT_DFU_COMPLETED:
+        case NRF_DFU_EVT_DFU_ABORTED:
+			LOG_INF("resetting...");
+			while(log_process(false));
+            sys_reboot(SYS_REBOOT_WARM);
+            break;
+        case NRF_DFU_EVT_TRANSPORT_DEACTIVATED:
+            // Reset the internal state of the DFU settings to the last stored state.
+			LOG_INF("NRF_DFU_EVT_TRANSPORT_DEACTIVATED");
+            nrf_dfu_settings_reinit();
+            break;
+        default:
+            break;
+    }
+
+}
+
+int dfu_init(void)
+{
+    int ret_val;
+
+    ret_val = nrf_dfu_settings_init(true);
+    if (ret_val != NRF_SUCCESS)
+	{
+		LOG_WRN("dfu settings init err %d", ret_val);
+	}
+
+    ret_val = nrf_dfu_init(dfu_observer);
+    if (ret_val != NRF_SUCCESS)
+	{
+		LOG_WRN("dfu init err %d", ret_val);
+	}
+
+    return ret_val;
+}
+
+static bool event_handler(const struct event_header *eh)
+{
+	if (is_module_state_event(eh)) {
+		const struct module_state_event *event =
+			cast_module_state_event(eh);
+
+		if (check_state(event, MODULE_ID(ble_state), MODULE_STATE_READY)) {
+			int err = 0;
+			err = dfu_init();
+			if (err) {
+				LOG_ERR("dfu service init err %d", err);				
+			}
+		}
+		return false;
+	}
+
+	/* If event is unhandled, unsubscribe. */
+	__ASSERT_NO_MSG(false);
+
+	return false;
+}
+
+EVENT_LISTENER(MODULE, event_handler);
+EVENT_SUBSCRIBE(MODULE, module_state_event);
+
diff --git a/cmake/partition_manager.cmake b/cmake/partition_manager.cmake
index 9aa61b61b..4efbc6105 100644
--- a/cmake/partition_manager.cmake
+++ b/cmake/partition_manager.cmake
@@ -422,7 +422,7 @@ else()
       endforeach()
 
       if (CONFIG_NRF53_UPGRADE_NETWORK_CORE
-          AND CONFIG_HCI_RPMSG_BUILD_STRATEGY_FROM_SOURCE)
+          AND (CONFIG_HCI_RPMSG_BUILD_STRATEGY_FROM_SOURCE OR CONFIG_BLE_NETWORK_CORE))
           # Create symbols for the offset reqired for moving the signed network
           # core application to MCUBoots secondary slot. This is needed
           # because  objcopy does not support arithmetic expressions as argument
diff --git a/modules/mcuboot/CMakeLists.txt b/modules/mcuboot/CMakeLists.txt
index 6743dd426..2eec188d9 100644
--- a/modules/mcuboot/CMakeLists.txt
+++ b/modules/mcuboot/CMakeLists.txt
@@ -236,7 +236,7 @@ if(CONFIG_BOOTLOADER_MCUBOOT)
       )
 
     if (CONFIG_NRF53_UPGRADE_NETWORK_CORE
-        AND CONFIG_HCI_RPMSG_BUILD_STRATEGY_FROM_SOURCE)
+        AND (CONFIG_HCI_RPMSG_BUILD_STRATEGY_FROM_SOURCE OR CONFIG_BLE_NETWORK_CORE))
       # Network core application updates are enabled.
       # We know this since MCUBoot is enabled on the application core, and
       # a network core child image is included in the build.
diff --git a/samples/CMakeLists.txt b/samples/CMakeLists.txt
index ac7f85bb3..c5e28d61f 100644
--- a/samples/CMakeLists.txt
+++ b/samples/CMakeLists.txt
@@ -104,7 +104,7 @@ endif()
 # Automatically include the multiprotocol_rpmsg as child image when both RPMSG HCI
 # and RPMSG 802.15.4 Serialization are enabled or the hci_rpmsg sample when
 # only RPMSG HCI is enabled. For any of these samples change the board to be the network core.
-if (CONFIG_BT_RPMSG_NRF53)
+if (CONFIG_BT_RPMSG_NRF53 OR CONFIG_BLE_NETWORK_CORE)
   if (CONFIG_SOC_NRF5340_CPUAPP)
 
     if (CONFIG_NRF_802154_SER_HOST)
@@ -114,9 +114,15 @@ if (CONFIG_BT_RPMSG_NRF53)
       "CONFIG_BT_RPMSG_NRF53 and CONFIG_NRF_802154_SER_HOST are set to 'y'")
     else()
       set(NETCORE_IMAGE "hci_rpmsg")
-      set(NETCORE_IMAGE_PATH "${ZEPHYR_BASE}/samples/bluetooth/${NETCORE_IMAGE}")
-      message("Adding 'hci_rpmsg' firmware as child image since "
-      "CONFIG_BT_RPMSG_NRF53 is set to 'y'")
+      if (CONFIG_BLE_NETWORK_CORE)
+        set(NETCORE_IMAGE_PATH "${ZEPHYR_BASE}/../sample/nrf53_ble/ble_netcore")
+        message("Adding 'ble_netcore' firmware as child image since "
+        "CONFIG_BLE_NETWORK_CORE is set to 'y'")	  
+      else()
+        set(NETCORE_IMAGE_PATH "${ZEPHYR_BASE}/samples/bluetooth/${NETCORE_IMAGE}")
+        message("Adding 'hci_rpmsg' firmware as child image since "
+        "CONFIG_BT_RPMSG_NRF53 is set to 'y'")
+      endif()
     endif()
 
     if (CONFIG_BT_LL_SOFTDEVICE_DEFAULT)
diff --git a/samples/bluetooth/peripheral_uart/prj.conf b/samples/bluetooth/peripheral_uart/prj.conf
index cd6df0664..f548601ca 100644
--- a/samples/bluetooth/peripheral_uart/prj.conf
+++ b/samples/bluetooth/peripheral_uart/prj.conf
@@ -46,5 +46,6 @@ CONFIG_LOG=y
 CONFIG_USE_SEGGER_RTT=y
 CONFIG_LOG_BACKEND_RTT=y
 CONFIG_LOG_BACKEND_UART=n
+CONFIG_LOG_PRINTK=y
 
-CONFIG_ASSERT=y
+CONFIG_ASSERT=y
\ No newline at end of file
diff --git a/samples/nrf5340/netboot/src/main.c b/samples/nrf5340/netboot/src/main.c
index 11807d351..405d8cd34 100644
--- a/samples/nrf5340/netboot/src/main.c
+++ b/samples/nrf5340/netboot/src/main.c
@@ -37,11 +37,14 @@ void main(void)
 		 */
 		uint32_t update_addr = (uint32_t)pcd_cmd_data_ptr_get();
 
-		valid = bl_validate_firmware(s0_addr, update_addr);
-		if (!valid) {
-			printk("Unable to find valid firmware inside %p\n\r",
-				(void *)update_addr);
-			goto failure;
+		if (update_addr < 0x10000000)
+		{
+			valid = bl_validate_firmware(s0_addr, update_addr);
+			if (!valid) {
+				printk("Unable to find valid firmware inside %p\n\r",
+					(void *)update_addr);
+				goto failure;
+			}
 		}
 
 		err = pcd_fw_copy(fdev);
@@ -55,11 +58,12 @@ void main(void)
 		 * is performed by the application core. This check is only
 		 * done to verify that the flash copy operation was successful.
 		 */
+		
 		valid = bl_validate_firmware(s0_addr, s0_addr);
 		if (valid) {
 			pcd_fw_copy_done();
 		} else {
-			printk("Unable to find valid firmware inside %p\n\r",
+			printk("2Unable to find valid firmware = %p\n\r",
 				(void *)s0_addr);
 			goto failure;
 		}
diff --git a/subsys/CMakeLists.txt b/subsys/CMakeLists.txt
index 16945ff8f..5a9e461fd 100644
--- a/subsys/CMakeLists.txt
+++ b/subsys/CMakeLists.txt
@@ -47,3 +47,6 @@ add_subdirectory(debug)
 add_subdirectory(partition_manager)
 
 add_subdirectory_ifdef(CONFIG_NRF_RPC nrf_rpc)
+
+add_subdirectory_ifdef(CONFIG_NRF_DFU nrf_dfu)
+add_subdirectory_ifdef(CONFIG_NRF_DFU_RPC_NET nrf_dfu)
diff --git a/subsys/Kconfig b/subsys/Kconfig
index 34df8730f..e06388785 100644
--- a/subsys/Kconfig
+++ b/subsys/Kconfig
@@ -42,3 +42,5 @@ rsource "zigbee/Kconfig"
 rsource "mgmt/fmfu/Kconfig"
 
 rsource "caf/Kconfig"
+
+rsource "nrf_dfu/Kconfig"
diff --git a/subsys/nrf_dfu/CMakeLists.txt b/subsys/nrf_dfu/CMakeLists.txt
new file mode 100644
index 000000000..eccf8476f
--- /dev/null
+++ b/subsys/nrf_dfu/CMakeLists.txt
@@ -0,0 +1,16 @@
+#
+# Copyright (c) 2019-2021 Nordic Semiconductor ASA
+#
+# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
+#
+
+zephyr_include_directories(inc)
+zephyr_library()
+
+zephyr_library_sources_ifdef(CONFIG_NRF_DFU_BT nrf_dfu_ble.c)
+add_subdirectory_ifdef(CONFIG_NRF_DFU common)
+zephyr_library_sources_ifdef(CONFIG_NRF_DFU_RPC_APP adapt_rpc_app.c)
+zephyr_library_sources_ifdef(CONFIG_NRF_DFU_RPC_NET adapt_rpc_net.c)
+zephyr_library_sources_ifdef(CONFIG_NRF_DFU_RPC_NET common/nrf_dfu_handling_error.c)
+
+zephyr_linker_sources_ifdef(CONFIG_NRF_DFU SECTIONS dfu_tran_sect.ld)
\ No newline at end of file
diff --git a/subsys/nrf_dfu/Kconfig b/subsys/nrf_dfu/Kconfig
new file mode 100644
index 000000000..dd76a38b0
--- /dev/null
+++ b/subsys/nrf_dfu/Kconfig
@@ -0,0 +1,50 @@
+# USB configuration options
+
+# Copyright (c) 2016 Wind River Systems, Inc.
+# SPDX-License-Identifier: Apache-2.0
+
+menu "nRF DFU module"
+
+menuconfig NRF_DFU
+	bool "DFU module ported from nRF5 SDK"
+	help
+	  "Enable Nordic DFU module"
+
+config NRF_DFU_BT
+	bool "Enable BLE transport"	
+	help
+	  "Transfer the new image by BLE transport"
+	  
+config NRF_DFU_RPC_APP
+	bool "transform BLE transport to RPC API on app core side"	
+	help
+	  "Can only be used on appcore. Transform BLE transport to RPC API on app core side"
+
+config NRF_DFU_RPC_NET
+	bool "transform BLE transport to RPC API on net core side"	
+	help
+	  "Can only be used on netcore. Transform BLE transport to RPC API on net core side"
+
+config NRF_DFU_LOG_LEVEL
+	int "Set the log level of nrf_dfu module"
+	default 2	
+	help
+	  Set the log level of nrf_dfu module
+
+config NRF_DFU_THREAD_STACK_SIZE
+	int "Set the stack size of DFU thread"
+	default 1536	
+	help
+	  Set the stack size of DFU thread
+
+config NRF_DFU_THREAD_PRIO
+	int "Set the priority of DFU thread"
+	default 8	
+	help
+	  Set the priority of DFU thread	  
+
+module = NRF_DFU
+module-str = NRF_DFU
+source "${ZEPHYR_BASE}/subsys/logging/Kconfig.template.log_config"
+	  
+endmenu
diff --git a/subsys/nrf_dfu/adapt_rpc_app.c b/subsys/nrf_dfu/adapt_rpc_app.c
new file mode 100644
index 000000000..0723f1038
--- /dev/null
+++ b/subsys/nrf_dfu/adapt_rpc_app.c
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) 2020 Nordic Semiconductor ASA
+ *
+ * SPDX-License-Identifier: LicenseRef-BSD-5-Clause-Nordic
+ */
+#include <errno.h>
+#include <init.h>
+#include <tinycbor/cbor.h>
+#include <nrf_rpc_cbor.h>
+#include "common_ids.h"
+#include <logging/log.h>
+#include "nrf_dfu_transport.h"
+#include "nrf_dfu_req_handler.h"
+#include "nrf_dfu_handling_error.h"
+#include "app_util.h"
+
+#define LOG_MODULE_NAME rpc_dfu_app
+LOG_MODULE_REGISTER(LOG_MODULE_NAME, CONFIG_NRF_DFU_LOG_LEVEL);
+
+#define CBOR_BUF_SIZE 16
+
+void rpc_dfu_req_handler_callback(nrf_dfu_response_t * p_res, void * p_context);
+
+NRF_RPC_GROUP_DEFINE(rpc_dfu, "rpc_dfu", NULL, NULL, NULL);
+
+static void rsp_error_code_send(int err_code)
+{
+	struct nrf_rpc_cbor_ctx ctx;
+
+	NRF_RPC_CBOR_ALLOC(ctx, CBOR_BUF_SIZE);
+
+	cbor_encode_int(&ctx.encoder, err_code);
+
+	nrf_rpc_cbor_rsp_no_err(&ctx);
+}
+
+static void rpc_nrf_dfu_req_handler_on_req(CborValue *packet, void *handler_data)
+{	
+	CborError cbor_err;
+	int err;
+	size_t len;
+	uint8_t buf[300];
+    nrf_dfu_request_t req;
+	
+	err = 0;
+	len = sizeof(buf);
+	cbor_err = cbor_value_copy_byte_string(packet, buf, &len, NULL);	
+	if (cbor_err != CborNoError || len < sizeof(nrf_dfu_request_t)) {		
+		goto cbor_error_exit;	
+	}
+
+	memcpy((uint8_t *)&req, buf, sizeof(nrf_dfu_request_t));
+
+	if (req.request == NRF_DFU_OP_OBJECT_WRITE)
+	{	
+		req.write.p_data = &buf[sizeof(nrf_dfu_request_t)];		
+	}
+
+	nrf_rpc_cbor_decoding_done(packet);
+
+    req.callback.response =  rpc_dfu_req_handler_callback;
+    req.callback.write = NULL;   	
+		
+	LOG_INF("req_op %d req_type %d", req.request, req.select.object_type);
+	err = nrf_dfu_req_handler_on_req(&req);
+	
+	rsp_error_code_send(err);
+
+	return;
+
+cbor_error_exit:
+	LOG_ERR("rpc app err");
+	nrf_rpc_cbor_decoding_done(packet);	    
+}
+
+NRF_RPC_CBOR_CMD_DECODER(rpc_dfu, rpc_nrf_dfu_req_handler_on_req_cb,
+			 RPC_CMD_NRF_DFU_REQ_HANDLER_ON_REQ,
+			 rpc_nrf_dfu_req_handler_on_req, NULL);
+
+
+static void rsp_error_code_handle(CborValue *packet, void *handler_data)
+{
+	CborError cbor_err;
+
+	if (!cbor_value_is_integer(packet)) {
+		*(int *)handler_data = -NRF_EINVAL;
+	}
+
+	cbor_err = cbor_value_get_int(packet, (int *)handler_data);
+	if (cbor_err != CborNoError) {
+		*(int *)handler_data = -NRF_EINVAL;
+	}
+}
+
+void rpc_dfu_req_handler_callback(nrf_dfu_response_t * p_res, void * p_context)
+{
+	int err;
+	int result;
+	struct nrf_rpc_cbor_ctx ctx;
+
+    __ASSERT_NO_MSG(p_res);
+
+	NRF_RPC_CBOR_ALLOC(ctx, CBOR_BUF_SIZE + sizeof(nrf_dfu_response_t));
+	
+	cbor_encode_byte_string(&ctx.encoder, (const uint8_t *)p_res, sizeof(nrf_dfu_response_t));	
+
+	err = nrf_rpc_cbor_cmd(&rpc_dfu, RPC_CMD_DFU_REQ_HANDLER_CALLBACK, &ctx,
+			       rsp_error_code_handle, &result);
+	
+    LOG_INF("req callback err=%d, ret=%d", err, result);
+ 
+}
diff --git a/subsys/nrf_dfu/adapt_rpc_net.c b/subsys/nrf_dfu/adapt_rpc_net.c
new file mode 100644
index 000000000..05ec86010
--- /dev/null
+++ b/subsys/nrf_dfu/adapt_rpc_net.c
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 2020 Nordic Semiconductor ASA
+ *
+ * SPDX-License-Identifier: LicenseRef-BSD-5-Clause-Nordic
+ */
+
+/** @file
+ * @brief Bluetooth transport for the mcumgr SMP protocol.
+ */
+
+#include <errno.h>
+
+#include <zephyr.h>
+#include <init.h>
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/uuid.h>
+#include <bluetooth/gatt.h>
+#include <tinycbor/cbor.h>
+#include <nrf_rpc_cbor.h>
+#include "common_ids.h"
+#include <logging/log.h>
+#include "nrf_dfu_transport.h"
+#include "nrf_dfu_req_handler.h"
+#include "nrf_dfu_handling_error.h"
+#include "app_util.h"
+
+#define LOG_MODULE_NAME rpc_dfu_net
+LOG_MODULE_REGISTER(LOG_MODULE_NAME, CONFIG_NRF_DFU_LOG_LEVEL);
+
+typedef struct {
+	void *fifo_reserved;
+	nrf_dfu_request_t req;	
+}dfu_data_t;
+
+static K_FIFO_DEFINE(fifo_dfu_data);
+
+#define CBOR_BUF_SIZE 16
+
+NRF_RPC_GROUP_DEFINE(rpc_dfu, "rpc_dfu", NULL, NULL, NULL);
+
+static void rsp_error_code_send(int err_code)
+{
+	struct nrf_rpc_cbor_ctx ctx;
+
+	NRF_RPC_CBOR_ALLOC(ctx, CBOR_BUF_SIZE);
+
+	cbor_encode_int(&ctx.encoder, err_code);
+
+	nrf_rpc_cbor_rsp_no_err(&ctx);
+}
+
+static void rsp_error_code_handle(CborValue *value, void *handler_data)
+{
+	CborError cbor_err;
+
+	if (!cbor_value_is_integer(value)) {
+		*(int *)handler_data = -NRF_EINVAL;
+	}
+
+	cbor_err = cbor_value_get_int(value, (int *)handler_data);
+	if (cbor_err != CborNoError) {
+		*(int *)handler_data = -NRF_EINVAL;
+	}
+}
+
+
+uint32_t nrf_dfu_req_handler_on_req(nrf_dfu_request_t * p_req)
+{
+	int err;
+	int result = 0;
+	struct nrf_rpc_cbor_ctx ctx;
+	uint8_t buf[300];
+	uint16_t len;
+	
+	__ASSERT_NO_MSG(p_req);
+
+	len = sizeof(nrf_dfu_request_t);
+	memcpy(buf, p_req, len);	
+
+	LOG_INF("req_op %d req_type %x len %d", p_req->request, p_req->select.object_type, p_req->write.len);
+	
+	if(p_req->request == NRF_DFU_OP_OBJECT_WRITE)
+	{		
+		memcpy(buf + sizeof(nrf_dfu_request_t), p_req->write.p_data, p_req->write.len);
+		len += p_req->write.len;		
+	}
+
+	NRF_RPC_CBOR_ALLOC(ctx, CBOR_BUF_SIZE + len);
+
+	cbor_encode_byte_string(&ctx.encoder, buf, len);	
+
+	err = nrf_rpc_cbor_cmd(&rpc_dfu, RPC_CMD_NRF_DFU_REQ_HANDLER_ON_REQ, &ctx,
+			       rsp_error_code_handle, &result);
+	
+	if (err < 0) {
+		LOG_ERR("net rpc cbor cmd err %d", err);
+		return err;
+	}
+	
+	return result;
+}
+
+
+static void rpc_dfu_req_handler_callback(CborValue *packet, void *handler_data)
+{
+	CborError cbor_err;
+	int err = 0;
+	size_t length;
+	nrf_dfu_response_t response;
+
+	length = sizeof(nrf_dfu_response_t);
+	cbor_err = cbor_value_copy_byte_string(packet, (uint8_t *)&response, &length,
+					       NULL);
+	if (cbor_err != CborNoError || length != sizeof(nrf_dfu_response_t)) {
+		LOG_ERR("net rpc cbor err");
+		err = -EBADMSG;		
+	}
+	else
+	{		
+		ble_dfu_req_handler_callback(&response, NULL);
+	}
+
+	nrf_rpc_cbor_decoding_done(packet);
+
+	rsp_error_code_send(err);
+
+}
+
+NRF_RPC_CBOR_CMD_DECODER(rpc_dfu, rpc_dfu_req_handler_cb,
+			 RPC_CMD_DFU_REQ_HANDLER_CALLBACK,
+			 rpc_dfu_req_handler_callback, NULL);
diff --git a/subsys/nrf_dfu/common/CMakeLists.txt b/subsys/nrf_dfu/common/CMakeLists.txt
new file mode 100644
index 000000000..cd5bed211
--- /dev/null
+++ b/subsys/nrf_dfu/common/CMakeLists.txt
@@ -0,0 +1,18 @@
+#
+# Copyright (c) 2019-2021 Nordic Semiconductor ASA
+#
+# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
+#
+
+zephyr_library_sources(crc32.c)
+zephyr_library_sources(nrf_dfu.c)
+zephyr_library_sources(nrf_dfu_flash.c)
+zephyr_library_sources(nrf_dfu_handling_error.c)
+zephyr_library_sources(nrf_dfu_req_handler.c)
+zephyr_library_sources(nrf_dfu_settings.c)
+zephyr_library_sources(nrf_dfu_transport.c)
+zephyr_library_sources(nrf_dfu_validation.c)
+zephyr_library_sources(dfu-cc.pb.c)
+zephyr_library_sources(pb_common.c)
+zephyr_library_sources(pb_decode.c)
+zephyr_linker_sources(SECTIONS dfu_trans.ld)
diff --git a/subsys/nrf_dfu/common/crc32.c b/subsys/nrf_dfu/common/crc32.c
new file mode 100644
index 000000000..0e3e38882
--- /dev/null
+++ b/subsys/nrf_dfu/common/crc32.c
@@ -0,0 +1,61 @@
+/**
+ * Copyright (c) 2013 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#include "sdk_common.h"
+//#if NRF_MODULE_ENABLED(CRC32)
+#include "crc32.h"
+
+#include <stdlib.h>
+
+uint32_t crc32_compute(uint8_t const * p_data, uint32_t size, uint32_t const * p_crc)
+{
+    uint32_t crc;
+
+    crc = (p_crc == NULL) ? 0xFFFFFFFF : ~(*p_crc);
+    for (uint32_t i = 0; i < size; i++)
+    {
+        crc = crc ^ p_data[i];
+        for (uint32_t j = 8; j > 0; j--)
+        {
+            crc = (crc >> 1) ^ (0xEDB88320U & ((crc & 1) ? 0xFFFFFFFF : 0));
+        }
+    }
+    return ~crc;
+}
+//#endif //NRF_MODULE_ENABLED(CRC32)
diff --git a/subsys/nrf_dfu/common/dfu-cc.options b/subsys/nrf_dfu/common/dfu-cc.options
new file mode 100644
index 000000000..de4fcdb86
--- /dev/null
+++ b/subsys/nrf_dfu/common/dfu-cc.options
@@ -0,0 +1,5 @@
+dfu.Hash.hash                       max_size:32
+dfu.SignedCommand.signature         max_size:64
+dfu.InitCommand.sd_req              max_count:16
+dfu.InitCommand.boot_validation     max_count:3
+dfu.BootValidation.bytes            max_size:64
\ No newline at end of file
diff --git a/subsys/nrf_dfu/common/dfu-cc.pb.c b/subsys/nrf_dfu/common/dfu-cc.pb.c
new file mode 100644
index 000000000..fa4a61a3a
--- /dev/null
+++ b/subsys/nrf_dfu/common/dfu-cc.pb.c
@@ -0,0 +1,123 @@
+/**
+ * Copyright (c) 2017 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/* Automatically generated nanopb constant definitions */
+/* Generated by nanopb-0.3.6-dev at Tue Sep 11 14:37:18 2018. */
+
+#include "dfu-cc.pb.h"
+
+/* @@protoc_insertion_point(includes) */
+#if PB_PROTO_HEADER_VERSION != 30
+#error Regenerate this file with the current version of nanopb generator.
+#endif
+
+const bool dfu_init_command_is_debug_default = false;
+
+
+const pb_field_t dfu_hash_fields[3] = {
+    PB_FIELD(  1, UENUM   , REQUIRED, STATIC  , FIRST, dfu_hash_t, hash_type, hash_type, 0),
+    PB_FIELD(  2, BYTES   , REQUIRED, STATIC  , OTHER, dfu_hash_t, hash, hash_type, 0),
+    PB_LAST_FIELD
+};
+
+const pb_field_t dfu_boot_validation_fields[3] = {
+    PB_FIELD(  1, UENUM   , REQUIRED, STATIC  , FIRST, dfu_boot_validation_t, type, type, 0),
+    PB_FIELD(  2, BYTES   , REQUIRED, STATIC  , OTHER, dfu_boot_validation_t, bytes, type, 0),
+    PB_LAST_FIELD
+};
+
+const pb_field_t dfu_init_command_fields[11] = {
+    PB_FIELD(  1, UINT32  , OPTIONAL, STATIC  , FIRST, dfu_init_command_t, fw_version, fw_version, 0),
+    PB_FIELD(  2, UINT32  , OPTIONAL, STATIC  , OTHER, dfu_init_command_t, hw_version, fw_version, 0),
+    PB_FIELD(  3, UINT32  , REPEATED, STATIC  , OTHER, dfu_init_command_t, sd_req, hw_version, 0),
+    PB_FIELD(  4, UENUM   , OPTIONAL, STATIC  , OTHER, dfu_init_command_t, type, sd_req, 0),
+    PB_FIELD(  5, UINT32  , OPTIONAL, STATIC  , OTHER, dfu_init_command_t, sd_size, type, 0),
+    PB_FIELD(  6, UINT32  , OPTIONAL, STATIC  , OTHER, dfu_init_command_t, bl_size, sd_size, 0),
+    PB_FIELD(  7, UINT32  , OPTIONAL, STATIC  , OTHER, dfu_init_command_t, app_size, bl_size, 0),
+    PB_FIELD(  8, MESSAGE , OPTIONAL, STATIC  , OTHER, dfu_init_command_t, hash, app_size, &dfu_hash_fields),
+    PB_FIELD(  9, BOOL    , OPTIONAL, STATIC  , OTHER, dfu_init_command_t, is_debug, hash, &dfu_init_command_is_debug_default),
+    PB_FIELD( 10, MESSAGE , REPEATED, STATIC  , OTHER, dfu_init_command_t, boot_validation, is_debug, &dfu_boot_validation_fields),
+    PB_LAST_FIELD
+};
+
+const pb_field_t dfu_command_fields[3] = {
+    PB_FIELD(  1, UENUM   , OPTIONAL, STATIC  , FIRST, dfu_command_t, op_code, op_code, 0),
+    PB_FIELD(  2, MESSAGE , OPTIONAL, STATIC  , OTHER, dfu_command_t, init, op_code, &dfu_init_command_fields),
+    PB_LAST_FIELD
+};
+
+const pb_field_t dfu_signed_command_fields[4] = {
+    PB_FIELD(  1, MESSAGE , REQUIRED, STATIC  , FIRST, dfu_signed_command_t, command, command, &dfu_command_fields),
+    PB_FIELD(  2, UENUM   , REQUIRED, STATIC  , OTHER, dfu_signed_command_t, signature_type, command, 0),
+    PB_FIELD(  3, BYTES   , REQUIRED, STATIC  , OTHER, dfu_signed_command_t, signature, signature_type, 0),
+    PB_LAST_FIELD
+};
+
+const pb_field_t dfu_packet_fields[3] = {
+    PB_FIELD(  1, MESSAGE , OPTIONAL, STATIC  , FIRST, dfu_packet_t, command, command, &dfu_command_fields),
+    PB_FIELD(  2, MESSAGE , OPTIONAL, STATIC  , OTHER, dfu_packet_t, signed_command, command, &dfu_signed_command_fields),
+    PB_LAST_FIELD
+};
+
+
+/* Check that field information fits in pb_field_t */
+#if !defined(PB_FIELD_32BIT)
+/* If you get an error here, it means that you need to define PB_FIELD_32BIT
+ * compile-time option. You can do that in pb.h or on compiler command line.
+ *
+ * The reason you need to do this is that some of your messages contain tag
+ * numbers or field sizes that are larger than what can fit in 8 or 16 bit
+ * field descriptors.
+ */
+PB_STATIC_ASSERT((pb_membersize(dfu_init_command_t, hash) < 65536 && pb_membersize(dfu_init_command_t, boot_validation[0]) < 65536 && pb_membersize(dfu_command_t, init) < 65536 && pb_membersize(dfu_signed_command_t, command) < 65536 && pb_membersize(dfu_packet_t, command) < 65536 && pb_membersize(dfu_packet_t, signed_command) < 65536), YOU_MUST_DEFINE_PB_FIELD_32BIT_FOR_MESSAGES_dfu_hash_dfu_boot_validation_dfu_init_command_dfu_command_dfu_signed_command_dfu_packet)
+#endif
+
+#if !defined(PB_FIELD_16BIT) && !defined(PB_FIELD_32BIT)
+/* If you get an error here, it means that you need to define PB_FIELD_16BIT
+ * compile-time option. You can do that in pb.h or on compiler command line.
+ *
+ * The reason you need to do this is that some of your messages contain tag
+ * numbers or field sizes that are larger than what can fit in the default
+ * 8 bit descriptors.
+ */
+PB_STATIC_ASSERT((pb_membersize(dfu_init_command_t, hash) < 256 && pb_membersize(dfu_init_command_t, boot_validation[0]) < 256 && pb_membersize(dfu_command_t, init) < 256 && pb_membersize(dfu_signed_command_t, command) < 256 && pb_membersize(dfu_packet_t, command) < 256 && pb_membersize(dfu_packet_t, signed_command) < 256), YOU_MUST_DEFINE_PB_FIELD_16BIT_FOR_MESSAGES_dfu_hash_dfu_boot_validation_dfu_init_command_dfu_command_dfu_signed_command_dfu_packet)
+#endif
+
+
+/* @@protoc_insertion_point(eof) */
diff --git a/subsys/nrf_dfu/common/dfu-cc.proto b/subsys/nrf_dfu/common/dfu-cc.proto
new file mode 100644
index 000000000..341b4e8f5
--- /dev/null
+++ b/subsys/nrf_dfu/common/dfu-cc.proto
@@ -0,0 +1,82 @@
+package dfu;
+
+// Version 0.1
+
+enum FwType {
+    APPLICATION             = 0;
+    SOFTDEVICE              = 1;
+    BOOTLOADER              = 2;
+    SOFTDEVICE_BOOTLOADER   = 3;
+    EXTERNAL_APPLICATION    = 4;
+}
+
+enum HashType {
+    NO_HASH = 0;
+    CRC     = 1;
+    SHA128  = 2;
+    SHA256  = 3;
+    SHA512  = 4;
+}
+
+enum OpCode {
+    INIT = 1;
+}
+
+enum ValidationType {
+    NO_VALIDATION                   = 0;
+    VALIDATE_GENERATED_CRC          = 1;
+    VALIDATE_SHA256                 = 2;
+    VALIDATE_ECDSA_P256_SHA256      = 3;
+}
+
+message Hash {
+    required HashType   hash_type   = 1;
+    required bytes      hash        = 2;
+}
+
+message BootValidation {
+
+    required ValidationType type    = 1;
+    required bytes          bytes   = 2;
+}
+
+// Commands data
+message InitCommand {
+    optional uint32             fw_version      = 1;
+    optional uint32             hw_version      = 2;
+    repeated uint32             sd_req          = 3 [packed = true];
+    optional FwType             type            = 4;
+
+    optional uint32             sd_size         = 5;
+    optional uint32             bl_size         = 6;
+    optional uint32             app_size        = 7;
+
+    optional Hash               hash            = 8;
+
+    optional bool               is_debug        = 9 [default = false];
+    repeated BootValidation     boot_validation = 10;
+}
+
+// Command type
+message Command {
+    optional OpCode         op_code = 1;
+    optional InitCommand    init    = 2;
+}
+
+// Signed command types
+enum SignatureType {
+    ECDSA_P256_SHA256   = 0;
+    ED25519             = 1;
+}
+
+message SignedCommand {
+    required Command        command         = 1;
+    required SignatureType  signature_type  = 2;
+    required bytes          signature       = 3;
+}
+
+// Parent packet type
+message Packet {
+    optional Command        command         = 1;
+    optional SignedCommand  signed_command  = 2;
+}
diff --git a/subsys/nrf_dfu/common/dfu_trans.ld b/subsys/nrf_dfu/common/dfu_trans.ld
new file mode 100644
index 000000000..cccb00a62
--- /dev/null
+++ b/subsys/nrf_dfu/common/dfu_trans.ld
@@ -0,0 +1,6 @@
+	SECTION_DATA_PROLOGUE(.dfu_trans,,)
+	{
+		__start_dfu_trans = .;
+		KEEP(*(SORT(.dfu_trans*)));
+		__stop_dfu_trans = .;
+	} GROUP_LINK_IN(ROMABLE_REGION)
diff --git a/subsys/nrf_dfu/common/nrf_dfu.c b/subsys/nrf_dfu/common/nrf_dfu.c
new file mode 100644
index 000000000..90f280dc9
--- /dev/null
+++ b/subsys/nrf_dfu/common/nrf_dfu.c
@@ -0,0 +1,97 @@
+/**
+ * Copyright (c) 2016 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include "nrf_dfu.h"
+#include "nrf_dfu_transport.h"
+#include "nrf_dfu_req_handler.h"
+#include <sys/printk.h>
+#include <dfu/mcuboot.h>
+
+static nrf_dfu_observer_t m_user_observer;                          //<! Observer callback set by the user.
+
+/**
+ * @brief This function calls the user's observer (@ref m_observer) after it is done handling the event.
+ */
+static void dfu_observer(nrf_dfu_evt_type_t event)
+{
+    switch (event)
+    {
+        case NRF_DFU_EVT_DFU_COMPLETED:
+        case NRF_DFU_EVT_DFU_ABORTED:
+#ifndef NRF_DFU_NO_TRANSPORT
+            UNUSED_RETURN_VALUE(nrf_dfu_transports_close(NULL));
+#endif
+            break;
+        default:
+            break;
+    }
+
+    /* Call user's observer if present. */
+    if (m_user_observer)
+    {
+        m_user_observer(event);
+    }
+}
+
+
+
+uint32_t nrf_dfu_init(nrf_dfu_observer_t observer)
+{
+    uint32_t ret_val;
+
+    m_user_observer = observer;
+
+    printk("initialize nrf_dfu \n\r");
+
+    boot_write_img_confirmed();
+
+    dfu_observer(NRF_DFU_EVT_DFU_INITIALIZED);
+
+    // Initializing transports
+    ret_val = nrf_dfu_transports_init(dfu_observer);
+    if (ret_val != NRF_SUCCESS)
+    {
+        printk("Could not initalize DFU transport: 0x%08x", ret_val);
+        return ret_val;
+    }
+
+    ret_val = nrf_dfu_req_handler_init(dfu_observer);
+
+    return ret_val;
+}
diff --git a/subsys/nrf_dfu/common/nrf_dfu_flash.c b/subsys/nrf_dfu/common/nrf_dfu_flash.c
new file mode 100644
index 000000000..6c76d2ec4
--- /dev/null
+++ b/subsys/nrf_dfu/common/nrf_dfu_flash.c
@@ -0,0 +1,346 @@
+/*
+ * Copyright (c) 2019 Nordic Semiconductor ASA
+ *
+ * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
+ */
+
+#include <zephyr.h>
+#include <inttypes.h>
+#include <zephyr/types.h>
+#include <sys/byteorder.h>
+#include <storage/flash_map.h>
+#include <logging/log.h>
+#include "nrf_dfu_flash.h"
+#include <drivers/flash.h>
+#include <storage/stream_flash.h>
+#include <dfu/flash_img.h>
+#include "nrf_dfu_settings.h"
+
+LOG_MODULE_REGISTER(dfu_flash, CONFIG_NRF_DFU_LOG_LEVEL);
+
+const void * const dfu_flash_module;
+
+#if 1// CONFIG_BOARD_HAS_NRF5_BOOTLOADER
+#define DFU_STREAM 1
+#endif
+
+
+#define FLASH_PAGE_SIZE_LOG2	12
+#define FLASH_PAGE_SIZE		BIT(FLASH_PAGE_SIZE_LOG2)
+#define FLASH_PAGE_ID(off)	((off) >> FLASH_PAGE_SIZE_LOG2)
+#define FLASH_CLEAN_VAL		UINT32_MAX
+#define FLASH_READ_CHUNK_SIZE	(FLASH_PAGE_SIZE / 8)
+
+/* Keep small to avoid blocking the workqueue for long periods of time. */
+#define STORE_CHUNK_SIZE		16 /* bytes */
+
+#define SYNC_BUFFER_SIZE (128 * sizeof(uint32_t)) /* bytes */
+
+#if CONFIG_SECURE_BOOT
+ #include <fw_info.h>
+ #define IMAGE0_ID		PM_S0_IMAGE_ID
+ #define IMAGE0_ADDRESS		PM_S0_IMAGE_ADDRESS
+ #define IMAGE1_ID		PM_S1_IMAGE_ID
+ #define IMAGE1_ADDRESS		PM_S1_IMAGE_ADDRESS
+#elif CONFIG_BOOTLOADER_MCUBOOT
+ #include <dfu/mcuboot.h>
+ #define IMAGE0_ID		PM_MCUBOOT_PRIMARY_ID
+ #define IMAGE0_ADDRESS		PM_MCUBOOT_PRIMARY_ADDRESS
+ #define IMAGE1_ID		PM_MCUBOOT_SECONDARY_ID
+ #define IMAGE1_ADDRESS		PM_MCUBOOT_SECONDARY_ADDRESS
+#else
+ //#error Bootloader not supported.
+#endif
+
+#ifndef DFU_STREAM
+static const struct flash_area *flash_area;
+#endif
+
+#define DFU_UNLOCKED	0
+
+static atomic_t dfu_locked = ATOMIC_INIT(DFU_UNLOCKED);
+
+
+bool dfu_lock(const void *module_id)
+{
+	return atomic_cas(&dfu_locked, DFU_UNLOCKED, (atomic_val_t)module_id);
+}
+
+void dfu_unlock(const void *module_id)
+{
+	bool success = atomic_cas(&dfu_locked, (atomic_val_t)module_id,
+				  DFU_UNLOCKED);
+
+	/* Module that have not locked dfu, should not try to unlock it. */
+	__ASSERT_NO_MSG(success);
+	ARG_UNUSED(success);
+}
+
+#ifndef DFU_STREAM
+static uint8_t dfu_slot_id(void)
+{
+#if CONFIG_BOOTLOADER_MCUBOOT
+	/* MCUBoot always puts new image in the secondary slot. */
+	return IMAGE1_ID;
+#else
+	BUILD_ASSERT(IMAGE0_ADDRESS < IMAGE1_ADDRESS);
+	if ((uint32_t)(uintptr_t)dfu_slot_id < IMAGE1_ADDRESS) {
+		return IMAGE1_ID;
+	}
+
+	return IMAGE0_ID;
+#endif
+}
+
+static bool is_page_clean(const struct flash_area *fa, int off, size_t len)
+{
+	static const size_t chunk_size = FLASH_READ_CHUNK_SIZE;
+	static const size_t chunk_cnt = FLASH_PAGE_SIZE / chunk_size;
+
+	BUILD_ASSERT(chunk_size * chunk_cnt == FLASH_PAGE_SIZE);
+	BUILD_ASSERT(chunk_size % sizeof(uint32_t) == 0);
+
+	uint32_t buf[chunk_size / sizeof(uint32_t)];
+
+	int err;
+
+	for (size_t i = 0; i < chunk_cnt; i++) {
+		err = flash_area_read(fa, off + i * chunk_size, buf, chunk_size);
+
+		if (err) {
+			LOG_ERR("Cannot read flash");
+			return false;
+		}
+
+		for (size_t j = 0; j < ARRAY_SIZE(buf); j++) {
+			if (buf[j] != FLASH_CLEAN_VAL) {
+				return false;
+			}
+		}
+	}
+
+	return true;
+}
+#endif
+
+
+#ifndef DFU_STREAM
+int dfu_flash_start(uint32_t image_start, uint32_t image_len)
+{
+	if (flash_area) {
+		LOG_WRN("DFU already in progress");
+		return 0;
+	}
+
+	if (!dfu_lock(dfu_flash_module)) {
+		LOG_WRN("DFU already started by another module");
+		return 0;
+	}
+	
+	__ASSERT_NO_MSG(flash_area == NULL);
+	int err = flash_area_open(dfu_slot_id(), &flash_area);
+
+	if (err) {
+		LOG_ERR("Cannot open flash area (%d)", err);
+		flash_area = NULL;
+		dfu_unlock(dfu_flash_module);
+
+		return err;
+	}
+
+	// LOG_DBG("flash area size=0x%x image size=0x%x id %d", flash_area->fa_size, image_len, flash_area->fa_id);
+	
+	// if (!is_page_clean(flash_area, 0, FLASH_PAGE_SIZE)) {
+	// 	uint32_t round_size = image_len/FLASH_PAGE_SIZE * 4096;
+	// 	if (image_len % FLASH_PAGE_SIZE) 
+	// 	{
+	// 		round_size += 4096;
+	// 	}
+	// 	err = flash_area_erase(flash_area, 0, round_size);
+	// 	if (err) {
+	// 		LOG_ERR("Cannot erase the whole image area %d", err);
+	// 		flash_area_close(flash_area);
+	// 		flash_area = NULL;			
+	// 	}
+	// 	else
+	// 	{
+	// 		LOG_INF("**the size=0x%x of Flash erased", image_len);
+	// 	}
+	// }
+
+	return err;	
+}
+#else
+#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)
+	static struct flash_img_context *ctx = NULL;
+#else
+	static struct flash_img_context ctx_data;
+#define ctx (&ctx_data)
+#endif
+int dfu_flash_start(uint32_t image_start, uint32_t image_len)
+{
+	int rc = 0;
+
+	if (!dfu_lock(dfu_flash_module)) {
+		LOG_WRN("DFU already started by another module");
+		return 0;
+	}		
+#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)
+	if (ctx == NULL) {
+		ctx = k_malloc(sizeof(*ctx));
+		if (ctx == NULL) {
+			return -EFAULT;
+		}
+	}
+#endif
+	rc = flash_img_init(ctx);
+	if (rc)
+	{
+#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)
+		k_free(ctx);
+		ctx = NULL;
+#endif		
+		LOG_ERR("flash_img_init err %d", rc);		
+	}
+
+#ifdef PM_MCUBOOT_SECONDARY_ADDRESS
+	ctx->stream.offset = PM_MCUBOOT_SECONDARY_ADDRESS + image_start;
+#else
+	ctx->stream.offset = image_start;
+#endif
+	return rc;
+
+}
+#endif
+
+#ifndef DFU_STREAM
+void dfu_flash_finish(void)
+{
+	__ASSERT_NO_MSG(flash_area != NULL);
+	
+#ifdef CONFIG_BOOTLOADER_MCUBOOT
+	int err = boot_request_upgrade(false);
+	if (err) {
+		LOG_ERR("Cannot request the image upgrade (err:%d)", err);
+	}
+#endif
+	LOG_INF("image trailer written");	
+	flash_area_close(flash_area);
+	dfu_unlock(dfu_flash_module);
+	flash_area = NULL;	
+}
+#else
+#ifdef CONFIG_BOARD_HAS_NRF5_BOOTLOADER
+extern nrf_dfu_settings_t s_dfu_settings;
+void dfu_flash_finish(void)
+{
+	int rc;
+	
+	ctx->stream.offset = BOOTLOADER_SETTINGS_ADDRESS;
+	ctx->stream.buf_bytes = 0;
+	ctx->stream.bytes_written = 0;
+	ctx->stream.available = FLASH_PAGE_SIZE;	
+	rc = flash_img_buffered_write(ctx, (void *)&s_dfu_settings, sizeof(nrf_dfu_settings_t), true);
+	if(rc)
+	{
+		LOG_ERR("update settings err %d", rc);
+	}
+	else
+	{
+		LOG_INF("settings page update done");
+	}
+
+	dfu_unlock(dfu_flash_module);
+
+#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)	
+	k_free(ctx);
+	ctx = NULL;	
+#endif
+
+}
+#else
+void dfu_flash_finish(void)
+{	
+#ifdef CONFIG_BOOTLOADER_MCUBOOT
+	int err = boot_request_upgrade(false);
+	if (err) {
+		LOG_ERR("Cannot request the image upgrade (err:%d)", err);
+	}
+#endif
+	dfu_unlock(dfu_flash_module);
+
+#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)	
+	k_free(ctx);
+	ctx = NULL;	
+#endif
+
+	LOG_INF("image trailer written");
+
+}
+#endif //CONFIG_BOARD_HAS_NRF5_BOOTLOADER
+#endif //DFU_STREAM
+
+#ifndef DFU_STREAM
+int dfu_data_store(int off, const void *src,
+		     size_t len, bool flush)
+{
+	int err;
+	LOG_DBG("flash store off=%x, src=%p, len=%d", off, src, len);
+	err = flash_area_write(flash_area, off, src, len);
+	if (err) {
+		LOG_ERR("Cannot write flash (%d)", err);
+		flash_area_close(flash_area);
+		flash_area = NULL;		
+	}
+	return err;
+}
+#else
+int dfu_data_store(int off, const void *src,
+		     size_t len, bool flush)
+{
+	int rc;
+		/* Cast away const. */
+	rc = flash_img_buffered_write(ctx, (void *)src, len, flush);
+
+	return rc;
+}
+#endif
+
+#ifndef DFU_STREAM
+int dfu_page_erase(int off, size_t len)
+{
+	int err = 0;
+
+    // __ASSERT_NO_MSG(flash_area != NULL);
+	if (flash_area == NULL)
+	{
+		err = flash_area_open(dfu_slot_id(), &flash_area);
+		if (err) {
+			LOG_ERR("Cannot open flash area (%d)", err);
+			return err;
+		}
+	}
+
+	__ASSERT_NO_MSG(off + FLASH_PAGE_SIZE <= flash_area->fa_size);    
+
+	if (!is_page_clean(flash_area, off, FLASH_PAGE_SIZE)) {
+		err = flash_area_erase(flash_area, off, FLASH_PAGE_SIZE);
+		if (err) {
+			LOG_ERR("Cannot erase page (%d)", err);
+			flash_area_close(flash_area);
+			flash_area = NULL;			
+		}
+		else
+		{
+			LOG_INF("===erase off=0x%x len=%d ==", off, len);
+		}
+	}
+        
+	return err;
+}
+#else
+int dfu_page_erase(int off, size_t len)
+{
+	return 0;
+}
+#endif
\ No newline at end of file
diff --git a/subsys/nrf_dfu/common/nrf_dfu_handling_error.c b/subsys/nrf_dfu/common/nrf_dfu_handling_error.c
new file mode 100644
index 000000000..845160d38
--- /dev/null
+++ b/subsys/nrf_dfu/common/nrf_dfu_handling_error.c
@@ -0,0 +1,59 @@
+/**
+ * Copyright (c) 2017 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include "nrf_dfu_handling_error.h"
+#include "nrf_dfu_req_handler.h"
+
+static nrf_dfu_ext_error_code_t m_last_error = NRF_DFU_EXT_ERROR_NO_ERROR;
+
+nrf_dfu_result_t ext_error_set(nrf_dfu_ext_error_code_t error_code)
+{
+    m_last_error = error_code;
+
+    return NRF_DFU_RES_CODE_EXT_ERROR;
+}
+
+nrf_dfu_ext_error_code_t ext_error_get()
+{
+    nrf_dfu_ext_error_code_t last_error = m_last_error;
+    m_last_error = NRF_DFU_EXT_ERROR_NO_ERROR;
+
+    return last_error;
+}
diff --git a/subsys/nrf_dfu/common/nrf_dfu_req_handler.c b/subsys/nrf_dfu/common/nrf_dfu_req_handler.c
new file mode 100644
index 000000000..b70ec689f
--- /dev/null
+++ b/subsys/nrf_dfu/common/nrf_dfu_req_handler.c
@@ -0,0 +1,721 @@
+/**
+ * Copyright (c) 2016 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <zephyr.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include "sdk_config.h"
+#include "nrf_dfu.h"
+#include "nrf_dfu_types.h"
+#include "nrf_dfu_req_handler.h"
+#include "nrf_dfu_handling_error.h"
+#include "app_util.h"
+#include "crc32.h"
+#include "nrf_dfu_validation.h"
+#include "nrf_dfu_settings.h"
+#include <logging/log.h>
+#include "nrf_dfu_flash.h"
+#include <logging/log_ctrl.h>
+
+#define LOG_MODULE_NAME dfu_req
+LOG_MODULE_REGISTER(LOG_MODULE_NAME, CONFIG_NRF_DFU_LOG_LEVEL);
+
+static uint32_t m_firmware_start_addr;          /**< Start address of the current firmware image. */
+static uint32_t m_firmware_size_req;            /**< The size of the entire firmware image. Defined by the init command. */
+
+static nrf_dfu_observer_t m_observer;
+
+typedef struct {
+	void *fifo_reserved;
+	nrf_dfu_request_t req;	
+}dfu_data_t;
+
+static K_FIFO_DEFINE(fifo_dfu_data);
+
+static nrf_dfu_result_t ext_err_code_handle(nrf_dfu_result_t ret_val)
+{
+    if (ret_val < NRF_DFU_RES_CODE_EXT_ERROR)
+    {
+        return ret_val;
+    }
+    else
+    {
+        nrf_dfu_ext_error_code_t ext_err =
+                (nrf_dfu_ext_error_code_t)((uint8_t)ret_val - (uint8_t)NRF_DFU_RES_CODE_EXT_ERROR);
+        return ext_error_set(ext_err);
+    }
+}
+
+
+static void on_prn_set_request(nrf_dfu_request_t * p_req, nrf_dfu_response_t * p_res)
+{
+    UNUSED_PARAMETER(p_req);
+    UNUSED_PARAMETER(p_res);
+    LOG_DBG("Handle NRF_DFU_OP_RECEIPT_NOTIF_SET");
+}
+
+
+static void on_abort_request(nrf_dfu_request_t * p_req, nrf_dfu_response_t * p_res)
+{
+    UNUSED_PARAMETER(p_req);
+    UNUSED_PARAMETER(p_res);
+    LOG_DBG("Handle NRF_DFU_OP_ABORT");
+
+    m_observer(NRF_DFU_EVT_DFU_ABORTED);
+}
+
+
+/* Set offset and CRC fields in the response for a 'command' message. */
+static void cmd_response_offset_and_crc_set(nrf_dfu_response_t * const p_res)
+{
+    __ASSERT_NO_MSG(p_res);
+
+    /* Copy the CRC and offset of the init packet. */
+    p_res->crc.offset = s_dfu_settings.progress.command_offset;
+    p_res->crc.crc    = s_dfu_settings.progress.command_crc;
+}
+
+
+static void on_cmd_obj_select_request(nrf_dfu_request_t const * p_req, nrf_dfu_response_t * p_res)
+{
+    UNUSED_PARAMETER(p_req);
+    LOG_DBG("Handle NRF_DFU_OP_OBJECT_SELECT (command)");
+
+    p_res->select.max_size = INIT_COMMAND_MAX_SIZE;
+    cmd_response_offset_and_crc_set(p_res);
+}
+
+
+static void on_cmd_obj_create_request(nrf_dfu_request_t * p_req, nrf_dfu_response_t * p_res)
+{
+    __ASSERT_NO_MSG(p_req);
+    __ASSERT_NO_MSG(p_res);
+
+    LOG_DBG("Handle NRF_DFU_OP_OBJECT_CREATE (command)");
+
+    m_observer(NRF_DFU_EVT_DFU_STARTED);
+
+    nrf_dfu_result_t ret_val = nrf_dfu_validation_init_cmd_create(p_req->create.object_size);
+    p_res->result = ext_err_code_handle(ret_val);
+}
+
+
+static void on_cmd_obj_write_request(nrf_dfu_request_t * p_req, nrf_dfu_response_t * p_res)
+{
+    __ASSERT_NO_MSG(p_req != NULL);
+    __ASSERT_NO_MSG(p_req->write.p_data != NULL);
+    __ASSERT_NO_MSG(p_req->write.len != 0);
+    __ASSERT_NO_MSG(p_res != NULL);
+
+    LOG_DBG("Handle NRF_DFU_OP_OBJECT_WRITE (command)");
+
+    nrf_dfu_result_t ret_val;
+
+    ret_val = nrf_dfu_validation_init_cmd_append(p_req->write.p_data, p_req->write.len);
+    p_res->result = ext_err_code_handle(ret_val);
+
+    /* Update response. This is only used when the PRN is triggered and the 'write' message
+     * is answered with a CRC message and these field are copied into the response. */
+    cmd_response_offset_and_crc_set(p_res);
+
+    /* If a callback to free the request payload buffer was provided, invoke it now. */
+    if (p_req->callback.write)
+    {
+        p_req->callback.write((void*)p_req->write.p_data);
+    }
+}
+
+
+static void on_cmd_obj_execute_request(nrf_dfu_request_t const * p_req, nrf_dfu_response_t * p_res)
+{
+    __ASSERT_NO_MSG(p_req);
+    __ASSERT_NO_MSG(p_res);
+
+    LOG_DBG("Handle NRF_DFU_OP_OBJECT_EXECUTE (command)");
+
+    nrf_dfu_result_t ret_val;
+    ret_val = nrf_dfu_validation_init_cmd_execute(&m_firmware_start_addr, &m_firmware_size_req);
+    p_res->result = ext_err_code_handle(ret_val);
+    LOG_INF("new fw start=%x, fw size=%x ", m_firmware_start_addr, m_firmware_size_req);
+
+    if (p_res->result == NRF_DFU_RES_CODE_SUCCESS)
+    {
+        if (nrf_dfu_settings_write_and_backup(NULL) == NRF_SUCCESS)
+        {
+            /* Setting DFU to initialized */
+            LOG_DBG("Writing valid init command to flash.");
+        }
+        else
+        {
+            p_res->result = NRF_DFU_RES_CODE_OPERATION_FAILED;
+        }
+    }
+    int err = dfu_flash_start(m_firmware_start_addr, m_firmware_size_req);
+    if (err)
+    {
+        p_res->result = NRF_DFU_RES_CODE_OPERATION_FAILED;
+    }
+}
+
+
+static void on_cmd_obj_crc_request(nrf_dfu_request_t const * p_req, nrf_dfu_response_t * p_res)
+{
+    UNUSED_PARAMETER(p_req);
+    LOG_DBG("Handle NRF_DFU_OP_CRC_GET (command)");
+
+    cmd_response_offset_and_crc_set(p_res);
+}
+
+
+/** @brief Function handling command requests from the transport layer.
+ *
+ * @param   p_req[in]       Pointer to the structure holding the DFU request.
+ * @param   p_res[out]      Pointer to the structure holding the DFU response.
+ *
+ * @retval NRF_SUCCESS      If the command request was executed successfully.
+ *                          Any other error code indicates that the data request
+ *                          could not be handled.
+ */
+static void nrf_dfu_command_req(nrf_dfu_request_t * p_req, nrf_dfu_response_t * p_res)
+{
+    __ASSERT_NO_MSG(p_req);
+    __ASSERT_NO_MSG(p_res);
+
+    switch (p_req->request)
+    {
+        case NRF_DFU_OP_OBJECT_CREATE:
+        {
+            on_cmd_obj_create_request(p_req, p_res);
+        } break;
+
+        case NRF_DFU_OP_CRC_GET:
+        {
+            on_cmd_obj_crc_request(p_req, p_res);
+        } break;
+
+        case NRF_DFU_OP_OBJECT_WRITE:
+        {
+            on_cmd_obj_write_request(p_req, p_res);
+        } break;
+
+        case NRF_DFU_OP_OBJECT_EXECUTE:
+        {
+            on_cmd_obj_execute_request(p_req, p_res);
+        } break;
+
+        case NRF_DFU_OP_OBJECT_SELECT:
+        {
+            on_cmd_obj_select_request(p_req, p_res);
+        } break;
+
+        default:
+        {
+            __ASSERT_NO_MSG(false);
+        } break;
+    }
+}
+
+
+static void on_data_obj_select_request(nrf_dfu_request_t * p_req, nrf_dfu_response_t * p_res)
+{
+    LOG_DBG("Handle NRF_DFU_OP_OBJECT_SELECT (data)");
+
+    p_res->select.crc    = s_dfu_settings.progress.firmware_image_crc;
+    p_res->select.offset = s_dfu_settings.progress.firmware_image_offset;
+
+    p_res->select.max_size = DATA_OBJECT_MAX_SIZE;
+
+    LOG_DBG("crc = 0x%x, offset = 0x%x, max_size = 0x%x",
+                  p_res->select.crc,
+                  p_res->select.offset,
+                  p_res->select.max_size);
+}
+
+
+static void on_data_obj_create_request(nrf_dfu_request_t * p_req, nrf_dfu_response_t * p_res)
+{
+    LOG_DBG("Handle NRF_DFU_OP_OBJECT_CREATE (data)");
+
+    if (!nrf_dfu_validation_init_cmd_present())
+    {
+        /* Can't accept data because DFU isn't initialized by init command. */
+        LOG_ERR("Cannot create data object without valid init command");
+        p_res->result = NRF_DFU_RES_CODE_OPERATION_NOT_PERMITTED;
+        return;
+    }
+
+    if (p_req->create.object_size == 0)
+    {
+        LOG_ERR("Object size cannot be 0.");
+        p_res->result = NRF_DFU_RES_CODE_INVALID_PARAMETER;
+        return;
+    }
+
+    if (  ((p_req->create.object_size & (CODE_PAGE_SIZE - 1)) != 0)
+        && (s_dfu_settings.progress.firmware_image_offset_last + p_req->create.object_size != m_firmware_size_req))
+    {
+        LOG_ERR("Object size must be page aligned");
+        p_res->result = NRF_DFU_RES_CODE_INVALID_PARAMETER;
+        return;
+    }
+
+    if (p_req->create.object_size > DATA_OBJECT_MAX_SIZE)
+    {
+        /* It is impossible to handle the command because the size is too large */
+        LOG_ERR("Invalid size for object (too large)");
+        p_res->result = NRF_DFU_RES_CODE_INSUFFICIENT_RESOURCES;
+        return;
+    }
+
+    if ((s_dfu_settings.progress.firmware_image_offset_last + p_req->create.object_size) >
+        m_firmware_size_req)
+    {
+        LOG_ERR("Creating the object with size 0x%08x would overflow firmware size. "
+                      "Offset is 0x%08x and firmware size is 0x%08x.",
+                      p_req->create.object_size,
+                      s_dfu_settings.progress.firmware_image_offset_last,
+                      m_firmware_size_req);
+
+        p_res->result = NRF_DFU_RES_CODE_OPERATION_NOT_PERMITTED;
+        return;
+    }
+
+    s_dfu_settings.progress.data_object_size      = p_req->create.object_size;
+    s_dfu_settings.progress.firmware_image_crc    = s_dfu_settings.progress.firmware_image_crc_last;
+    s_dfu_settings.progress.firmware_image_offset = s_dfu_settings.progress.firmware_image_offset_last;
+    s_dfu_settings.write_offset                   = s_dfu_settings.progress.firmware_image_offset_last;
+
+    /* Erase the page we're at. */
+    if (dfu_page_erase(m_firmware_start_addr + s_dfu_settings.progress.firmware_image_offset, p_req->create.object_size))                      
+    {
+        LOG_ERR("Erase operation failed");
+        p_res->result = NRF_DFU_RES_CODE_INVALID_OBJECT;
+        return;
+    }
+
+    LOG_DBG("Creating object with size: %d. Offset: 0x%08x, CRC: 0x%08x",
+                 s_dfu_settings.progress.data_object_size,
+                 s_dfu_settings.progress.firmware_image_offset,
+                 s_dfu_settings.progress.firmware_image_crc);
+}
+
+
+static void on_data_obj_write_request(nrf_dfu_request_t * p_req, nrf_dfu_response_t * p_res)
+{
+    LOG_DBG("Handle NRF_DFU_OP_OBJECT_WRITE (data)");
+
+    if (!nrf_dfu_validation_init_cmd_present())
+    {
+        /* Can't accept data because DFU isn't initialized by init command. */
+        p_res->result = NRF_DFU_RES_CODE_OPERATION_NOT_PERMITTED;
+        return;
+    }
+
+    uint32_t const data_object_offset = s_dfu_settings.progress.firmware_image_offset -
+                                        s_dfu_settings.progress.firmware_image_offset_last;
+
+    if ((p_req->write.len + data_object_offset) > s_dfu_settings.progress.data_object_size)
+    {
+        /* Can't accept data because too much data has been received. */
+        LOG_ERR("Write request too long");
+        p_res->result = NRF_DFU_RES_CODE_INVALID_PARAMETER;
+        return;
+    }
+
+    uint32_t const write_addr = m_firmware_start_addr + s_dfu_settings.write_offset;
+    /* CRC must be calculated before handing off the data to fstorage because the data is
+     * freed on write completion.
+     */
+    uint32_t const next_crc =
+        crc32_compute(p_req->write.p_data, p_req->write.len, &s_dfu_settings.progress.firmware_image_crc);
+
+    // __ASSERT_NO_MSG(p_req->callback.write);
+    int ret;
+    if ((s_dfu_settings.progress.firmware_image_offset + p_req->write.len) == m_firmware_size_req)
+    {
+        LOG_DBG("last image packet");
+        ret = dfu_data_store(write_addr, p_req->write.p_data, p_req->write.len, true);        
+    }
+    else
+    {
+        ret = dfu_data_store(write_addr, p_req->write.p_data, p_req->write.len, false);
+    }
+    // int ret = dfu_data_store(write_addr, p_req->write.p_data, p_req->write.len);
+				   
+    // uint32_t ret =
+    //     nrf_dfu_flash_store(write_addr, p_req->write.p_data, p_req->write.len, p_req->callback.write);
+    // p_req->callback.write((void*)p_req->write.p_data);
+    // if (ret != NRF_SUCCESS)
+    if (ret)
+    {
+        /* When nrf_dfu_flash_store() fails because there is no space in the queue,
+         * stop processing the request so that the peer can detect a CRC error
+         * and retransmit this object. Remember to manually free the buffer !
+         */
+        // p_req->callback.write((void*)p_req->write.p_data);
+        LOG_ERR("DFU write error %d", ret);
+        return;
+    }
+
+    /* Update the CRC of the firmware image. */
+    s_dfu_settings.write_offset                   += p_req->write.len;
+    s_dfu_settings.progress.firmware_image_offset += p_req->write.len;
+    s_dfu_settings.progress.firmware_image_crc     = next_crc;
+
+    /* This is only used when the PRN is triggered and the 'write' message
+     * is answered with a CRC message and these field are copied into the response.
+     */
+    p_res->write.crc    = s_dfu_settings.progress.firmware_image_crc;
+    p_res->write.offset = s_dfu_settings.progress.firmware_image_offset;
+}
+
+
+static void on_data_obj_crc_request(nrf_dfu_request_t * p_req, nrf_dfu_response_t * p_res)
+{
+    LOG_DBG("Handle NRF_DFU_OP_CRC_GET (data)");
+    LOG_DBG("Offset:0x%x, CRC:0x%08x",
+                 s_dfu_settings.progress.firmware_image_offset,
+                 s_dfu_settings.progress.firmware_image_crc);
+
+    p_res->crc.crc    = s_dfu_settings.progress.firmware_image_crc;
+    p_res->crc.offset = s_dfu_settings.progress.firmware_image_offset;
+}
+
+
+static void on_data_obj_execute_request_sched(void * p_evt, uint16_t event_length)
+{
+    UNUSED_PARAMETER(event_length);
+
+    uint32_t          ret;
+    nrf_dfu_request_t * p_req = (nrf_dfu_request_t *)(p_evt);
+
+    nrf_dfu_response_t res =
+    {
+        .request = NRF_DFU_OP_OBJECT_EXECUTE,
+    };
+
+    if (s_dfu_settings.progress.firmware_image_offset == m_firmware_size_req)
+    {
+        LOG_INF("Whole firmware image received.");
+
+        res.result = NRF_DFU_RES_CODE_SUCCESS;
+
+        res.result = ext_err_code_handle(res.result);
+
+        /* Provide response to transport */
+        p_req->callback.response(&res, p_req->p_context);        
+
+#ifdef CONFIG_BOARD_HAS_NRF5_BOOTLOADER
+        update_settings_dfu_mode(m_firmware_start_addr, m_firmware_size_req);
+#endif
+        dfu_flash_finish();
+
+        m_observer(NRF_DFU_EVT_DFU_COMPLETED);       
+        
+    }
+    else
+    {
+        res.result = NRF_DFU_RES_CODE_SUCCESS;
+
+        /* Provide response to transport */
+        p_req->callback.response(&res, p_req->p_context);
+
+        if (NRF_DFU_SAVE_PROGRESS_IN_FLASH)
+        {
+            /* Allowing skipping settings backup to save time and flash wear. */
+            ret = nrf_dfu_settings_write_and_backup(NULL);
+            UNUSED_RETURN_VALUE(ret);
+        }
+    }
+
+    LOG_INF("Request handling complete. Result: 0x%x fw offset=0x%x", res.result, s_dfu_settings.progress.firmware_image_offset);
+}
+
+
+static bool on_data_obj_execute_request(nrf_dfu_request_t * p_req, nrf_dfu_response_t * p_res)
+{
+    LOG_DBG("Handle NRF_DFU_OP_OBJECT_EXECUTE (data)");
+
+    uint32_t const data_object_size = s_dfu_settings.progress.firmware_image_offset -
+                                      s_dfu_settings.progress.firmware_image_offset_last;
+
+    if (s_dfu_settings.progress.data_object_size != data_object_size)
+    {
+        /* The size of the written object was not as expected. */
+        LOG_ERR("Invalid data. expected: %d, got: %d",
+                      s_dfu_settings.progress.data_object_size,
+                      data_object_size);
+
+        p_res->result = NRF_DFU_RES_CODE_OPERATION_NOT_PERMITTED;
+        return true;
+    }
+
+    /* Update the offset and crc values for the last object written. */
+    s_dfu_settings.progress.data_object_size           = 0;
+    s_dfu_settings.progress.firmware_image_crc_last    = s_dfu_settings.progress.firmware_image_crc;
+    s_dfu_settings.progress.firmware_image_offset_last = s_dfu_settings.progress.firmware_image_offset;
+
+    on_data_obj_execute_request_sched(p_req, 0);
+
+    m_observer(NRF_DFU_EVT_OBJECT_RECEIVED);
+
+    return false;
+}
+
+
+static bool nrf_dfu_data_req(nrf_dfu_request_t * p_req, nrf_dfu_response_t * p_res)
+{
+    __ASSERT_NO_MSG(p_req);
+    __ASSERT_NO_MSG(p_res);
+
+    bool response_ready = true;
+
+    switch (p_req->request)
+    {
+        case NRF_DFU_OP_OBJECT_CREATE:
+        {
+            on_data_obj_create_request(p_req, p_res);
+        } break;
+
+        case NRF_DFU_OP_OBJECT_WRITE:
+        {
+            on_data_obj_write_request(p_req, p_res);
+        } break;
+
+        case NRF_DFU_OP_CRC_GET:
+        {
+            on_data_obj_crc_request(p_req, p_res);
+        } break;
+
+        case NRF_DFU_OP_OBJECT_EXECUTE:
+        {
+            response_ready = on_data_obj_execute_request(p_req, p_res);
+        } break;
+
+        case NRF_DFU_OP_OBJECT_SELECT:
+        {
+            on_data_obj_select_request(p_req, p_res);
+        } break;
+
+        default:
+        {
+            __ASSERT_NO_MSG(false);
+        } break;
+    }
+
+    return response_ready;
+}
+
+
+/**@brief Function for handling requests to manipulate data or command objects.
+ *
+ * @param[in]  p_req    Request.
+ * @param[out] p_res    Response.
+ *
+ * @return  Whether response is ready to be sent.
+ */
+static bool nrf_dfu_obj_op(nrf_dfu_request_t * p_req, nrf_dfu_response_t * p_res)
+{
+    /* Keep track of the current object type since write and execute requests don't contain it. */
+    static nrf_dfu_obj_type_t current_object = NRF_DFU_OBJ_TYPE_COMMAND;
+
+    if (    (p_req->request == NRF_DFU_OP_OBJECT_SELECT)
+        ||  (p_req->request == NRF_DFU_OP_OBJECT_CREATE))
+    {
+        __ASSERT(offsetof(nrf_dfu_request_select_t, object_type) ==
+                      offsetof(nrf_dfu_request_create_t, object_type),
+                      "Wrong object_type offset!");
+
+        current_object = (nrf_dfu_obj_type_t)(p_req->select.object_type);
+    }
+
+    bool response_ready = true;
+
+    switch (current_object)
+    {
+        case NRF_DFU_OBJ_TYPE_COMMAND:
+            nrf_dfu_command_req(p_req, p_res);
+            break;
+
+        case NRF_DFU_OBJ_TYPE_DATA:
+            response_ready = nrf_dfu_data_req(p_req, p_res);
+            break;
+
+        default:
+            /* The select request had an invalid object type. */
+            LOG_ERR("Invalid object type in request.");
+            current_object = NRF_DFU_OBJ_TYPE_INVALID;
+            p_res->result  = NRF_DFU_RES_CODE_INVALID_OBJECT;
+            break;
+    }
+
+    return response_ready;
+}
+
+
+static void nrf_dfu_req_handler_req_process(nrf_dfu_request_t * p_req)
+{
+    __ASSERT_NO_MSG(p_req->callback.response);
+
+    bool response_ready = true;
+
+    /* The request handlers assume these values to be set. */
+    nrf_dfu_response_t response =
+    {
+        .request = p_req->request,
+        .result  = NRF_DFU_RES_CODE_SUCCESS,
+    };
+
+
+    switch (p_req->request)
+    {
+        case NRF_DFU_OP_RECEIPT_NOTIF_SET:
+        {
+            on_prn_set_request(p_req, &response);
+        } break;
+
+        case NRF_DFU_OP_ABORT:
+        {
+            on_abort_request(p_req, &response);
+        } break;
+
+        case NRF_DFU_OP_OBJECT_CREATE:
+            /* Restart the inactivity timer on CREATE messages. */
+            /* Fallthrough. */
+        case NRF_DFU_OP_OBJECT_SELECT:
+        case NRF_DFU_OP_OBJECT_WRITE:
+        case NRF_DFU_OP_OBJECT_EXECUTE:
+        case NRF_DFU_OP_CRC_GET:
+        {
+            response_ready = nrf_dfu_obj_op(p_req, &response);
+        } break;
+
+        default:
+            LOG_INF("Invalid opcode received: 0x%x.", p_req->request);
+            response.result = NRF_DFU_RES_CODE_OP_CODE_NOT_SUPPORTED;
+            break;
+    }
+
+    if (response_ready)
+    {
+        LOG_DBG("Request handling complete. Result: 0x%x", response.result);
+
+        p_req->callback.response(&response, p_req->p_context);
+
+        if (response.result != NRF_DFU_RES_CODE_SUCCESS)
+        {
+            m_observer(NRF_DFU_EVT_DFU_FAILED);
+        }
+    }
+}
+
+void req_handler_thread(void)
+{	
+	LOG_INF("DFU thread created");
+
+	while (1) {
+        dfu_data_t * dfu_req = k_fifo_get(&fifo_dfu_data,
+						     K_FOREVER);
+        nrf_dfu_req_handler_req_process(&dfu_req->req);
+        if(dfu_req->req.request == NRF_DFU_OP_OBJECT_WRITE) 
+        {
+            k_free(dfu_req->req.write.p_data);	
+        }  	        
+        k_free(dfu_req);	
+	}
+}
+
+uint32_t nrf_dfu_req_handler_on_req(nrf_dfu_request_t * p_req)
+{
+    uint32_t ret = NRF_SUCCESS;
+
+    if (p_req->callback.response == NULL)
+    {
+        return NRF_ERROR_INVALID_PARAM;
+    }
+
+    dfu_data_t *dfu_req = k_malloc(sizeof(dfu_data_t));
+    memcpy(&dfu_req->req, p_req, sizeof(nrf_dfu_request_t));
+    if(p_req->request == NRF_DFU_OP_OBJECT_WRITE) 
+    {
+        uint8_t * data = k_malloc(p_req->write.len);
+        memcpy(data, p_req->write.p_data, p_req->write.len);
+        dfu_req->req.write.p_data = data;
+    }  		
+    k_fifo_put(&fifo_dfu_data, dfu_req);
+
+    // nrf_dfu_req_handler_req_process(p_req);
+    
+    return ret;
+}
+
+uint32_t nrf_dfu_req_handler_init(nrf_dfu_observer_t observer)
+{
+    // uint32_t       ret_val;
+    nrf_dfu_result_t result;
+
+    if (observer == NULL)
+    {
+        return NRF_ERROR_INVALID_PARAM;
+    }
+
+    nrf_dfu_validation_init();
+    if (nrf_dfu_validation_init_cmd_present())
+    {
+        /* Execute a previously received init packed. Subsequent executes will have no effect. */
+        result = nrf_dfu_validation_init_cmd_execute(&m_firmware_start_addr, &m_firmware_size_req);
+        if (result != NRF_DFU_RES_CODE_SUCCESS)
+        {
+            /* Init packet in flash is not valid! */
+            return NRF_ERROR_INTERNAL;
+        }
+    }
+
+
+    m_observer = observer;
+
+    /* Initialize extended error handling with "No error" as the most recent error. */
+    result = ext_error_set(NRF_DFU_EXT_ERROR_NO_ERROR);
+    UNUSED_RETURN_VALUE(result);
+
+    return NRF_SUCCESS;
+}
+
+K_THREAD_DEFINE(req_handler_thread_id, CONFIG_NRF_DFU_THREAD_STACK_SIZE, req_handler_thread, NULL, NULL,
+		NULL, CONFIG_NRF_DFU_THREAD_PRIO, 0, 0);
diff --git a/subsys/nrf_dfu/common/nrf_dfu_settings.c b/subsys/nrf_dfu/common/nrf_dfu_settings.c
new file mode 100644
index 000000000..876989bf0
--- /dev/null
+++ b/subsys/nrf_dfu/common/nrf_dfu_settings.c
@@ -0,0 +1,175 @@
+/**
+ * Copyright (c) 2016 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <stdint.h>
+#include "nrf_dfu_settings.h"
+#include <stddef.h>
+#include <string.h>
+#include "crc32.h"
+#include "sdk_config.h"
+#include "nrf_dfu_types.h"
+#include <logging/log.h>
+#include <nrfx_nvmc.h>
+
+#define LOG_MODULE_NAME dfu_settings
+LOG_MODULE_REGISTER(LOG_MODULE_NAME, CONFIG_NRF_DFU_LOG_LEVEL);
+
+#define DFU_SETTINGS_VERSION_OFFSET             (offsetof(nrf_dfu_settings_t, settings_version))                         //<! Offset in the settings struct where the settings version is located.
+#define DFU_SETTINGS_INIT_COMMAND_OFFSET        (offsetof(nrf_dfu_settings_t, init_command))                             //<! Offset in the settings struct where the InitCommand is located.
+#define DFU_SETTINGS_BOOT_VALIDATION_OFFSET     (offsetof(nrf_dfu_settings_t, boot_validation_crc))                      //<! Offset in the settings struct where the boot validation info is located.
+#define DFU_SETTINGS_BOOT_VALIDATION_SIZE       ((3 * sizeof(boot_validation_t)) + 4)
+#define DFU_SETTINGS_BOND_DATA_OFFSET_V1        (offsetof(nrf_dfu_settings_t, init_command) + INIT_COMMAND_MAX_SIZE_v1)  //<! Offset in the settings struct where the bond data was located in settings version 1.
+#define DFU_SETTINGS_ADV_NAME_OFFSET_V1         (offsetof(nrf_dfu_settings_t, init_command) + INIT_COMMAND_MAX_SIZE_v1 + NRF_DFU_PEER_DATA_LEN)  //<! Offset in the settings struct where the bond data was located in settings version 1.
+
+
+#define NRF_DFU_IN_APP 1
+
+
+nrf_dfu_settings_t s_dfu_settings;
+nrf_dfu_settings_t m_dfu_settings_buffer;
+
+static uint32_t settings_crc_get(nrf_dfu_settings_t const * p_settings)
+{
+    BUILD_ASSERT(offsetof(nrf_dfu_settings_t, crc) == 0);
+
+    // The crc is calculated from the s_dfu_settings struct, except the crc itself, the init command, bond data, and boot validation.
+    return crc32_compute((uint8_t*)(p_settings) + 4, DFU_SETTINGS_INIT_COMMAND_OFFSET - 4, NULL);
+}
+
+static uint32_t boot_validation_crc(nrf_dfu_settings_t const * p_settings)
+{
+    return crc32_compute((const uint8_t *)&p_settings->boot_validation_softdevice,
+                          DFU_SETTINGS_BOOT_VALIDATION_SIZE - 4,
+                          NULL);
+}
+
+
+void nrf_dfu_settings_reinit(void)
+{
+    
+    LOG_DBG("Resetting bootloader settings");
+    memset(&s_dfu_settings, 0x00, sizeof(nrf_dfu_settings_t));
+    s_dfu_settings.settings_version = NRF_DFU_SETTINGS_VERSION;
+
+#ifdef CONFIG_BOARD_HAS_NRF5_BOOTLOADER
+    memcpy(&s_dfu_settings, (void *)BOOTLOADER_SETTINGS_ADDRESS, sizeof(nrf_dfu_settings_t));
+    nrf_dfu_settings_progress_reset();
+#endif
+    return;
+}
+
+uint32_t nrf_dfu_settings_init(bool sd_irq_initialized)
+{
+    uint32_t err_code;
+
+    LOG_DBG("Calling nrf_dfu_settings_init()...");
+
+    nrf_dfu_settings_reinit();
+
+    err_code = nrf_dfu_settings_write_and_backup(NULL);
+
+    if (err_code != NRF_SUCCESS)
+    {
+        LOG_ERR("nrf_dfu_settings_write_and_backup() failed with error: %x", err_code);
+        return NRF_ERROR_INTERNAL;
+    }
+
+    return NRF_SUCCESS;
+}
+
+
+static uint32_t settings_write(void                   * p_dst,
+                                 void const             * p_src,
+                                 nrf_dfu_flash_callback_t callback,
+                                 nrf_dfu_settings_t     * p_dfu_settings_buffer)
+{
+
+    if (callback != NULL)
+    {
+        callback(NULL);
+    }
+
+    return NRF_SUCCESS;
+}
+
+#ifdef CONFIG_BOARD_HAS_NRF5_BOOTLOADER
+uint32_t nrf_dfu_bank1_start_addr(void)
+{
+    uint32_t bank0_addr = MBR_SIZE;
+    return ALIGN_TO_PAGE(bank0_addr + s_dfu_settings.bank_0.image_size);
+}
+
+void update_settings_dfu_mode(uint32_t data_addr, uint32_t data_len)
+{
+    s_dfu_settings.bank_current = NRF_DFU_CURRENT_BANK_1;
+    s_dfu_settings.bank_1.image_crc  = crc32_compute((uint8_t *)data_addr, data_len, NULL);
+    s_dfu_settings.bank_1.image_size = data_len;
+    s_dfu_settings.bank_1.bank_code = NRF_DFU_BANK_VALID_APP;
+    s_dfu_settings.progress.update_start_address = data_addr;
+
+    s_dfu_settings.crc = settings_crc_get(&s_dfu_settings);
+    s_dfu_settings.boot_validation_crc = boot_validation_crc(&s_dfu_settings);  
+}
+#endif
+
+uint32_t nrf_dfu_settings_write(nrf_dfu_flash_callback_t callback)
+{
+    static nrf_dfu_settings_t dfu_settings_buffer;
+    s_dfu_settings.crc = settings_crc_get(&s_dfu_settings);
+    s_dfu_settings.boot_validation_crc = boot_validation_crc(&s_dfu_settings);
+    return settings_write(&s_dfu_settings,
+                          &s_dfu_settings,
+                          callback,
+                          &dfu_settings_buffer);
+}
+
+
+uint32_t nrf_dfu_settings_write_and_backup(nrf_dfu_flash_callback_t callback)
+{
+    uint32_t err_code = nrf_dfu_settings_write(callback);
+    return err_code;
+}
+
+void nrf_dfu_settings_progress_reset(void)
+{
+    memset(s_dfu_settings.init_command, 0xFF, INIT_COMMAND_MAX_SIZE); // Remove the last init command
+    memset(&s_dfu_settings.progress, 0, sizeof(dfu_progress_t));
+    s_dfu_settings.write_offset = 0;
+}
diff --git a/subsys/nrf_dfu/common/nrf_dfu_transport.c b/subsys/nrf_dfu/common/nrf_dfu_transport.c
new file mode 100644
index 000000000..d434cfe73
--- /dev/null
+++ b/subsys/nrf_dfu/common/nrf_dfu_transport.c
@@ -0,0 +1,93 @@
+/**
+ * Copyright (c) 2016 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include "nrf_dfu_transport.h"
+#include <logging/log.h>
+
+#define LOG_MODULE_NAME dfu_trans
+LOG_MODULE_REGISTER(LOG_MODULE_NAME, CONFIG_NRF_DFU_LOG_LEVEL);
+
+#define DFU_TRANS_SECTION_ITEM_GET(i)       NRF_SECTION_ITEM_GET(dfu_trans, nrf_dfu_transport_t, (i))
+#define DFU_TRANS_SECTION_ITEM_COUNT        NRF_SECTION_ITEM_COUNT(dfu_trans, nrf_dfu_transport_t)
+
+NRF_SECTION_DEF(dfu_trans, const nrf_dfu_transport_t);
+
+
+uint32_t nrf_dfu_transports_init(nrf_dfu_observer_t observer)
+{
+    uint32_t const num_transports = DFU_TRANS_SECTION_ITEM_COUNT;
+    uint32_t ret_val = NRF_SUCCESS;
+
+    LOG_DBG("Initializing transports (found: %d)", num_transports);
+
+    for (uint32_t i = 0; i < num_transports; i++)
+    {
+        nrf_dfu_transport_t * const trans = DFU_TRANS_SECTION_ITEM_GET(i);
+        ret_val = trans->init_func(observer);
+        if (ret_val != NRF_SUCCESS)
+        {
+            LOG_DBG("Failed to initialize transport %d, error %d", i, ret_val);
+            break;
+        }
+    }
+
+    return ret_val;
+}
+
+
+uint32_t nrf_dfu_transports_close(nrf_dfu_transport_t const * p_exception)
+{
+    uint32_t const num_transports = DFU_TRANS_SECTION_ITEM_COUNT;
+    uint32_t ret_val = NRF_SUCCESS;
+
+    LOG_DBG("Shutting down transports (found: %d)", num_transports);
+
+    for (uint32_t i = 0; i < num_transports; i++)
+    {
+        nrf_dfu_transport_t * const trans = DFU_TRANS_SECTION_ITEM_GET(i);
+        ret_val = trans->close_func(p_exception);
+        if (ret_val != NRF_SUCCESS)
+        {
+            LOG_DBG("Failed to shutdown transport %d, error %d", i, ret_val);
+            break;
+        }
+    }
+
+    return ret_val;
+}
diff --git a/subsys/nrf_dfu/common/nrf_dfu_validation.c b/subsys/nrf_dfu/common/nrf_dfu_validation.c
new file mode 100644
index 000000000..f2b5bd03a
--- /dev/null
+++ b/subsys/nrf_dfu/common/nrf_dfu_validation.c
@@ -0,0 +1,342 @@
+/**
+ * Copyright (c) 2017 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdbool.h>
+#include "nrf_dfu_types.h"
+#include "nrf_dfu_settings.h"
+#include "pb.h"
+#include "pb_common.h"
+#include "pb_decode.h"
+#include "dfu-cc.pb.h"
+#include "crc32.h"
+#include "nrf_dfu_validation.h"
+#include <logging/log.h>
+
+#define LOG_MODULE_NAME dfu_validate
+LOG_MODULE_REGISTER(LOG_MODULE_NAME, CONFIG_NRF_DFU_LOG_LEVEL);
+
+
+#define EXT_ERR(err) (nrf_dfu_result_t)((uint32_t)NRF_DFU_RES_CODE_EXT_ERROR + (uint32_t)err)
+
+/* Whether a complete init command has been received and prevalidated, but the firmware
+ * is not yet fully transferred. This value will also be correct after reset.
+ */
+static bool               m_valid_init_cmd_present = false;
+static dfu_packet_t       m_packet                 = DFU_PACKET_INIT_DEFAULT;
+static uint8_t*           m_init_packet_data_ptr   = 0;
+static uint32_t           m_init_packet_data_len   = 0;
+static pb_istream_t       m_pb_stream;
+
+static dfu_init_command_t const * mp_init = NULL;
+
+/** @brief Flag used by parser code to indicate that the init command has been found to be invalid.
+ */
+static bool                                         m_init_packet_valid = false;
+
+ static void pb_decoding_callback(pb_istream_t *str,
+                                  uint32_t tag,
+                                  pb_wire_type_t wire_type,
+                                  void *iter)
+ {
+     pb_field_iter_t* p_iter = (pb_field_iter_t *) iter;
+
+     // Match the beginning of the init command.
+     if (p_iter->pos->ptr == &dfu_init_command_fields[0])
+     {
+         uint8_t  * ptr  = (uint8_t *)str->state;
+         uint32_t   size = str->bytes_left;
+
+         if (m_init_packet_data_ptr != NULL || m_init_packet_data_len != 0)
+         {
+             m_init_packet_valid = false;
+             return;
+         }
+
+         // Remove tag.
+         while (*ptr & 0x80)
+         {
+             ptr++;
+             size--;
+         }
+         ptr++;
+         size--;
+
+         // Store the info in init_packet_data.
+         m_init_packet_data_ptr = ptr;
+         m_init_packet_data_len = size;
+         m_init_packet_valid    = true;
+
+         LOG_DBG("PB: Init packet data len: %d", size);
+     }
+ }
+
+ /** @brief Function for decoding byte stream into variable.
+  *
+  *  @retval true   If the stored init command was successfully decoded.
+  *  @retval false  If there was no stored init command, or the decoding failed.
+  */
+ static bool stored_init_cmd_decode(void)
+ {
+     m_pb_stream = pb_istream_from_buffer(s_dfu_settings.init_command,
+                                          s_dfu_settings.progress.command_size);
+
+     dfu_init_command_t * p_init;
+
+     // Attach our callback to follow the field decoding.
+     m_pb_stream.decoding_callback = pb_decoding_callback;
+
+     m_init_packet_valid    = false;
+     m_init_packet_data_ptr = NULL;
+     m_init_packet_data_len = 0;
+     memset(&m_packet, 0, sizeof(m_packet));
+
+     if (!pb_decode(&m_pb_stream, dfu_packet_fields, &m_packet))
+     {
+         LOG_ERR("Handler: Invalid protocol buffer m_pb_stream");
+         return false;
+     }
+
+     if (!m_init_packet_valid || (m_packet.has_signed_command && m_packet.has_command))
+     {
+         LOG_ERR("Handler: Invalid init command.");
+         return false;
+     }
+     else if (m_packet.has_signed_command && m_packet.signed_command.command.has_init)
+     {
+         p_init = &m_packet.signed_command.command.init;
+
+         m_pb_stream = pb_istream_from_buffer(m_init_packet_data_ptr, m_init_packet_data_len);
+         memset(p_init, 0, sizeof(dfu_init_command_t));
+
+         if (!pb_decode(&m_pb_stream, dfu_init_command_fields, p_init))
+         {
+             LOG_ERR("Handler: Invalid protocol buffer m_pb_stream (init command)");
+             return false;
+         }
+     }
+     else if (m_packet.has_command && m_packet.command.has_init)
+     {
+         p_init = &m_packet.command.init;
+     }
+     else
+     {
+         return false;
+     }
+
+     mp_init = p_init;
+
+     return true;
+ }
+
+void nrf_dfu_validation_init(void)
+{
+     //If the command is stored to flash, init command was valid.
+     if ((s_dfu_settings.progress.command_size != 0) &&
+          stored_init_cmd_decode())
+     {
+         m_valid_init_cmd_present = true;
+     }
+     else
+     {
+         m_valid_init_cmd_present = false;
+     }    
+}
+
+
+nrf_dfu_result_t nrf_dfu_validation_init_cmd_create(uint32_t size)
+{
+    nrf_dfu_result_t ret_val = NRF_DFU_RES_CODE_SUCCESS;
+    if (size == 0)
+    {
+        ret_val = NRF_DFU_RES_CODE_INVALID_PARAMETER;
+    }
+    else if (size > INIT_COMMAND_MAX_SIZE)
+    {
+        ret_val = NRF_DFU_RES_CODE_INSUFFICIENT_RESOURCES;
+    }
+    else
+    {
+        // Set DFU to uninitialized.
+        m_valid_init_cmd_present = false;
+
+        // Reset all progress.
+        nrf_dfu_settings_progress_reset();
+
+        // Set the init command size.
+        s_dfu_settings.progress.command_size = size;
+    }
+    return ret_val;
+}
+
+
+nrf_dfu_result_t nrf_dfu_validation_init_cmd_append(uint8_t const * p_data, uint32_t length)
+{
+    nrf_dfu_result_t ret_val = NRF_DFU_RES_CODE_SUCCESS;
+    if ((length + s_dfu_settings.progress.command_offset) > s_dfu_settings.progress.command_size)
+    {
+        LOG_ERR("Init command larger than expected.");
+        ret_val = NRF_DFU_RES_CODE_INVALID_PARAMETER;
+    }
+    else
+    {
+        // Copy the received data to RAM, update offset and calculate CRC.
+        memcpy(&s_dfu_settings.init_command[s_dfu_settings.progress.command_offset],
+                p_data,
+                length);
+
+        s_dfu_settings.progress.command_offset += length;
+        s_dfu_settings.progress.command_crc = crc32_compute(p_data,
+                                                            length,
+                                                            &s_dfu_settings.progress.command_crc);
+    }
+    return ret_val;
+}
+
+
+void nrf_dfu_validation_init_cmd_status_get(uint32_t * p_offset,
+                                            uint32_t * p_crc,
+                                            uint32_t * p_max_size)
+{
+    *p_offset   = s_dfu_settings.progress.command_offset;
+    *p_crc      = s_dfu_settings.progress.command_crc;
+    *p_max_size = INIT_COMMAND_MAX_SIZE;
+}
+
+
+bool nrf_dfu_validation_init_cmd_present(void)
+{
+    return m_valid_init_cmd_present;    
+}
+
+// Function to calculate the total size of the firmware(s) in the update.
+static nrf_dfu_result_t update_data_size_get(dfu_init_command_t const * p_init, uint32_t * p_size)
+{
+    nrf_dfu_result_t ret_val = EXT_ERR(NRF_DFU_EXT_ERROR_INIT_COMMAND_INVALID);
+    uint32_t         fw_sz   = 0;
+
+    fw_sz = p_init->app_size;
+
+    if (fw_sz)
+    {
+        *p_size = fw_sz;
+        ret_val = NRF_DFU_RES_CODE_SUCCESS;
+    }
+    else
+    {
+        LOG_ERR("Init packet does not contain valid firmware size");
+    }
+
+    return ret_val;
+}
+
+/**@brief Function to determine where to temporarily store the incoming firmware.
+ *        This also checks whether the update will fit, and deletes existing
+ *        firmware to make room for the new firmware.
+ *
+ * @param[in]  p_init   Init command.
+ * @param[in]  fw_size  The size of the incoming firmware.
+ * @param[out] p_addr   The address at which to initially store the firmware.
+ *
+ * @retval NRF_DFU_RES_CODE_SUCCESS                 If the size check passed and
+ *                                                  an address was found.
+ * @retval NRF_DFU_RES_CODE_INSUFFICIENT_RESOURCES  If the size check failed.
+ */
+static nrf_dfu_result_t update_data_addr_get(dfu_init_command_t const * p_init,
+                                             uint32_t                   fw_size,
+                                             uint32_t                 * p_addr)
+{    
+    *p_addr = 0;
+#ifdef CONFIG_BOARD_HAS_NRF5_BOOTLOADER
+    *p_addr = nrf_dfu_bank1_start_addr();
+#endif    
+    return NRF_DFU_RES_CODE_SUCCESS;
+}
+
+
+nrf_dfu_result_t nrf_dfu_validation_init_cmd_execute(uint32_t * p_dst_data_addr,
+                                                     uint32_t * p_data_len)
+{
+    nrf_dfu_result_t ret_val = NRF_DFU_RES_CODE_SUCCESS;
+
+     if (s_dfu_settings.progress.command_offset != s_dfu_settings.progress.command_size)
+     {
+         // The object wasn't the right (requested) size.
+         LOG_ERR("Execute with faulty offset");
+         ret_val = NRF_DFU_RES_CODE_OPERATION_NOT_PERMITTED;
+     }
+     else if (m_valid_init_cmd_present)
+     {         
+         *p_dst_data_addr = 0;
+#ifdef CONFIG_BOARD_HAS_NRF5_BOOTLOADER
+        *p_dst_data_addr = nrf_dfu_bank1_start_addr();
+#endif
+         ret_val          = update_data_size_get(mp_init, p_data_len);
+     }
+     else if (stored_init_cmd_decode())
+     {
+         *p_dst_data_addr = 0;
+         *p_data_len      = 0;
+
+         ret_val = update_data_size_get(mp_init, p_data_len);
+
+         // Get address where to flash the binary.
+         if (ret_val == NRF_DFU_RES_CODE_SUCCESS)
+         {
+             ret_val = update_data_addr_get(mp_init, *p_data_len, p_dst_data_addr);
+         }
+
+         // Set flag validating the init command.
+         if (ret_val == NRF_DFU_RES_CODE_SUCCESS)
+         {
+             m_valid_init_cmd_present = true;
+         }
+         else
+         {
+             nrf_dfu_settings_progress_reset();
+         }
+     }
+     else
+     {
+         LOG_ERR("Failed to decode init packet");
+         ret_val = NRF_DFU_RES_CODE_INVALID_OBJECT;
+     }
+
+    return ret_val;
+}
+
diff --git a/subsys/nrf_dfu/common/pb_common.c b/subsys/nrf_dfu/common/pb_common.c
new file mode 100644
index 000000000..385c0193f
--- /dev/null
+++ b/subsys/nrf_dfu/common/pb_common.c
@@ -0,0 +1,97 @@
+/* pb_common.c: Common support functions for pb_encode.c and pb_decode.c.
+ *
+ * 2014 Petteri Aimonen <jpa@kapsi.fi>
+ */
+
+#include "pb_common.h"
+
+bool pb_field_iter_begin(pb_field_iter_t *iter, const pb_field_t *fields, void *dest_struct)
+{
+    iter->start = fields;
+    iter->pos = fields;
+    iter->required_field_index = 0;
+    iter->dest_struct = dest_struct;
+    iter->pData = (char*)dest_struct + iter->pos->data_offset;
+    iter->pSize = (char*)iter->pData + iter->pos->size_offset;
+    
+    return (iter->pos->tag != 0);
+}
+
+bool pb_field_iter_next(pb_field_iter_t *iter)
+{
+    const pb_field_t *prev_field = iter->pos;
+
+    if (prev_field->tag == 0)
+    {
+        /* Handle empty message types, where the first field is already the terminator.
+         * In other cases, the iter->pos never points to the terminator. */
+        return false;
+    }
+    
+    iter->pos++;
+    
+    if (iter->pos->tag == 0)
+    {
+        /* Wrapped back to beginning, reinitialize */
+        (void)pb_field_iter_begin(iter, iter->start, iter->dest_struct);
+        return false;
+    }
+    else
+    {
+        /* Increment the pointers based on previous field size */
+        size_t prev_size = prev_field->data_size;
+    
+        if (PB_HTYPE(prev_field->type) == PB_HTYPE_ONEOF &&
+            PB_HTYPE(iter->pos->type) == PB_HTYPE_ONEOF)
+        {
+            /* Don't advance pointers inside unions */
+            prev_size = 0;
+            iter->pData = (char*)iter->pData - prev_field->data_offset;
+        }
+        else if (PB_ATYPE(prev_field->type) == PB_ATYPE_STATIC &&
+                 PB_HTYPE(prev_field->type) == PB_HTYPE_REPEATED)
+        {
+            /* In static arrays, the data_size tells the size of a single entry and
+             * array_size is the number of entries */
+            prev_size *= prev_field->array_size;
+        }
+        else if (PB_ATYPE(prev_field->type) == PB_ATYPE_POINTER)
+        {
+            /* Pointer fields always have a constant size in the main structure.
+             * The data_size only applies to the dynamically allocated area. */
+            prev_size = sizeof(void*);
+        }
+
+        if (PB_HTYPE(prev_field->type) == PB_HTYPE_REQUIRED)
+        {
+            /* Count the required fields, in order to check their presence in the
+             * decoder. */
+            iter->required_field_index++;
+        }
+    
+        iter->pData = (char*)iter->pData + prev_size + iter->pos->data_offset;
+        iter->pSize = (char*)iter->pData + iter->pos->size_offset;
+        return true;
+    }
+}
+
+bool pb_field_iter_find(pb_field_iter_t *iter, uint32_t tag)
+{
+    const pb_field_t *start = iter->pos;
+    
+    do {
+        if (iter->pos->tag == tag &&
+            PB_LTYPE(iter->pos->type) != PB_LTYPE_EXTENSION)
+        {
+            /* Found the wanted field */
+            return true;
+        }
+        
+        (void)pb_field_iter_next(iter);
+    } while (iter->pos != start);
+    
+    /* Searched all the way back to start, and found nothing. */
+    return false;
+}
+
+
diff --git a/subsys/nrf_dfu/common/pb_decode.c b/subsys/nrf_dfu/common/pb_decode.c
new file mode 100644
index 000000000..ef69efe4a
--- /dev/null
+++ b/subsys/nrf_dfu/common/pb_decode.c
@@ -0,0 +1,1340 @@
+/* pb_decode.c -- decode a protobuf using minimal resources
+ *
+ * 2011 Petteri Aimonen <jpa@kapsi.fi>
+ */
+
+/* Use the GCC warn_unused_result attribute to check that all return values
+ * are propagated correctly. On other compilers and gcc before 3.4.0 just
+ * ignore the annotation.
+ */
+#if !defined(__GNUC__) || ( __GNUC__ < 3) || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)
+    #define checkreturn
+#else
+    #define checkreturn __attribute__((warn_unused_result))
+#endif
+
+#include "pb.h"
+#include "pb_decode.h"
+#include "pb_common.h"
+
+/**************************************
+ * Declarations internal to this file *
+ **************************************/
+
+typedef bool (*pb_decoder_t)(pb_istream_t *stream, const pb_field_t *field, void *dest) checkreturn;
+
+static bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count);
+static bool checkreturn pb_decode_varint32(pb_istream_t *stream, uint32_t *dest);
+static bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size);
+static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);
+static bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);
+static bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);
+static void iter_from_extension(pb_field_iter_t *iter, pb_extension_t *extension);
+static bool checkreturn default_extension_decoder(pb_istream_t *stream, pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type);
+static bool checkreturn decode_extension(pb_istream_t *stream, uint32_t tag, pb_wire_type_t wire_type, pb_field_iter_t *iter);
+static bool checkreturn find_extension_field(pb_field_iter_t *iter);
+static void pb_field_set_to_default(pb_field_iter_t *iter);
+static void pb_message_set_to_defaults(const pb_field_t fields[], void *dest_struct);
+static bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_dec_uvarint(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_dec_svarint(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_dec_fixed32(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_dec_fixed64(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_skip_varint(pb_istream_t *stream);
+static bool checkreturn pb_skip_string(pb_istream_t *stream);
+
+#ifdef PB_ENABLE_MALLOC
+static bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size);
+static bool checkreturn pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *iter);
+static void pb_release_single_field(const pb_field_iter_t *iter);
+#endif
+
+/* --- Function pointers to field decoders ---
+ * Order in the array must match pb_action_t LTYPE numbering.
+ */
+static const pb_decoder_t PB_DECODERS[PB_LTYPES_COUNT] = {
+    &pb_dec_varint,
+    &pb_dec_uvarint,
+    &pb_dec_svarint,
+    &pb_dec_fixed32,
+    &pb_dec_fixed64,
+    
+    &pb_dec_bytes,
+    &pb_dec_string,
+    &pb_dec_submessage,
+    NULL /* extensions */
+};
+
+/*******************************
+ * pb_istream_t implementation *
+ *******************************/
+
+static bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)
+{
+    const pb_byte_t *source = (const pb_byte_t*)stream->state;
+    stream->state = (pb_byte_t*)stream->state + count;
+    
+    if (buf != NULL)
+    {
+        while (count--)
+            *buf++ = *source++;
+    }
+    
+    return true;
+}
+
+bool checkreturn pb_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)
+{
+#ifndef PB_BUFFER_ONLY
+	if (buf == NULL && stream->callback != buf_read)
+	{
+		/* Skip input bytes */
+		pb_byte_t tmp[16];
+		while (count > 16)
+		{
+			if (!pb_read(stream, tmp, 16))
+				return false;
+			
+			count -= 16;
+		}
+		
+		return pb_read(stream, tmp, count);
+	}
+#endif
+
+    if (stream->bytes_left < count)
+        PB_RETURN_ERROR(stream, "end-of-stream");
+    
+#ifndef PB_BUFFER_ONLY
+    if (!stream->callback(stream, buf, count))
+        PB_RETURN_ERROR(stream, "io error");
+#else
+    if (!buf_read(stream, buf, count))
+        return false;
+#endif
+    
+    stream->bytes_left -= count;
+    return true;
+}
+
+/* Read a single byte from input stream. buf may not be NULL.
+ * This is an optimization for the varint decoding. */
+static bool checkreturn pb_readbyte(pb_istream_t *stream, pb_byte_t *buf)
+{
+    if (stream->bytes_left == 0)
+        PB_RETURN_ERROR(stream, "end-of-stream");
+
+#ifndef PB_BUFFER_ONLY
+    if (!stream->callback(stream, buf, 1))
+        PB_RETURN_ERROR(stream, "io error");
+#else
+    *buf = *(const pb_byte_t*)stream->state;
+    stream->state = (pb_byte_t*)stream->state + 1;
+#endif
+
+    stream->bytes_left--;
+    
+    return true;    
+}
+
+pb_istream_t pb_istream_from_buffer(const pb_byte_t *buf, size_t bufsize)
+{
+    pb_istream_t stream;
+    /* Cast away the const from buf without a compiler error.  We are
+     * careful to use it only in a const manner in the callbacks.
+     */
+    union {
+        void *state;
+        const void *c_state;
+    } state;
+#ifdef PB_BUFFER_ONLY
+    stream.callback = NULL;
+#else
+    stream.callback = &buf_read;
+#endif
+    state.c_state = buf;
+    stream.state = state.state;
+    stream.bytes_left = bufsize;
+    stream.decoding_callback = NULL;
+#ifndef PB_NO_ERRMSG
+    stream.errmsg = NULL;
+#endif
+    return stream;
+}
+
+/********************
+ * Helper functions *
+ ********************/
+
+static bool checkreturn pb_decode_varint32(pb_istream_t *stream, uint32_t *dest)
+{
+    pb_byte_t byte;
+    uint32_t result;
+    
+    if (!pb_readbyte(stream, &byte))
+        return false;
+    
+    if ((byte & 0x80) == 0)
+    {
+        /* Quick case, 1 byte value */
+        result = byte;
+    }
+    else
+    {
+        /* Multibyte case */
+        uint_fast8_t bitpos = 7;
+        result = byte & 0x7F;
+        
+        do
+        {
+            if (bitpos >= 32)
+                PB_RETURN_ERROR(stream, "varint overflow");
+            
+            if (!pb_readbyte(stream, &byte))
+                return false;
+            
+            result |= (uint32_t)(byte & 0x7F) << bitpos;
+            bitpos = (uint_fast8_t)(bitpos + 7);
+        } while (byte & 0x80);
+   }
+   
+   *dest = result;
+   return true;
+}
+
+bool checkreturn pb_decode_varint(pb_istream_t *stream, uint64_t *dest)
+{
+    pb_byte_t byte;
+    uint_fast8_t bitpos = 0;
+    uint64_t result = 0;
+    
+    do
+    {
+        if (bitpos >= 64)
+            PB_RETURN_ERROR(stream, "varint overflow");
+        
+        if (!pb_readbyte(stream, &byte))
+            return false;
+
+        result |= (uint64_t)(byte & 0x7F) << bitpos;
+        bitpos = (uint_fast8_t)(bitpos + 7);
+    } while (byte & 0x80);
+    
+    *dest = result;
+    return true;
+}
+
+bool checkreturn pb_skip_varint(pb_istream_t *stream)
+{
+    pb_byte_t byte;
+    do
+    {
+        if (!pb_read(stream, &byte, 1))
+            return false;
+    } while (byte & 0x80);
+    return true;
+}
+
+bool checkreturn pb_skip_string(pb_istream_t *stream)
+{
+    uint32_t length;
+    if (!pb_decode_varint32(stream, &length))
+        return false;
+    
+    return pb_read(stream, NULL, length);
+}
+
+bool checkreturn pb_decode_tag(pb_istream_t *stream, pb_wire_type_t *wire_type, uint32_t *tag, bool *eof)
+{
+    uint32_t temp;
+    *eof = false;
+    *wire_type = (pb_wire_type_t) 0;
+    *tag = 0;
+    
+    if (!pb_decode_varint32(stream, &temp))
+    {
+        if (stream->bytes_left == 0)
+            *eof = true;
+
+        return false;
+    }
+    
+    if (temp == 0)
+    {
+        *eof = true; /* Special feature: allow 0-terminated messages. */
+        return false;
+    }
+    
+    *tag = temp >> 3;
+    *wire_type = (pb_wire_type_t)(temp & 7);
+    return true;
+}
+
+bool checkreturn pb_skip_field(pb_istream_t *stream, pb_wire_type_t wire_type)
+{
+    switch (wire_type)
+    {
+        case PB_WT_VARINT: return pb_skip_varint(stream);
+        case PB_WT_64BIT: return pb_read(stream, NULL, 8);
+        case PB_WT_STRING: return pb_skip_string(stream);
+        case PB_WT_32BIT: return pb_read(stream, NULL, 4);
+        default: PB_RETURN_ERROR(stream, "invalid wire_type");
+    }
+}
+
+/* Read a raw value to buffer, for the purpose of passing it to callback as
+ * a substream. Size is maximum size on call, and actual size on return.
+ */
+static bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size)
+{
+    size_t max_size = *size;
+    switch (wire_type)
+    {
+        case PB_WT_VARINT:
+            *size = 0;
+            do
+            {
+                (*size)++;
+                if (*size > max_size) return false;
+                if (!pb_read(stream, buf, 1)) return false;
+            } while (*buf++ & 0x80);
+            return true;
+            
+        case PB_WT_64BIT:
+            *size = 8;
+            return pb_read(stream, buf, 8);
+        
+        case PB_WT_32BIT:
+            *size = 4;
+            return pb_read(stream, buf, 4);
+        
+        default: PB_RETURN_ERROR(stream, "invalid wire_type");
+    }
+}
+
+/* Decode string length from stream and return a substream with limited length.
+ * Remember to close the substream using pb_close_string_substream().
+ */
+bool checkreturn pb_make_string_substream(pb_istream_t *stream, pb_istream_t *substream)
+{
+    uint32_t size;
+    if (!pb_decode_varint32(stream, &size))
+        return false;
+    
+    *substream = *stream;
+    if (substream->bytes_left < size)
+        PB_RETURN_ERROR(stream, "parent stream too short");
+    
+    substream->bytes_left = size;
+    stream->bytes_left -= size;
+    return true;
+}
+
+void pb_close_string_substream(pb_istream_t *stream, pb_istream_t *substream)
+{
+    stream->state = substream->state;
+
+#ifndef PB_NO_ERRMSG
+    stream->errmsg = substream->errmsg;
+#endif
+}
+
+/*************************
+ * Decode a single field *
+ *************************/
+
+static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)
+{
+    pb_type_t type;
+    pb_decoder_t func;
+    
+    type = iter->pos->type;
+    func = PB_DECODERS[PB_LTYPE(type)];
+
+    switch (PB_HTYPE(type))
+    {
+        case PB_HTYPE_REQUIRED:
+            return func(stream, iter->pos, iter->pData);
+            
+        case PB_HTYPE_OPTIONAL:
+            *(bool*)iter->pSize = true;
+            return func(stream, iter->pos, iter->pData);
+    
+        case PB_HTYPE_REPEATED:
+            if (wire_type == PB_WT_STRING
+                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)
+            {
+                /* Packed array */
+                bool status = true;
+                pb_size_t *size = (pb_size_t*)iter->pSize;
+                pb_istream_t substream;
+                if (!pb_make_string_substream(stream, &substream))
+                    return false;
+                
+                while (substream.bytes_left > 0 && *size < iter->pos->array_size)
+                {
+                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);
+                    if (!func(&substream, iter->pos, pItem))
+                    {
+                        status = false;
+                        break;
+                    }
+                    (*size)++;
+                }
+                pb_close_string_substream(stream, &substream);
+                
+                if (substream.bytes_left != 0)
+                    PB_RETURN_ERROR(stream, "array overflow");
+                
+                return status;
+            }
+            else
+            {
+                /* Repeated field */
+                pb_size_t *size = (pb_size_t*)iter->pSize;
+                void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);
+                if (*size >= iter->pos->array_size)
+                    PB_RETURN_ERROR(stream, "array overflow");
+                
+                (*size)++;
+                return func(stream, iter->pos, pItem);
+            }
+
+        case PB_HTYPE_ONEOF:
+            *(pb_size_t*)iter->pSize = iter->pos->tag;
+            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)
+            {
+                /* We memset to zero so that any callbacks are set to NULL.
+                 * Then set any default values. */
+                memset(iter->pData, 0, iter->pos->data_size);
+                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);
+            }
+            return func(stream, iter->pos, iter->pData);
+
+        default:
+            PB_RETURN_ERROR(stream, "invalid field type");
+    }
+}
+
+#ifdef PB_ENABLE_MALLOC
+/* Allocate storage for the field and store the pointer at iter->pData.
+ * array_size is the number of entries to reserve in an array.
+ * Zero size is not allowed, use pb_free() for releasing.
+ */
+static bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size)
+{    
+    void *ptr = *(void**)pData;
+    
+    if (data_size == 0 || array_size == 0)
+        PB_RETURN_ERROR(stream, "invalid size");
+    
+    /* Check for multiplication overflows.
+     * This code avoids the costly division if the sizes are small enough.
+     * Multiplication is safe as long as only half of bits are set
+     * in either multiplicand.
+     */
+    {
+        const size_t check_limit = (size_t)1 << (sizeof(size_t) * 4);
+        if (data_size >= check_limit || array_size >= check_limit)
+        {
+            const size_t size_max = (size_t)-1;
+            if (size_max / array_size < data_size)
+            {
+                PB_RETURN_ERROR(stream, "size too large");
+            }
+        }
+    }
+    
+    /* Allocate new or expand previous allocation */
+    /* Note: on failure the old pointer will remain in the structure,
+     * the message must be freed by caller also on error return. */
+    ptr = pb_realloc(ptr, array_size * data_size);
+    if (ptr == NULL)
+        PB_RETURN_ERROR(stream, "realloc failed");
+    
+    *(void**)pData = ptr;
+    return true;
+}
+
+/* Clear a newly allocated item in case it contains a pointer, or is a submessage. */
+static void initialize_pointer_field(void *pItem, pb_field_iter_t *iter)
+{
+    if (PB_LTYPE(iter->pos->type) == PB_LTYPE_STRING ||
+        PB_LTYPE(iter->pos->type) == PB_LTYPE_BYTES)
+    {
+        *(void**)pItem = NULL;
+    }
+    else if (PB_LTYPE(iter->pos->type) == PB_LTYPE_SUBMESSAGE)
+    {
+        pb_message_set_to_defaults((const pb_field_t *) iter->pos->ptr, pItem);
+    }
+}
+#endif
+
+static bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)
+{
+#ifndef PB_ENABLE_MALLOC
+    PB_UNUSED(wire_type);
+    PB_UNUSED(iter);
+    PB_RETURN_ERROR(stream, "no malloc support");
+#else
+    pb_type_t type;
+    pb_decoder_t func;
+    
+    type = iter->pos->type;
+    func = PB_DECODERS[PB_LTYPE(type)];
+    
+    switch (PB_HTYPE(type))
+    {
+        case PB_HTYPE_REQUIRED:
+        case PB_HTYPE_OPTIONAL:
+        case PB_HTYPE_ONEOF:
+            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&
+                *(void**)iter->pData != NULL)
+            {
+                /* Duplicate field, have to release the old allocation first. */
+                pb_release_single_field(iter);
+            }
+        
+            if (PB_HTYPE(type) == PB_HTYPE_ONEOF)
+            {
+                *(pb_size_t*)iter->pSize = iter->pos->tag;
+            }
+
+            if (PB_LTYPE(type) == PB_LTYPE_STRING ||
+                PB_LTYPE(type) == PB_LTYPE_BYTES)
+            {
+                return func(stream, iter->pos, iter->pData);
+            }
+            else
+            {
+                if (!allocate_field(stream, iter->pData, iter->pos->data_size, 1))
+                    return false;
+                
+                initialize_pointer_field(*(void**)iter->pData, iter);
+                return func(stream, iter->pos, *(void**)iter->pData);
+            }
+    
+        case PB_HTYPE_REPEATED:
+            if (wire_type == PB_WT_STRING
+                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)
+            {
+                /* Packed array, multiple items come in at once. */
+                bool status = true;
+                pb_size_t *size = (pb_size_t*)iter->pSize;
+                size_t allocated_size = *size;
+                void *pItem;
+                pb_istream_t substream;
+                
+                if (!pb_make_string_substream(stream, &substream))
+                    return false;
+                
+                while (substream.bytes_left)
+                {
+                    if ((size_t)*size + 1 > allocated_size)
+                    {
+                        /* Allocate more storage. This tries to guess the
+                         * number of remaining entries. Round the division
+                         * upwards. */
+                        allocated_size += (substream.bytes_left - 1) / iter->pos->data_size + 1;
+                        
+                        if (!allocate_field(&substream, iter->pData, iter->pos->data_size, allocated_size))
+                        {
+                            status = false;
+                            break;
+                        }
+                    }
+
+                    /* Decode the array entry */
+                    pItem = *(char**)iter->pData + iter->pos->data_size * (*size);
+                    initialize_pointer_field(pItem, iter);
+                    if (!func(&substream, iter->pos, pItem))
+                    {
+                        status = false;
+                        break;
+                    }
+                    
+                    if (*size == PB_SIZE_MAX)
+                    {
+#ifndef PB_NO_ERRMSG
+                        stream->errmsg = "too many array entries";
+#endif
+                        status = false;
+                        break;
+                    }
+                    
+                    (*size)++;
+                }
+                pb_close_string_substream(stream, &substream);
+                
+                return status;
+            }
+            else
+            {
+                /* Normal repeated field, i.e. only one item at a time. */
+                pb_size_t *size = (pb_size_t*)iter->pSize;
+                void *pItem;
+                
+                if (*size == PB_SIZE_MAX)
+                    PB_RETURN_ERROR(stream, "too many array entries");
+                
+                (*size)++;
+                if (!allocate_field(stream, iter->pData, iter->pos->data_size, *size))
+                    return false;
+            
+                pItem = *(char**)iter->pData + iter->pos->data_size * (*size - 1);
+                initialize_pointer_field(pItem, iter);
+                return func(stream, iter->pos, pItem);
+            }
+
+        default:
+            PB_RETURN_ERROR(stream, "invalid field type");
+    }
+#endif
+}
+
+static bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)
+{
+    pb_callback_t *pCallback = (pb_callback_t*)iter->pData;
+    
+#ifdef PB_OLD_CALLBACK_STYLE
+    void *arg = pCallback->arg;
+#else
+    void **arg = &(pCallback->arg);
+#endif
+    
+    if (pCallback->funcs.decode == NULL)
+        return pb_skip_field(stream, wire_type);
+    
+    if (wire_type == PB_WT_STRING)
+    {
+        pb_istream_t substream;
+        
+        if (!pb_make_string_substream(stream, &substream))
+            return false;
+        
+        do
+        {
+            if (!pCallback->funcs.decode(&substream, iter->pos, arg))
+                PB_RETURN_ERROR(stream, "callback failed");
+        } while (substream.bytes_left);
+        
+        pb_close_string_substream(stream, &substream);
+        return true;
+    }
+    else
+    {
+        /* Copy the single scalar value to stack.
+         * This is required so that we can limit the stream length,
+         * which in turn allows to use same callback for packed and
+         * not-packed fields. */
+        pb_istream_t substream;
+        pb_byte_t buffer[10];
+        size_t size = sizeof(buffer);
+        
+        if (!read_raw_value(stream, wire_type, buffer, &size))
+            return false;
+        substream = pb_istream_from_buffer(buffer, size);
+        
+        return pCallback->funcs.decode(&substream, iter->pos, arg);
+    }
+}
+
+static bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)
+{
+#ifdef PB_ENABLE_MALLOC
+    /* When decoding an oneof field, check if there is old data that must be
+     * released first. */
+    if (PB_HTYPE(iter->pos->type) == PB_HTYPE_ONEOF)
+    {
+        if (!pb_release_union_field(stream, iter))
+            return false;
+    }
+#endif
+
+    switch (PB_ATYPE(iter->pos->type))
+    {
+        case PB_ATYPE_STATIC:
+            return decode_static_field(stream, wire_type, iter);
+        
+        case PB_ATYPE_POINTER:
+            return decode_pointer_field(stream, wire_type, iter);
+        
+        case PB_ATYPE_CALLBACK:
+            return decode_callback_field(stream, wire_type, iter);
+        
+        default:
+            PB_RETURN_ERROR(stream, "invalid field type");
+    }
+}
+
+static void iter_from_extension(pb_field_iter_t *iter, pb_extension_t *extension)
+{
+    /* Fake a field iterator for the extension field.
+     * It is not actually safe to advance this iterator, but decode_field
+     * will not even try to. */
+    const pb_field_t *field = (const pb_field_t*)extension->type->arg;
+    (void)pb_field_iter_begin(iter, field, extension->dest);
+    iter->pData = extension->dest;
+    iter->pSize = &extension->found;
+    
+    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
+    {
+        /* For pointer extensions, the pointer is stored directly
+         * in the extension structure. This avoids having an extra
+         * indirection. */
+        iter->pData = &extension->dest;
+    }
+}
+
+/* Default handler for extension fields. Expects a pb_field_t structure
+ * in extension->type->arg. */
+static bool checkreturn default_extension_decoder(pb_istream_t *stream,
+    pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type)
+{
+    const pb_field_t *field = (const pb_field_t*)extension->type->arg;
+    pb_field_iter_t iter;
+    
+    if (field->tag != tag)
+        return true;
+    
+    iter_from_extension(&iter, extension);
+    extension->found = true;
+    return decode_field(stream, wire_type, &iter);
+}
+
+/* Try to decode an unknown field as an extension field. Tries each extension
+ * decoder in turn, until one of them handles the field or loop ends. */
+static bool checkreturn decode_extension(pb_istream_t *stream,
+    uint32_t tag, pb_wire_type_t wire_type, pb_field_iter_t *iter)
+{
+    pb_extension_t *extension = *(pb_extension_t* const *)iter->pData;
+    size_t pos = stream->bytes_left;
+    
+    while (extension != NULL && pos == stream->bytes_left)
+    {
+        bool status;
+        if (extension->type->decode)
+            status = extension->type->decode(stream, extension, tag, wire_type);
+        else
+            status = default_extension_decoder(stream, extension, tag, wire_type);
+
+        if (!status)
+            return false;
+        
+        extension = extension->next;
+    }
+    
+    return true;
+}
+
+/* Step through the iterator until an extension field is found or until all
+ * entries have been checked. There can be only one extension field per
+ * message. Returns false if no extension field is found. */
+static bool checkreturn find_extension_field(pb_field_iter_t *iter)
+{
+    const pb_field_t *start = iter->pos;
+    
+    do {
+        if (PB_LTYPE(iter->pos->type) == PB_LTYPE_EXTENSION)
+            return true;
+        (void)pb_field_iter_next(iter);
+    } while (iter->pos != start);
+    
+    return false;
+}
+
+/* Initialize message fields to default values, recursively */
+static void pb_field_set_to_default(pb_field_iter_t *iter)
+{
+    pb_type_t type;
+    type = iter->pos->type;
+    
+    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)
+    {
+        pb_extension_t *ext = *(pb_extension_t* const *)iter->pData;
+        while (ext != NULL)
+        {
+            pb_field_iter_t ext_iter;
+            ext->found = false;
+            iter_from_extension(&ext_iter, ext);
+            pb_field_set_to_default(&ext_iter);
+            ext = ext->next;
+        }
+    }
+    else if (PB_ATYPE(type) == PB_ATYPE_STATIC)
+    {
+        bool init_data = true;
+        if (PB_HTYPE(type) == PB_HTYPE_OPTIONAL)
+        {
+            /* Set has_field to false. Still initialize the optional field
+             * itself also. */
+            *(bool*)iter->pSize = false;
+        }
+        else if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||
+                 PB_HTYPE(type) == PB_HTYPE_ONEOF)
+        {
+            /* REPEATED: Set array count to 0, no need to initialize contents.
+               ONEOF: Set which_field to 0. */
+            *(pb_size_t*)iter->pSize = 0;
+            init_data = false;
+        }
+
+        if (init_data)
+        {
+            if (PB_LTYPE(iter->pos->type) == PB_LTYPE_SUBMESSAGE)
+            {
+                /* Initialize submessage to defaults */
+                pb_message_set_to_defaults((const pb_field_t *) iter->pos->ptr, iter->pData);
+            }
+            else if (iter->pos->ptr != NULL)
+            {
+                /* Initialize to default value */
+                memcpy(iter->pData, iter->pos->ptr, iter->pos->data_size);
+            }
+            else
+            {
+                /* Initialize to zeros */
+                memset(iter->pData, 0, iter->pos->data_size);
+            }
+        }
+    }
+    else if (PB_ATYPE(type) == PB_ATYPE_POINTER)
+    {
+        /* Initialize the pointer to NULL. */
+        *(void**)iter->pData = NULL;
+        
+        /* Initialize array count to 0. */
+        if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||
+            PB_HTYPE(type) == PB_HTYPE_ONEOF)
+        {
+            *(pb_size_t*)iter->pSize = 0;
+        }
+    }
+    else if (PB_ATYPE(type) == PB_ATYPE_CALLBACK)
+    {
+        /* Don't overwrite callback */
+    }
+}
+
+static void pb_message_set_to_defaults(const pb_field_t fields[], void *dest_struct)
+{
+    pb_field_iter_t iter;
+
+    if (!pb_field_iter_begin(&iter, fields, dest_struct))
+        return; /* Empty message type */
+    
+    do
+    {
+        pb_field_set_to_default(&iter);
+    } while (pb_field_iter_next(&iter));
+}
+
+/*********************
+ * Decode all fields *
+ *********************/
+
+bool checkreturn pb_decode_noinit(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)
+{
+    uint32_t fields_seen[(PB_MAX_REQUIRED_FIELDS + 31) / 32] = {0, 0};
+    const uint32_t allbits = ~(uint32_t)0;
+    uint32_t extension_range_start = 0;
+    pb_field_iter_t iter;
+    
+    /* Return value ignored, as empty message types will be correctly handled by
+     * pb_field_iter_find() anyway. */
+    (void)pb_field_iter_begin(&iter, fields, dest_struct);
+    
+    while (stream->bytes_left)
+    {
+        uint32_t tag;
+        pb_wire_type_t wire_type;
+        bool eof;
+        
+        if (!pb_decode_tag(stream, &wire_type, &tag, &eof))
+        {
+            if (eof)
+                break;
+            else
+                return false;
+        }
+        
+        if (!pb_field_iter_find(&iter, tag))
+        {
+            /* No match found, check if it matches an extension. */
+            if (tag >= extension_range_start)
+            {
+                if (!find_extension_field(&iter))
+                    extension_range_start = (uint32_t)-1;
+                else
+                    extension_range_start = iter.pos->tag;
+                
+                if (tag >= extension_range_start)
+                {
+                    size_t pos = stream->bytes_left;
+                
+                    if (!decode_extension(stream, tag, wire_type, &iter))
+                        return false;
+                    
+                    if (pos != stream->bytes_left)
+                    {
+                        /* The field was handled */
+                        continue;                    
+                    }
+                }
+            }
+        
+            /* No match found, skip data */
+            if (!pb_skip_field(stream, wire_type))
+                return false;
+            continue;
+        }
+        
+        if (PB_HTYPE(iter.pos->type) == PB_HTYPE_REQUIRED
+            && iter.required_field_index < PB_MAX_REQUIRED_FIELDS)
+        {
+            uint32_t tmp = ((uint32_t)1 << (iter.required_field_index & 31));
+            fields_seen[iter.required_field_index >> 5] |= tmp;
+        }
+
+        if(stream->decoding_callback)
+        {
+            stream->decoding_callback(stream, tag, wire_type, &iter);
+        }
+
+        if (!decode_field(stream, wire_type, &iter))
+            return false;
+    }
+    
+    /* Check that all required fields were present. */
+    {
+        /* First figure out the number of required fields by
+         * seeking to the end of the field array. Usually we
+         * are already close to end after decoding.
+         */
+        unsigned req_field_count;
+        pb_type_t last_type;
+        unsigned i;
+        do {
+            req_field_count = iter.required_field_index;
+            last_type = iter.pos->type;
+        } while (pb_field_iter_next(&iter));
+        
+        /* Fixup if last field was also required. */
+        if (PB_HTYPE(last_type) == PB_HTYPE_REQUIRED && iter.pos->tag != 0)
+            req_field_count++;
+        
+        if (req_field_count > 0)
+        {
+            /* Check the whole words */
+            for (i = 0; i < (req_field_count >> 5); i++)
+            {
+                if (fields_seen[i] != allbits)
+                    PB_RETURN_ERROR(stream, "missing required field");
+            }
+            
+            /* Check the remaining bits */
+            if (fields_seen[req_field_count >> 5] != (allbits >> (32 - (req_field_count & 31))))
+                PB_RETURN_ERROR(stream, "missing required field");
+        }
+    }
+    
+    return true;
+}
+
+bool checkreturn pb_decode(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)
+{
+    bool status;
+    pb_message_set_to_defaults(fields, dest_struct);
+    status = pb_decode_noinit(stream, fields, dest_struct);
+    
+#ifdef PB_ENABLE_MALLOC
+    if (!status)
+        pb_release(fields, dest_struct);
+#endif
+    
+    return status;
+}
+
+bool pb_decode_delimited(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)
+{
+    pb_istream_t substream;
+    bool status;
+    
+    if (!pb_make_string_substream(stream, &substream))
+        return false;
+    
+    status = pb_decode(&substream, fields, dest_struct);
+    pb_close_string_substream(stream, &substream);
+    return status;
+}
+
+#ifdef PB_ENABLE_MALLOC
+/* Given an oneof field, if there has already been a field inside this oneof,
+ * release it before overwriting with a different one. */
+static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *iter)
+{
+    pb_size_t old_tag = *(pb_size_t*)iter->pSize; /* Previous which_ value */
+    pb_size_t new_tag = iter->pos->tag; /* New which_ value */
+
+    if (old_tag == 0)
+        return true; /* Ok, no old data in union */
+
+    if (old_tag == new_tag)
+        return true; /* Ok, old data is of same type => merge */
+
+    /* Release old data. The find can fail if the message struct contains
+     * invalid data. */
+    if (!pb_field_iter_find(iter, old_tag))
+        PB_RETURN_ERROR(stream, "invalid union tag");
+
+    pb_release_single_field(iter);
+
+    /* Restore iterator to where it should be.
+     * This shouldn't fail unless the pb_field_t structure is corrupted. */
+    if (!pb_field_iter_find(iter, new_tag))
+        PB_RETURN_ERROR(stream, "iterator error");
+    
+    return true;
+}
+
+static void pb_release_single_field(const pb_field_iter_t *iter)
+{
+    pb_type_t type;
+    type = iter->pos->type;
+
+    if (PB_HTYPE(type) == PB_HTYPE_ONEOF)
+    {
+        if (*(pb_size_t*)iter->pSize != iter->pos->tag)
+            return; /* This is not the current field in the union */
+    }
+
+    /* Release anything contained inside an extension or submsg.
+     * This has to be done even if the submsg itself is statically
+     * allocated. */
+    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)
+    {
+        /* Release fields from all extensions in the linked list */
+        pb_extension_t *ext = *(pb_extension_t**)iter->pData;
+        while (ext != NULL)
+        {
+            pb_field_iter_t ext_iter;
+            iter_from_extension(&ext_iter, ext);
+            pb_release_single_field(&ext_iter);
+            ext = ext->next;
+        }
+    }
+    else if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)
+    {
+        /* Release fields in submessage or submsg array */
+        void *pItem = iter->pData;
+        pb_size_t count = 1;
+        
+        if (PB_ATYPE(type) == PB_ATYPE_POINTER)
+        {
+            pItem = *(void**)iter->pData;
+        }
+        
+        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)
+        {
+            count = *(pb_size_t*)iter->pSize;
+        }
+        
+        if (pItem)
+        {
+            while (count--)
+            {
+                pb_release((const pb_field_t*)iter->pos->ptr, pItem);
+                pItem = (char*)pItem + iter->pos->data_size;
+            }
+        }
+    }
+    
+    if (PB_ATYPE(type) == PB_ATYPE_POINTER)
+    {
+        if (PB_HTYPE(type) == PB_HTYPE_REPEATED &&
+            (PB_LTYPE(type) == PB_LTYPE_STRING ||
+             PB_LTYPE(type) == PB_LTYPE_BYTES))
+        {
+            /* Release entries in repeated string or bytes array */
+            void **pItem = *(void***)iter->pData;
+            pb_size_t count = *(pb_size_t*)iter->pSize;
+            while (count--)
+            {
+                pb_free(*pItem);
+                *pItem++ = NULL;
+            }
+        }
+        
+        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)
+        {
+            /* We are going to release the array, so set the size to 0 */
+            *(pb_size_t*)iter->pSize = 0;
+        }
+        
+        /* Release main item */
+        pb_free(*(void**)iter->pData);
+        *(void**)iter->pData = NULL;
+    }
+}
+
+void pb_release(const pb_field_t fields[], void *dest_struct)
+{
+    pb_field_iter_t iter;
+    
+    if (!dest_struct)
+        return; /* Ignore NULL pointers, similar to free() */
+
+    if (!pb_field_iter_begin(&iter, fields, dest_struct))
+        return; /* Empty message type */
+    
+    do
+    {
+        pb_release_single_field(&iter);
+    } while (pb_field_iter_next(&iter));
+}
+#endif
+
+/* Field decoders */
+
+bool pb_decode_svarint(pb_istream_t *stream, int64_t *dest)
+{
+    uint64_t value;
+    if (!pb_decode_varint(stream, &value))
+        return false;
+    
+    if (value & 1)
+        *dest = (int64_t)(~(value >> 1));
+    else
+        *dest = (int64_t)(value >> 1);
+    
+    return true;
+}
+
+bool pb_decode_fixed32(pb_istream_t *stream, void *dest)
+{
+    pb_byte_t bytes[4];
+
+    if (!pb_read(stream, bytes, 4))
+        return false;
+    
+    *(uint32_t*)dest = ((uint32_t)bytes[0] << 0) |
+                       ((uint32_t)bytes[1] << 8) |
+                       ((uint32_t)bytes[2] << 16) |
+                       ((uint32_t)bytes[3] << 24);
+    return true;
+}
+
+bool pb_decode_fixed64(pb_istream_t *stream, void *dest)
+{
+    pb_byte_t bytes[8];
+
+    if (!pb_read(stream, bytes, 8))
+        return false;
+    
+    *(uint64_t*)dest = ((uint64_t)bytes[0] << 0) |
+                       ((uint64_t)bytes[1] << 8) |
+                       ((uint64_t)bytes[2] << 16) |
+                       ((uint64_t)bytes[3] << 24) |
+                       ((uint64_t)bytes[4] << 32) |
+                       ((uint64_t)bytes[5] << 40) |
+                       ((uint64_t)bytes[6] << 48) |
+                       ((uint64_t)bytes[7] << 56);
+    
+    return true;
+}
+
+static bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    uint64_t value;
+    int64_t svalue;
+    int64_t clamped;
+    if (!pb_decode_varint(stream, &value))
+        return false;
+    
+    /* See issue 97: Google's C++ protobuf allows negative varint values to
+     * be cast as int32_t, instead of the int64_t that should be used when
+     * encoding. Previous nanopb versions had a bug in encoding. In order to
+     * not break decoding of such messages, we cast <=32 bit fields to
+     * int32_t first to get the sign correct.
+     */
+    if (field->data_size == sizeof(int64_t))
+        svalue = (int64_t)value;
+    else
+        svalue = (int32_t)value;
+
+    /* Cast to the proper field size, while checking for overflows */
+    if (field->data_size == sizeof(int64_t))
+        clamped = *(int64_t*)dest = svalue;
+    else if (field->data_size == sizeof(int32_t))
+        clamped = *(int32_t*)dest = (int32_t)svalue;
+    else if (field->data_size == sizeof(int_least16_t))
+        clamped = *(int_least16_t*)dest = (int_least16_t)svalue;
+    else if (field->data_size == sizeof(int_least8_t))
+        clamped = *(int_least8_t*)dest = (int_least8_t)svalue;
+    else
+        PB_RETURN_ERROR(stream, "invalid data_size");
+
+    if (clamped != svalue)
+        PB_RETURN_ERROR(stream, "integer too large");
+    
+    return true;
+}
+
+static bool checkreturn pb_dec_uvarint(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    uint64_t value, clamped;
+    if (!pb_decode_varint(stream, &value))
+        return false;
+    
+    /* Cast to the proper field size, while checking for overflows */
+    if (field->data_size == sizeof(uint64_t))
+        clamped = *(uint64_t*)dest = value;
+    else if (field->data_size == sizeof(uint32_t))
+        clamped = *(uint32_t*)dest = (uint32_t)value;
+    else if (field->data_size == sizeof(uint_least16_t))
+        clamped = *(uint_least16_t*)dest = (uint_least16_t)value;
+    else if (field->data_size == sizeof(uint_least8_t))
+        clamped = *(uint_least8_t*)dest = (uint_least8_t)value;
+    else
+        PB_RETURN_ERROR(stream, "invalid data_size");
+    
+    if (clamped != value)
+        PB_RETURN_ERROR(stream, "integer too large");
+
+    return true;
+}
+
+static bool checkreturn pb_dec_svarint(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    int64_t value, clamped;
+    if (!pb_decode_svarint(stream, &value))
+        return false;
+    
+    /* Cast to the proper field size, while checking for overflows */
+    if (field->data_size == sizeof(int64_t))
+        clamped = *(int64_t*)dest = value;
+    else if (field->data_size == sizeof(int32_t))
+        clamped = *(int32_t*)dest = (int32_t)value;
+    else if (field->data_size == sizeof(int_least16_t))
+        clamped = *(int_least16_t*)dest = (int_least16_t)value;
+    else if (field->data_size == sizeof(int_least8_t))
+        clamped = *(int_least8_t*)dest = (int_least8_t)value;
+    else
+        PB_RETURN_ERROR(stream, "invalid data_size");
+
+    if (clamped != value)
+        PB_RETURN_ERROR(stream, "integer too large");
+    
+    return true;
+}
+
+static bool checkreturn pb_dec_fixed32(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    PB_UNUSED(field);
+    return pb_decode_fixed32(stream, dest);
+}
+
+static bool checkreturn pb_dec_fixed64(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    PB_UNUSED(field);
+    return pb_decode_fixed64(stream, dest);
+}
+
+static bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    uint32_t size;
+    size_t alloc_size;
+    pb_bytes_array_t *bdest;
+    
+    if (!pb_decode_varint32(stream, &size))
+        return false;
+    
+    if (size > PB_SIZE_MAX)
+        PB_RETURN_ERROR(stream, "bytes overflow");
+    
+    alloc_size = PB_BYTES_ARRAY_T_ALLOCSIZE(size);
+    if (size > alloc_size)
+        PB_RETURN_ERROR(stream, "size too large");
+    
+    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
+    {
+#ifndef PB_ENABLE_MALLOC
+        PB_RETURN_ERROR(stream, "no malloc support");
+#else
+        if (!allocate_field(stream, dest, alloc_size, 1))
+            return false;
+        bdest = *(pb_bytes_array_t**)dest;
+#endif
+    }
+    else
+    {
+        if (alloc_size > field->data_size)
+            PB_RETURN_ERROR(stream, "bytes overflow");
+        bdest = (pb_bytes_array_t*)dest;
+    }
+
+    bdest->size = (pb_size_t)size;
+    return pb_read(stream, bdest->bytes, size);
+}
+
+static bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    uint32_t size;
+    size_t alloc_size;
+    bool status;
+    if (!pb_decode_varint32(stream, &size))
+        return false;
+    
+    /* Space for null terminator */
+    alloc_size = size + 1;
+    
+    if (alloc_size < size)
+        PB_RETURN_ERROR(stream, "size too large");
+    
+    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
+    {
+#ifndef PB_ENABLE_MALLOC
+        PB_RETURN_ERROR(stream, "no malloc support");
+#else
+        if (!allocate_field(stream, dest, alloc_size, 1))
+            return false;
+        dest = *(void**)dest;
+#endif
+    }
+    else
+    {
+        if (alloc_size > field->data_size)
+            PB_RETURN_ERROR(stream, "string overflow");
+    }
+    
+    status = pb_read(stream, (pb_byte_t*)dest, size);
+    *((pb_byte_t*)dest + size) = 0;
+    return status;
+}
+
+static bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    bool status;
+    pb_istream_t substream;
+    const pb_field_t* submsg_fields = (const pb_field_t*)field->ptr;
+    
+    if (!pb_make_string_substream(stream, &substream))
+        return false;
+    
+    if (field->ptr == NULL)
+        PB_RETURN_ERROR(stream, "invalid field descriptor");
+    
+    /* New array entries need to be initialized, while required and optional
+     * submessages have already been initialized in the top-level pb_decode. */
+    if (PB_HTYPE(field->type) == PB_HTYPE_REPEATED)
+        status = pb_decode(&substream, submsg_fields, dest);
+    else
+        status = pb_decode_noinit(&substream, submsg_fields, dest);
+    
+    pb_close_string_substream(stream, &substream);
+    return status;
+}
diff --git a/subsys/nrf_dfu/dfu_tran_sect.ld b/subsys/nrf_dfu/dfu_tran_sect.ld
new file mode 100644
index 000000000..cccb00a62
--- /dev/null
+++ b/subsys/nrf_dfu/dfu_tran_sect.ld
@@ -0,0 +1,6 @@
+	SECTION_DATA_PROLOGUE(.dfu_trans,,)
+	{
+		__start_dfu_trans = .;
+		KEEP(*(SORT(.dfu_trans*)));
+		__stop_dfu_trans = .;
+	} GROUP_LINK_IN(ROMABLE_REGION)
diff --git a/subsys/nrf_dfu/inc/app_util.h b/subsys/nrf_dfu/inc/app_util.h
new file mode 100644
index 000000000..b04d0a733
--- /dev/null
+++ b/subsys/nrf_dfu/inc/app_util.h
@@ -0,0 +1,133 @@
+/**
+ * Copyright (c) 2012 - 2019, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/** @file
+ *
+ * @defgroup app_util Utility Functions and Definitions
+ * @{
+ * @ingroup app_common
+ *
+ * @brief Various types and definitions available to all applications.
+ */
+
+#ifndef APP_UTIL_H__
+#define APP_UTIL_H__
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include "compiler_abstraction.h"
+#include <cmsis_gcc.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*Segger embedded studio originally has offsetof macro which cannot be used in macros (like STATIC_ASSERT).
+  This redefinition is to allow using that. */
+#if defined(__SES_ARM) && defined(__GNUC__)
+#undef offsetof
+#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)
+#endif
+
+
+/**@brief Function for encoding a uint16 value.
+ *
+ * @param[in]   value            Value to be encoded.
+ * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
+ *
+ * @return      Number of bytes written.
+ */
+static __INLINE uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
+{
+    p_encoded_data[0] = (uint8_t) ((value & 0x00FF) >> 0);
+    p_encoded_data[1] = (uint8_t) ((value & 0xFF00) >> 8);
+    return sizeof(uint16_t);
+}
+
+/**@brief Function for encoding a uint32 value.
+ *
+ * @param[in]   value            Value to be encoded.
+ * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
+ *
+ * @return      Number of bytes written.
+ */
+static __INLINE uint8_t uint32_encode(uint32_t value, uint8_t * p_encoded_data)
+{
+    p_encoded_data[0] = (uint8_t) ((value & 0x000000FF) >> 0);
+    p_encoded_data[1] = (uint8_t) ((value & 0x0000FF00) >> 8);
+    p_encoded_data[2] = (uint8_t) ((value & 0x00FF0000) >> 16);
+    p_encoded_data[3] = (uint8_t) ((value & 0xFF000000) >> 24);
+    return sizeof(uint32_t);
+}
+
+/**@brief Function for decoding a uint16 value.
+ *
+ * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
+ *
+ * @return      Decoded value.
+ */
+static __INLINE uint16_t uint16_decode(const uint8_t * p_encoded_data)
+{
+        return ( (((uint16_t)((uint8_t *)p_encoded_data)[0])) |
+                 (((uint16_t)((uint8_t *)p_encoded_data)[1]) << 8 ));
+}
+
+
+/**@brief Function for decoding a uint32 value.
+ *
+ * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
+ *
+ * @return      Decoded value.
+ */
+static __INLINE uint32_t uint32_decode(const uint8_t * p_encoded_data)
+{
+    return ( (((uint32_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
+             (((uint32_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
+             (((uint32_t)((uint8_t *)p_encoded_data)[2]) << 16) |
+             (((uint32_t)((uint8_t *)p_encoded_data)[3]) << 24 ));
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // APP_UTIL_H__
+
+/** @} */
diff --git a/subsys/nrf_dfu/inc/common_ids.h b/subsys/nrf_dfu/inc/common_ids.h
new file mode 100644
index 000000000..746b3523a
--- /dev/null
+++ b/subsys/nrf_dfu/inc/common_ids.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2020 Nordic Semiconductor ASA
+ *
+ * SPDX-License-Identifier: LicenseRef-BSD-5-Clause-Nordic
+ */
+
+#ifndef COMMON_IDS_H_
+#define COMMON_IDS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum rpc_command {
+	RPC_CMD_NRF_DFU_REQ_HANDLER_ON_REQ = 1,
+	RPC_CMD_DFU_REQ_HANDLER_CALLBACK = 2,
+	RPC_COMMAND_APP_SEND,
+	RPC_COMMAND_NET_SEND,	
+	RPC_COMMAND_APP_BT_NUS_SEND,
+	RPC_COMMAND_NET_BT_NUS_RECEIVE_CB,
+	RPC_COMMAND_APP_BT_SMP_SEND,
+	RPC_COMMAND_NET_BT_SMP_RECEIVE_CB,
+	RPC_COMMAND_APP_BT_SMP_GET_MTU 	
+};
+
+enum rpc_api_type {
+	NET2APP_BT_ADDR_SEND = 0x01,
+	APP2NET_BT_NUS_SEND,
+	APP2NET_BT_SMP_SEND,
+	NET2APP_BT_NUS_RECV,
+	NET2APP_BT_CONN_STATUS
+/*  RPC_COMMAND_NET_BT_MTU_SIZE_CB = 0x05, */
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* COMMON_IDS_H_ */
diff --git a/subsys/nrf_dfu/inc/crc32.h b/subsys/nrf_dfu/inc/crc32.h
new file mode 100644
index 000000000..92b2f0c89
--- /dev/null
+++ b/subsys/nrf_dfu/inc/crc32.h
@@ -0,0 +1,79 @@
+/**
+ * Copyright (c) 2015 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/** @file
+ *
+ * @defgroup crc32 CRC32 compute
+ * @{
+ * @ingroup hci_transport
+ *
+ * @brief    This module implements the CRC-32 calculation in the blocks.
+ */
+
+#ifndef CRC32_H__
+#define CRC32_H__
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**@brief Function for calculating CRC-32 in blocks.
+ *
+ * Feed each consecutive data block into this function, along with the current value of p_crc as
+ * returned by the previous call of this function. The first call of this function should pass NULL
+ * as the initial value of the crc in p_crc.
+ *
+ * @param[in] p_data The input data block for computation.
+ * @param[in] size   The size of the input data block in bytes.
+ * @param[in] p_crc  The previous calculated CRC-32 value or NULL if first call.
+ *
+ * @return The updated CRC-32 value, based on the input supplied.
+ */
+uint32_t crc32_compute(uint8_t const * p_data, uint32_t size, uint32_t const * p_crc);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // CRC32_H__
+
+/** @} */
diff --git a/subsys/nrf_dfu/inc/dfu-cc.pb.h b/subsys/nrf_dfu/inc/dfu-cc.pb.h
new file mode 100644
index 000000000..b23dc1a27
--- /dev/null
+++ b/subsys/nrf_dfu/inc/dfu-cc.pb.h
@@ -0,0 +1,241 @@
+/**
+ * Copyright (c) 2017 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/* Automatically generated nanopb header */
+/* Generated by nanopb-0.3.6-dev at Tue Sep 11 14:37:18 2018. */
+
+#ifndef PB_DFU_CC_PB_H_INCLUDED
+#define PB_DFU_CC_PB_H_INCLUDED
+#include <pb.h>
+
+/* @@protoc_insertion_point(includes) */
+#if PB_PROTO_HEADER_VERSION != 30
+#error Regenerate this file with the current version of nanopb generator.
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Enum definitions */
+typedef enum
+{
+    DFU_FW_TYPE_APPLICATION = 0,
+    DFU_FW_TYPE_SOFTDEVICE = 1,
+    DFU_FW_TYPE_BOOTLOADER = 2,
+    DFU_FW_TYPE_SOFTDEVICE_BOOTLOADER = 3,
+    DFU_FW_TYPE_EXTERNAL_APPLICATION = 4
+} dfu_fw_type_t;
+#define DFU_FW_TYPE_MIN DFU_FW_TYPE_APPLICATION
+#define DFU_FW_TYPE_MAX DFU_FW_TYPE_EXTERNAL_APPLICATION
+#define DFU_FW_TYPE_ARRAYSIZE ((dfu_fw_type_t)(DFU_FW_TYPE_EXTERNAL_APPLICATION+1))
+
+typedef enum
+{
+    DFU_HASH_TYPE_NO_HASH = 0,
+    DFU_HASH_TYPE_CRC = 1,
+    DFU_HASH_TYPE_SHA128 = 2,
+    DFU_HASH_TYPE_SHA256 = 3,
+    DFU_HASH_TYPE_SHA512 = 4
+} dfu_hash_type_t;
+#define DFU_HASH_TYPE_MIN DFU_HASH_TYPE_NO_HASH
+#define DFU_HASH_TYPE_MAX DFU_HASH_TYPE_SHA512
+#define DFU_HASH_TYPE_ARRAYSIZE ((dfu_hash_type_t)(DFU_HASH_TYPE_SHA512+1))
+
+typedef enum
+{
+    DFU_OP_CODE_INIT = 1
+} dfu_op_code_t;
+#define DFU_OP_CODE_MIN DFU_OP_CODE_INIT
+#define DFU_OP_CODE_MAX DFU_OP_CODE_INIT
+#define DFU_OP_CODE_ARRAYSIZE ((dfu_op_code_t)(DFU_OP_CODE_INIT+1))
+
+typedef enum
+{
+    DFU_VALIDATION_TYPE_NO_VALIDATION = 0,
+    DFU_VALIDATION_TYPE_VALIDATE_GENERATED_CRC = 1,
+    DFU_VALIDATION_TYPE_VALIDATE_SHA256 = 2,
+    DFU_VALIDATION_TYPE_VALIDATE_ECDSA_P256_SHA256 = 3
+} dfu_validation_type_t;
+#define DFU_VALIDATION_TYPE_MIN DFU_VALIDATION_TYPE_NO_VALIDATION
+#define DFU_VALIDATION_TYPE_MAX DFU_VALIDATION_TYPE_VALIDATE_ECDSA_P256_SHA256
+#define DFU_VALIDATION_TYPE_ARRAYSIZE ((dfu_validation_type_t)(DFU_VALIDATION_TYPE_VALIDATE_ECDSA_P256_SHA256+1))
+
+typedef enum
+{
+    DFU_SIGNATURE_TYPE_ECDSA_P256_SHA256 = 0,
+    DFU_SIGNATURE_TYPE_ED25519 = 1
+} dfu_signature_type_t;
+#define DFU_SIGNATURE_TYPE_MIN DFU_SIGNATURE_TYPE_ECDSA_P256_SHA256
+#define DFU_SIGNATURE_TYPE_MAX DFU_SIGNATURE_TYPE_ED25519
+#define DFU_SIGNATURE_TYPE_ARRAYSIZE ((dfu_signature_type_t)(DFU_SIGNATURE_TYPE_ED25519+1))
+
+/* Struct definitions */
+typedef PB_BYTES_ARRAY_T(64) dfu_boot_validation_bytes_t;
+typedef struct {
+    dfu_validation_type_t type;
+    dfu_boot_validation_bytes_t bytes;
+/* @@protoc_insertion_point(struct:dfu_boot_validation_t) */
+} dfu_boot_validation_t;
+
+typedef PB_BYTES_ARRAY_T(32) dfu_hash_hash_t;
+typedef struct {
+    dfu_hash_type_t hash_type;
+    dfu_hash_hash_t hash;
+/* @@protoc_insertion_point(struct:dfu_hash_t) */
+} dfu_hash_t;
+
+typedef struct {
+    bool has_fw_version;
+    uint32_t fw_version;
+    bool has_hw_version;
+    uint32_t hw_version;
+    pb_size_t sd_req_count;
+    uint32_t sd_req[16];
+    bool has_type;
+    dfu_fw_type_t type;
+    bool has_sd_size;
+    uint32_t sd_size;
+    bool has_bl_size;
+    uint32_t bl_size;
+    bool has_app_size;
+    uint32_t app_size;
+    bool has_hash;
+    dfu_hash_t hash;
+    bool has_is_debug;
+    bool is_debug;
+    pb_size_t boot_validation_count;
+    dfu_boot_validation_t boot_validation[3];
+/* @@protoc_insertion_point(struct:dfu_init_command_t) */
+} dfu_init_command_t;
+
+typedef struct {
+    bool has_op_code;
+    dfu_op_code_t op_code;
+    bool has_init;
+    dfu_init_command_t init;
+/* @@protoc_insertion_point(struct:dfu_command_t) */
+} dfu_command_t;
+
+typedef PB_BYTES_ARRAY_T(64) dfu_signed_command_signature_t;
+typedef struct {
+    dfu_command_t command;
+    dfu_signature_type_t signature_type;
+    dfu_signed_command_signature_t signature;
+/* @@protoc_insertion_point(struct:dfu_signed_command_t) */
+} dfu_signed_command_t;
+
+typedef struct {
+    bool has_command;
+    dfu_command_t command;
+    bool has_signed_command;
+    dfu_signed_command_t signed_command;
+/* @@protoc_insertion_point(struct:dfu_packet_t) */
+} dfu_packet_t;
+
+/* Default values for struct fields */
+extern const bool dfu_init_command_is_debug_default;
+
+/* Initializer values for message structs */
+#define DFU_HASH_INIT_DEFAULT                    {(dfu_hash_type_t)0, {0, {0}}}
+#define DFU_BOOT_VALIDATION_INIT_DEFAULT         {(dfu_validation_type_t)0, {0, {0}}}
+#define DFU_INIT_COMMAND_INIT_DEFAULT            {false, 0, false, 0, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, false, (dfu_fw_type_t)0, false, 0, false, 0, false, 0, false, DFU_HASH_INIT_DEFAULT, false, false, 0, {DFU_BOOT_VALIDATION_INIT_DEFAULT, DFU_BOOT_VALIDATION_INIT_DEFAULT, DFU_BOOT_VALIDATION_INIT_DEFAULT}}
+#define DFU_COMMAND_INIT_DEFAULT                 {false, (dfu_op_code_t)0, false, DFU_INIT_COMMAND_INIT_DEFAULT}
+#define DFU_SIGNED_COMMAND_INIT_DEFAULT          {DFU_COMMAND_INIT_DEFAULT, (dfu_signature_type_t)0, {0, {0}}}
+#define DFU_PACKET_INIT_DEFAULT                  {false, DFU_COMMAND_INIT_DEFAULT, false, DFU_SIGNED_COMMAND_INIT_DEFAULT}
+#define DFU_HASH_INIT_ZERO                       {(dfu_hash_type_t)0, {0, {0}}}
+#define DFU_BOOT_VALIDATION_INIT_ZERO            {(dfu_validation_type_t)0, {0, {0}}}
+#define DFU_INIT_COMMAND_INIT_ZERO               {false, 0, false, 0, 0, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, false, (dfu_fw_type_t)0, false, 0, false, 0, false, 0, false, DFU_HASH_INIT_ZERO, false, 0, 0, {DFU_BOOT_VALIDATION_INIT_ZERO, DFU_BOOT_VALIDATION_INIT_ZERO, DFU_BOOT_VALIDATION_INIT_ZERO}}
+#define DFU_COMMAND_INIT_ZERO                    {false, (dfu_op_code_t)0, false, DFU_INIT_COMMAND_INIT_ZERO}
+#define DFU_SIGNED_COMMAND_INIT_ZERO             {DFU_COMMAND_INIT_ZERO, (dfu_signature_type_t)0, {0, {0}}}
+#define DFU_PACKET_INIT_ZERO                     {false, DFU_COMMAND_INIT_ZERO, false, DFU_SIGNED_COMMAND_INIT_ZERO}
+
+/* Field tags (for use in manual encoding/decoding) */
+#define DFU_BOOT_VALIDATION_TYPE_TAG             1
+#define DFU_BOOT_VALIDATION_BYTES_TAG            2
+#define DFU_HASH_HASH_TYPE_TAG                   1
+#define DFU_HASH_HASH_TAG                        2
+#define DFU_INIT_COMMAND_FW_VERSION_TAG          1
+#define DFU_INIT_COMMAND_HW_VERSION_TAG          2
+#define DFU_INIT_COMMAND_SD_REQ_TAG              3
+#define DFU_INIT_COMMAND_TYPE_TAG                4
+#define DFU_INIT_COMMAND_SD_SIZE_TAG             5
+#define DFU_INIT_COMMAND_BL_SIZE_TAG             6
+#define DFU_INIT_COMMAND_APP_SIZE_TAG            7
+#define DFU_INIT_COMMAND_HASH_TAG                8
+#define DFU_INIT_COMMAND_IS_DEBUG_TAG            9
+#define DFU_INIT_COMMAND_BOOT_VALIDATION_TAG     10
+#define DFU_COMMAND_OP_CODE_TAG                  1
+#define DFU_COMMAND_INIT_TAG                     2
+#define DFU_SIGNED_COMMAND_COMMAND_TAG           1
+#define DFU_SIGNED_COMMAND_SIGNATURE_TYPE_TAG    2
+#define DFU_SIGNED_COMMAND_SIGNATURE_TAG         3
+#define DFU_PACKET_COMMAND_TAG                   1
+#define DFU_PACKET_SIGNED_COMMAND_TAG            2
+
+/* Struct field encoding specification for nanopb */
+extern const pb_field_t dfu_hash_fields[3];
+extern const pb_field_t dfu_boot_validation_fields[3];
+extern const pb_field_t dfu_init_command_fields[11];
+extern const pb_field_t dfu_command_fields[3];
+extern const pb_field_t dfu_signed_command_fields[4];
+extern const pb_field_t dfu_packet_fields[3];
+
+/* Maximum encoded size of messages (where known) */
+#define DFU_HASH_SIZE                            36
+#define DFU_BOOT_VALIDATION_SIZE                 68
+#define DFU_INIT_COMMAND_SIZE                    378
+#define DFU_COMMAND_SIZE                         383
+#define DFU_SIGNED_COMMAND_SIZE                  454
+#define DFU_PACKET_SIZE                          843
+
+/* Message IDs (where set with "msgid" option) */
+#ifdef PB_MSGID
+
+#define DFU_CC_MESSAGES \
+
+
+#endif
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+/* @@protoc_insertion_point(eof) */
+
+#endif
diff --git a/subsys/nrf_dfu/inc/nordic_common.h b/subsys/nrf_dfu/inc/nordic_common.h
new file mode 100644
index 000000000..c66b452ef
--- /dev/null
+++ b/subsys/nrf_dfu/inc/nordic_common.h
@@ -0,0 +1,77 @@
+/**
+ * Copyright (c) 2008 - 2019, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/** @file
+ * @brief Common defines and macros for firmware developed by Nordic Semiconductor.
+ */
+
+#ifndef NORDIC_COMMON_H__
+#define NORDIC_COMMON_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**@brief Concatenates two parameters.
+ *
+ * It realizes two level expansion to make it sure that all the parameters
+ * are actually expanded before gluing them together.
+ *
+ * @param p1 First parameter to concatenating
+ * @param p2 Second parameter to concatenating
+ *
+ * @return Two parameters glued together.
+ *         They have to create correct C mnemonic in other case
+ *         preprocessor error would be generated.
+ *
+ * @sa CONCAT_3
+ */
+#define CONCAT_2(p1, p2)      CONCAT_2_(p1, p2)
+/** Auxiliary macro used by @ref CONCAT_2 */
+#define CONCAT_2_(p1, p2)     p1##p2
+
+#define UNUSED_VARIABLE(X)  ((void)(X))
+#define UNUSED_PARAMETER(X) UNUSED_VARIABLE(X)
+#define UNUSED_RETURN_VALUE(X) UNUSED_VARIABLE(X)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // NORDIC_COMMON_H__
diff --git a/subsys/nrf_dfu/inc/nrf_dfu.h b/subsys/nrf_dfu/inc/nrf_dfu.h
new file mode 100644
index 000000000..35b6701dd
--- /dev/null
+++ b/subsys/nrf_dfu/inc/nrf_dfu.h
@@ -0,0 +1,85 @@
+/**
+ * Copyright (c) 2016 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/**@file
+ *
+ * @defgroup nrf_dfu DFU modules
+ * @{
+ * @ingroup  nrf_bootloader
+ * @brief Modules providing Device Firmware Update (DFU) functionality.
+ *
+ * The DFU module, in combination with the @ref nrf_bootloader module,
+ * can be used to implement a bootloader that supports Device Firmware Updates.
+ */
+
+#ifndef NRF_DFU_H__
+#define NRF_DFU_H__
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "nrf_dfu_types.h"
+#include "nrf_dfu_req_handler.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define NRF_DFU_SCHED_EVENT_DATA_SIZE (sizeof(nrf_dfu_request_t))
+
+
+/** @brief Function for initializing a DFU operation.
+ *
+ * This function initializes a DFU operation and any transports that are registered
+ * in the system.
+ *
+ * @param[in] observer  Callback function for receiving DFU notifications.
+ *
+ * @retval  NRF_SUCCESS     If the DFU operation was successfully initialized.
+ */
+uint32_t nrf_dfu_init(nrf_dfu_observer_t observer);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // NRF_DFU_H__
+
+/** @} */
diff --git a/subsys/nrf_dfu/inc/nrf_dfu_flash.h b/subsys/nrf_dfu/inc/nrf_dfu_flash.h
new file mode 100644
index 000000000..730dc062e
--- /dev/null
+++ b/subsys/nrf_dfu/inc/nrf_dfu_flash.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2020 Nordic Semiconductor ASA
+ *
+ * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
+ */
+
+#ifndef _NRF_DFU_FLASH_H_
+#define _NRF_DFU_FLASH_H_
+
+#include <zephyr/types.h>
+
+bool dfu_lock(const void *module_id);
+void dfu_unlock(const void *module_id);
+void dfu_flash_cmd_handler(const uint8_t opt_id, const uint8_t *data,
+			  const size_t size);
+int dfu_data_store(int off, const void *src, size_t len, bool flush);
+int dfu_page_erase(int off, size_t len);
+int dfu_flash_start(uint32_t image_start, uint32_t image_len);
+void dfu_flash_finish(void);
+
+#endif /* _NRF_DFU_FLASH_H_ */
diff --git a/subsys/nrf_dfu/inc/nrf_dfu_handling_error.h b/subsys/nrf_dfu/inc/nrf_dfu_handling_error.h
new file mode 100644
index 000000000..3b7c62fef
--- /dev/null
+++ b/subsys/nrf_dfu/inc/nrf_dfu_handling_error.h
@@ -0,0 +1,125 @@
+/**
+ * Copyright (c) 2017 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+ /**@file
+ *
+ * @defgroup nrf_dfu_rescodes DFU result codes
+ * @{
+ * @ingroup  sdk_nrf_dfu_transport
+ * @brief When the DFU controller sends requests to the DFU bootloader on
+ * the DFU target, the DFU bootloader answers with any of these result codes.
+ */
+
+
+#ifndef DFU_HANDLING_ERROR_H__
+#define DFU_HANDLING_ERROR_H__
+
+#include "nrf_dfu_types.h"
+#include "nrf_dfu_req_handler.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+/**@brief DFU request extended result codes.
+ *
+ * @details When an event returns @ref NRF_DFU_RES_CODE_EXT_ERROR, it also stores an extended error code.
+ *          The transport layer can then send the extended error code together with the error code to give
+ *          the controller additional information about the cause of the error.
+ */
+typedef enum
+{
+    NRF_DFU_EXT_ERROR_NO_ERROR                  = 0x00, /**< No extended error code has been set. This error indicates an implementation problem. */
+    NRF_DFU_EXT_ERROR_INVALID_ERROR_CODE        = 0x01, /**< Invalid error code. This error code should never be used outside of development. */
+    NRF_DFU_EXT_ERROR_WRONG_COMMAND_FORMAT      = 0x02, /**< The format of the command was incorrect. This error code is not used in the
+                                                             current implementation, because @ref NRF_DFU_RES_CODE_OP_CODE_NOT_SUPPORTED
+                                                             and @ref NRF_DFU_RES_CODE_INVALID_PARAMETER cover all
+                                                             possible format errors. */
+    NRF_DFU_EXT_ERROR_UNKNOWN_COMMAND           = 0x03, /**< The command was successfully parsed, but it is not supported or unknown. */
+    NRF_DFU_EXT_ERROR_INIT_COMMAND_INVALID      = 0x04, /**< The init command is invalid. The init packet either has
+                                                             an invalid update type or it is missing required fields for the update type
+                                                             (for example, the init packet for a SoftDevice update is missing the SoftDevice size field). */
+    NRF_DFU_EXT_ERROR_FW_VERSION_FAILURE        = 0x05, /**< The firmware version is too low. For an application or SoftDevice, the version must be greater than
+                                                             or equal to the current version. For a bootloader, it must be greater than the current version.
+                                                             to the current version. This requirement prevents downgrade attacks.*/
+    NRF_DFU_EXT_ERROR_HW_VERSION_FAILURE        = 0x06, /**< The hardware version of the device does not match the required
+                                                             hardware version for the update. */
+    NRF_DFU_EXT_ERROR_SD_VERSION_FAILURE        = 0x07, /**< The array of supported SoftDevices for the update does not contain
+                                                             the FWID of the current SoftDevice or the first FWID is '0' on a
+                                                             bootloader which requires the SoftDevice to be present. */
+    NRF_DFU_EXT_ERROR_SIGNATURE_MISSING         = 0x08, /**< The init packet does not contain a signature. This error code is not used in the
+                                                             current implementation, because init packets without a signature
+                                                             are regarded as invalid. */
+    NRF_DFU_EXT_ERROR_WRONG_HASH_TYPE           = 0x09, /**< The hash type that is specified by the init packet is not supported by the DFU bootloader. */
+    NRF_DFU_EXT_ERROR_HASH_FAILED               = 0x0A, /**< The hash of the firmware image cannot be calculated. */
+    NRF_DFU_EXT_ERROR_WRONG_SIGNATURE_TYPE      = 0x0B, /**< The type of the signature is unknown or not supported by the DFU bootloader. */
+    NRF_DFU_EXT_ERROR_VERIFICATION_FAILED       = 0x0C, /**< The hash of the received firmware image does not match the hash in the init packet. */
+    NRF_DFU_EXT_ERROR_INSUFFICIENT_SPACE        = 0x0D, /**< The available space on the device is insufficient to hold the firmware. */
+} nrf_dfu_ext_error_code_t;
+
+
+/**@brief Function for setting an extended error code that can be retrieved later.
+ *
+ * @details When an extended error occurs in the DFU process, this function can be used to store the error.
+ *
+ * @param error_code The error code to store.
+ *
+ * @retval NRF_DFU_RES_CODE_EXT_ERROR
+ */
+nrf_dfu_result_t ext_error_set(nrf_dfu_ext_error_code_t error_code);
+
+/**@brief Function for getting the most recent extended error code.
+ *
+ * @details This function is used by the transport layer to fetch the most recent extended error code.
+ *
+ * @return The most recent error code. If the function is called again before a new error occurs, @ref NRF_DFU_EXT_ERROR_NO_ERROR is returned.
+ */
+nrf_dfu_ext_error_code_t ext_error_get( void );
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // DFU_HANDLING_ERROR_H__
+
+/** @} */
diff --git a/subsys/nrf_dfu/inc/nrf_dfu_req_handler.h b/subsys/nrf_dfu/inc/nrf_dfu_req_handler.h
new file mode 100644
index 000000000..d01fe6182
--- /dev/null
+++ b/subsys/nrf_dfu/inc/nrf_dfu_req_handler.h
@@ -0,0 +1,344 @@
+/**
+ * Copyright (c) 2016 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/**@file
+ *
+ * @defgroup sdk_nrf_dfu_req_handler Request handling
+ * @{
+ * @ingroup  nrf_dfu
+ */
+
+#ifndef NRF_DFU_REQ_HANDLER_H__
+#define NRF_DFU_REQ_HANDLER_H__
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "nrf_dfu_types.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+//ANON_UNIONS_ENABLE;
+
+/**
+ * @brief DFU object types.
+ */
+typedef enum
+{
+    NRF_DFU_OBJ_TYPE_INVALID,                   //!< Invalid object type.
+    NRF_DFU_OBJ_TYPE_COMMAND,                   //!< Command object.
+    NRF_DFU_OBJ_TYPE_DATA,                      //!< Data object.
+} nrf_dfu_obj_type_t;
+
+/**
+ * @brief DFU protocol operation.
+ */
+typedef enum
+{
+    NRF_DFU_OP_PROTOCOL_VERSION     = 0x00,     //!< Retrieve protocol version.
+    NRF_DFU_OP_OBJECT_CREATE        = 0x01,     //!< Create selected object.
+    NRF_DFU_OP_RECEIPT_NOTIF_SET    = 0x02,     //!< Set receipt notification.
+    NRF_DFU_OP_CRC_GET              = 0x03,     //!< Request CRC of selected object.
+    NRF_DFU_OP_OBJECT_EXECUTE       = 0x04,     //!< Execute selected object.
+    NRF_DFU_OP_OBJECT_SELECT        = 0x06,     //!< Select object.
+    NRF_DFU_OP_MTU_GET              = 0x07,     //!< Retrieve MTU size.
+    NRF_DFU_OP_OBJECT_WRITE         = 0x08,     //!< Write selected object.
+    NRF_DFU_OP_PING                 = 0x09,     //!< Ping.
+    NRF_DFU_OP_HARDWARE_VERSION     = 0x0A,     //!< Retrieve hardware version.
+    NRF_DFU_OP_FIRMWARE_VERSION     = 0x0B,     //!< Retrieve firmware version.
+    NRF_DFU_OP_ABORT                = 0x0C,     //!< Abort the DFU procedure.
+    NRF_DFU_OP_RESPONSE             = 0x60,     //!< Response.
+    NRF_DFU_OP_INVALID              = 0xFF,
+} nrf_dfu_op_t;
+
+/**
+ * @brief DFU operation result code.
+ */
+typedef enum
+{
+    NRF_DFU_RES_CODE_INVALID                 = 0x00,    //!< Invalid opcode.
+    NRF_DFU_RES_CODE_SUCCESS                 = 0x01,    //!< Operation successful.
+    NRF_DFU_RES_CODE_OP_CODE_NOT_SUPPORTED   = 0x02,    //!< Opcode not supported.
+    NRF_DFU_RES_CODE_INVALID_PARAMETER       = 0x03,    //!< Missing or invalid parameter value.
+    NRF_DFU_RES_CODE_INSUFFICIENT_RESOURCES  = 0x04,    //!< Not enough memory for the data object.
+    NRF_DFU_RES_CODE_INVALID_OBJECT          = 0x05,    //!< Data object does not match the firmware and hardware requirements, the signature is wrong, or parsing the command failed.
+    NRF_DFU_RES_CODE_UNSUPPORTED_TYPE        = 0x07,    //!< Not a valid object type for a Create request.
+    NRF_DFU_RES_CODE_OPERATION_NOT_PERMITTED = 0x08,    //!< The state of the DFU process does not allow this operation.
+    NRF_DFU_RES_CODE_OPERATION_FAILED        = 0x0A,    //!< Operation failed.
+    NRF_DFU_RES_CODE_EXT_ERROR               = 0x0B,    //!< Extended error. The next byte of the response contains the error code of the extended error (see @ref nrf_dfu_ext_error_code_t.
+} nrf_dfu_result_t;
+
+typedef enum
+{
+    NRF_DFU_FIRMWARE_TYPE_SOFTDEVICE    = 0x00,
+    NRF_DFU_FIRMWARE_TYPE_APPLICATION   = 0x01,
+    NRF_DFU_FIRMWARE_TYPE_BOOTLOADER    = 0x02,
+    NRF_DFU_FIRMWARE_TYPE_UNKNOWN       = 0xFF,
+} nrf_dfu_firmware_type_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_PROTOCOL_VERSION response details.
+ */
+typedef struct
+{
+    uint8_t version;                    //!< Protocol version.
+} nrf_dfu_response_protocol_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_HARDWARE_VERSION response details.
+ */
+typedef struct
+{
+    uint32_t part;                      //!< Hardware part, from FICR register.
+    uint32_t variant;                   //!< Hardware variant, from FICR register.
+    struct
+    {
+        uint32_t rom_size;              //!< ROM size, in bytes.
+        uint32_t ram_size;              //!< RAM size, in bytes.
+        uint32_t rom_page_size;         //!< ROM flash page size, in bytes.
+    } memory;
+} nrf_dfu_response_hardware_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_FIRMWARE_VERSION response details.
+ */
+typedef struct
+{
+    nrf_dfu_firmware_type_t type;       //!< Firmware type.
+    uint32_t                version;    //!< Firmware version.
+    uint32_t                addr;       //!< Firmware address in flash.
+    uint32_t                len;        //!< Firmware length in bytes.
+} nrf_dfu_response_firmware_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_OBJECT_SELECT response details.
+ */
+typedef struct
+{
+    uint32_t offset;                    //!< Current offset.
+    uint32_t crc;                       //!< Current CRC.
+    uint32_t max_size;                  //!< Maximum size of selected object.
+} nrf_dfu_response_select_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_OBJECT_CREATE response details.
+ */
+typedef struct
+{
+    uint32_t offset;                    //!< Current offset
+    uint32_t crc;                       //!< Current CRC.
+} nrf_dfu_response_create_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_OBJECT_WRITE response details.
+ */
+typedef struct
+{
+    uint32_t offset;                    //!< Used only when packet receipt notification is used.
+    uint32_t crc;                       //!< Used only when packet receipt notification is used.
+} nrf_dfu_response_write_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_CRC_GET response details.
+ */
+typedef struct
+{
+    uint32_t offset;                    //!< Current offset.
+    uint32_t crc;                       //!< Current CRC.
+} nrf_dfu_response_crc_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_PING response details.
+ */
+typedef struct
+{
+    uint8_t id;                         //!< The received ID which is echoed back.
+} nrf_dfu_response_ping_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_MTU_GET response details.
+ */
+typedef struct
+{
+    uint16_t size;                      //!< The MTU size as specified by the local transport.
+} nrf_dfu_response_mtu_t;
+
+/**
+ * @brief DFU response message.
+ */
+typedef struct
+{
+    nrf_dfu_op_t     request;                      //!< Requested operation.
+    nrf_dfu_result_t result;                       //!< Result of the operation.
+    union
+    {
+        nrf_dfu_response_protocol_t protocol;      //!< Protocol version response.
+        nrf_dfu_response_hardware_t hardware;      //!< Hardware version response.
+        nrf_dfu_response_firmware_t firmware;      //!< Firmware version response.
+        nrf_dfu_response_select_t   select;        //!< Select object response..
+        nrf_dfu_response_create_t   create;        //!< Create object response..
+        nrf_dfu_response_write_t    write;         //!< Write object response.
+        nrf_dfu_response_crc_t      crc;           //!< CRC response.
+        nrf_dfu_response_ping_t     ping;          //!< Ping response.
+        nrf_dfu_response_mtu_t      mtu;           //!< MTU response.
+    };
+} nrf_dfu_response_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_FIRMWARE_VERSION request details.
+ */
+typedef struct
+{
+    uint8_t image_number;  //!< Index of the firmware.
+} nrf_dfu_request_firmware_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_OBJECT_SELECT request details.
+ */
+typedef struct
+{
+    uint32_t object_type;  //!< Object type. See @ref nrf_dfu_obj_type_t.
+} nrf_dfu_request_select_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_OBJECT_CREATE request details.
+ */
+typedef struct
+{
+    uint32_t object_type;  //!< Object type. See @ref nrf_dfu_obj_type_t.
+    uint32_t object_size;  //!< Object size in bytes.
+} nrf_dfu_request_create_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_OBJECT_WRITE request details.
+ */
+typedef struct
+{
+    uint8_t    * p_data; //!< Data.
+    uint16_t         len;    //!< Length of data in @ref nrf_dfu_request_write_t::p_data.
+} nrf_dfu_request_write_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_PING request details.
+ */
+typedef struct
+{
+    uint8_t id;             //!< Ping ID that will be returned in response.
+} nrf_dfu_request_ping_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_MTU_GET request details.
+ */
+typedef struct
+{
+    uint16_t size;          //!< Transport MTU size in bytes.
+} nrf_dfu_request_mtu_t;
+
+/**
+ * @brief @ref NRF_DFU_OP_RECEIPT_NOTIF_SET request details.
+ */
+typedef struct
+{
+    uint32_t target;        //!< Target PRN.
+} nrf_dfu_request_prn_t;
+
+
+typedef void (*nrf_dfu_response_callback_t)(nrf_dfu_response_t * p_res, void * p_context);
+
+/**
+ *@brief DFU request.
+ */
+typedef struct
+{
+    nrf_dfu_op_t   request;     //!< Requested operation.
+    void         * p_context;
+    struct
+    {
+        nrf_dfu_response_callback_t response; //!< Callback to call to send the response.
+        nrf_dfu_flash_callback_t    write;
+    } callback;
+    union
+    {
+        nrf_dfu_request_firmware_t firmware;    //!< Firmware version request.
+        nrf_dfu_request_select_t   select;      //!< Select object request.
+        nrf_dfu_request_create_t   create;      //!< Create object request.
+        nrf_dfu_request_write_t    write;       //!< Write object request.
+        nrf_dfu_request_ping_t     ping;        //!< Ping.
+        nrf_dfu_request_mtu_t      mtu;         //!< MTU size request.
+        nrf_dfu_request_prn_t      prn;         //!< Set receipt notification request.
+    };
+} nrf_dfu_request_t;
+
+
+/**@brief  Function for initializing the request handling module.
+ *
+ * @param observer  Callback function for receiving notifications.
+ *
+ * @retval NRF_SUCCESS             If the operation was successful.
+ * @retval NRF_ERROR_INTERNAL      If the init packet in flash is not valid.
+ * @retval NRF_ERROR_INVALID_PARAM If observer is not provided.
+ */
+ret_code_t nrf_dfu_req_handler_init(nrf_dfu_observer_t observer);
+
+
+/**@brief  Function for scheduling processing of a DFU request.
+ *
+ * Requests are processed asynchronously by the scheduler.
+ *
+ * @param[in] p_req  Request to be handled. The response callback must be non-null.
+ *
+ * @retval NRF_SUCCESS              If the command request was executed successfully.
+ * @retval NRF_ERROR_NO_MEM         If the scheduler ran out of memory.
+ * @retval NRF_ERROR_INVALID_PARAM  If the response callback is NULL.
+ */
+ret_code_t nrf_dfu_req_handler_on_req(nrf_dfu_request_t * p_req);
+
+void ble_dfu_req_handler_callback(nrf_dfu_response_t * p_res, void * p_context);
+
+//ANON_UNIONS_DISABLE;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // NRF_DFU_REQ_HANDLER_H__
+
+/** @} */
diff --git a/subsys/nrf_dfu/inc/nrf_dfu_settings.h b/subsys/nrf_dfu/inc/nrf_dfu_settings.h
new file mode 100644
index 000000000..422e91782
--- /dev/null
+++ b/subsys/nrf_dfu/inc/nrf_dfu_settings.h
@@ -0,0 +1,144 @@
+/**
+ * Copyright (c) 2016 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/**@file
+ *
+ * @defgroup nrf_dfu_settings DFU settings
+ * @{
+ * @ingroup  nrf_dfu
+ */
+
+#ifndef NRF_DFU_SETTINGS_H__
+#define NRF_DFU_SETTINGS_H__
+
+#include <stdint.h>
+#include "nrf_dfu_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void (*nrf_dfu_flash_callback_t)(void * p_buf);
+
+/**@brief   Global settings.
+ *
+ * @note Using this variable is not thread-safe.
+ *
+ */
+extern nrf_dfu_settings_t s_dfu_settings;
+
+
+/**@brief   Function for writing DFU settings to flash.
+ *
+ * @param[in]   callback    Pointer to a function that is called after completing the write operation.
+ *
+ * @retval  NRF_SUCCESS         If the write process was successfully initiated.
+ * @retval  NRF_ERROR_INTERNAL  If a flash error occurred.
+ */
+ret_code_t nrf_dfu_settings_write(nrf_dfu_flash_callback_t callback);
+
+
+/**@brief   Function for backing up the settings.
+ *
+ * This function copies the contents of the settings page (in flash) to a separate page (in flash).
+ * During @ref nrf_dfu_settings_init, the backup is restored if the original is invalid.
+ *
+ * @param[in]   callback    Pointer to a function that is called after completing the write operation.
+ */
+void nrf_dfu_settings_backup(nrf_dfu_flash_callback_t callback);
+
+
+/**@brief   Function for writing DFU settings to flash and to backup.
+ *
+ * This function first calls @ref nrf_dfu_settings_write and then @ref nrf_dfu_settings_backup.
+ *
+ * @param[in]   callback    Pointer to a function that is called after completing the write and backup operation.
+ *
+ * @retval  NRF_SUCCESS         If the write process was successfully initiated.
+ * @retval  NRF_ERROR_INTERNAL  If a flash error occurred during the first write.
+ */
+ret_code_t nrf_dfu_settings_write_and_backup(nrf_dfu_flash_callback_t callback);
+
+
+/**@brief   Function for initializing the DFU settings structure.
+ *
+ * Initializes the RAM structure from the flash contents.
+ * This function is called as part of @ref nrf_dfu_settings_init.
+ *
+ * @retval  NRF_SUCCESS         If the initialization was successful.
+ * @retval  NRF_ERROR_INTERNAL  If a flash error occurred.
+ */
+void nrf_dfu_settings_reinit(void);
+
+
+/**@brief   Function for initializing the DFU settings module.
+ *
+ * @retval  NRF_SUCCESS         If the initialization was successful.
+ * @retval  NRF_ERROR_INTERNAL  If a flash error occurred.
+ */
+ret_code_t nrf_dfu_settings_init(bool sd_irq_initialized);
+
+/** @brief Function for erasing additional data in DFU settings.
+ *
+ * @note    Erasing additional data in DFU settings is only possible
+ *          if nrf_dfu_flash is initialized to not use SoftDevice calls.
+ *
+ * @retval  NRF_SUCCESS     Additional data was successfully erased.
+ * @retval  Any other error code reported by nrf_dfu_flash
+ */
+ret_code_t nrf_dfu_settings_additional_erase(void);
+
+/** @brief Function for resetting both init command and DFU transfer progress inside settings structure.
+ *
+ * @note    This function does not perform flash operation.
+ *          In order to save the reset state, please use @ref nrf_dfu_settings_write function.
+ */
+void nrf_dfu_settings_progress_reset(void);
+
+uint32_t nrf_dfu_bank1_start_addr(void);
+
+void update_settings_dfu_mode(uint32_t data_addr, uint32_t data_len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // NRF_DFU_SETTINGS_H__
+
+/**@} */
diff --git a/subsys/nrf_dfu/inc/nrf_dfu_transport.h b/subsys/nrf_dfu/inc/nrf_dfu_transport.h
new file mode 100644
index 000000000..4f33a572d
--- /dev/null
+++ b/subsys/nrf_dfu/inc/nrf_dfu_transport.h
@@ -0,0 +1,134 @@
+/**
+ * Copyright (c) 2016 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/**@file
+ *
+ * @defgroup sdk_nrf_dfu_transport DFU transport
+ * @{
+ * @ingroup  nrf_dfu
+ * @brief Generic Device Firmware Update (DFU) transport interface.
+ *
+ * @details The DFU transport module defines a generic interface that must
+ *          be implemented for each transport layer.
+ */
+
+#ifndef NRF_DFU_TRANSPORT_H__
+#define NRF_DFU_TRANSPORT_H__
+
+#include <stdint.h>
+#include "nrf_section.h"
+#include "nrf_dfu_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @brief Forward declaration of nrf_dfu_transport_t */
+typedef struct nrf_dfu_transport_s nrf_dfu_transport_t;
+
+/** @brief  Function type for initializing a DFU transport.
+ *
+ * @details This function initializes a DFU transport. The implementation
+ *          of the function must initialize DFU mode and stay in service
+ *          until either the device is reset or the DFU operation is finalized.
+ *          When the DFU transport receives requests, it should call @ref nrf_dfu_req_handler_on_req for handling the requests.
+ *
+ * @param observer          Callback function for receiving DFU transport notifications.
+ *
+ * @retval  NRF_SUCCESS     If initialization was successful for the transport. Any other return code indicates that the DFU transport could not be initialized.
+ */
+typedef uint32_t (*nrf_dfu_init_fn_t)(nrf_dfu_observer_t observer);
+
+
+/** @brief  Function type for closing down a DFU transport.
+ *
+ * @details This function closes down a DFU transport in a gentle way.
+ *
+ * @param[in] p_exception    If exception matches current transport closing should be omitted.
+ *
+ * @retval    NRF_SUCCESS    If closing was successful for the transport. Any other return code indicates that the DFU transport could not be closed closed down.
+ */
+typedef uint32_t (*nrf_dfu_close_fn_t)(nrf_dfu_transport_t const * p_exception);
+
+
+
+/** @brief DFU transport registration.
+ *
+ * @details     Every DFU transport must provide a registration of the initialization function.
+ */
+struct nrf_dfu_transport_s
+{
+    nrf_dfu_init_fn_t              init_func;          /**< Registration of the init function to run to initialize a DFU transport. */
+    nrf_dfu_close_fn_t             close_func;         /**< Registration of the close function to close down a DFU transport. */
+};
+
+
+/** @brief Function for initializing all the registered DFU transports.
+ *
+ * @retval  NRF_SUCCESS     If all DFU transport were initialized successfully.
+ *                          Any other error code indicates that at least one DFU
+ *                          transport could not be initialized.
+ */
+uint32_t nrf_dfu_transports_init(nrf_dfu_observer_t observer);
+
+/** @brief Function for closing down all (with optional exception) the registered DFU transports.
+ *
+ * @param[in] p_exception   Transport which should not be closed. NULL if all transports should be closed.
+ * @retval    NRF_SUCCESS   If all DFU transport were closed down successfully.
+ *                          Any other error code indicates that at least one DFU
+ *                          transport could not be closed down.
+ */
+uint32_t nrf_dfu_transports_close(nrf_dfu_transport_t const * p_exception);
+
+
+/** @brief  Macro for registering a DFU transport by using section variables.
+ *
+ * @details     This macro places a variable in a section named "dfu_trans", which
+ *              is initialized by @ref nrf_dfu_transports_init.
+ */
+#define DFU_TRANSPORT_REGISTER(trans_var) NRF_SECTION_ITEM_REGISTER(dfu_trans, trans_var)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // NRF_DFU_TRANSPORT_H__
+
+/** @} */
diff --git a/subsys/nrf_dfu/inc/nrf_dfu_types.h b/subsys/nrf_dfu/inc/nrf_dfu_types.h
new file mode 100644
index 000000000..2fe2499d7
--- /dev/null
+++ b/subsys/nrf_dfu/inc/nrf_dfu_types.h
@@ -0,0 +1,272 @@
+/**
+ * Copyright (c) 2016 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/**@file
+ *
+ * @defgroup sdk_nrf_dfu_types DFU types
+ * @{
+ * @ingroup  nrf_dfu
+ */
+
+#ifndef NRF_DFU_TYPES_H__
+#define NRF_DFU_TYPES_H__
+
+#include <stdint.h>
+#include <stddef.h>
+#include <stdbool.h>
+
+#include "nrf_error.h"
+#include "sdk_config.h"
+
+#define  NRF_DFU_SETTINGS_VERSION 2
+typedef void (*nrf_dfu_flash_callback_t)(void * p_buf);
+typedef uint32_t ret_code_t;
+
+#define UNUSED_VARIABLE(X)  ((void)(X))
+#define UNUSED_PARAMETER(X) UNUSED_VARIABLE(X)
+#define UNUSED_RETURN_VALUE(X) UNUSED_VARIABLE(X)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @brief The size that must be reserved for the MBR when a SoftDevice is written to flash.
+This is the offset where the first byte of the SoftDevice hex file is written. */
+#define MBR_SIZE                (0x1000)
+
+/**@brief Macro for increasing a number to the nearest (larger) multiple of another number.
+ *
+ * @param[in]  alignment  The number to align to.
+ * @param[in]  number     The number to align (increase).
+ *
+ * @return The aligned (increased) @p number.
+ */
+#define ALIGN_NUM(alignment, number) (((number) - 1) + (alignment) - (((number) - 1) % (alignment)))
+
+/**
+ * Round up val to the next page boundary
+ */
+#define ALIGN_TO_PAGE(val) ALIGN_NUM((CODE_PAGE_SIZE), (val))
+
+
+#define INIT_COMMAND_MAX_SIZE      512 /**< Maximum size of the init command stored in dfu_settings. */
+#define INIT_COMMAND_MAX_SIZE_v1   256 /**< Maximum size of the init command in settings version 1. */
+
+/** @brief  Size of a flash page. This value is used for calculating the size of the reserved
+ *          flash space in the bootloader region.
+ */
+#if defined(NRF51)
+    #define CODE_PAGE_SIZE            1024
+#elif defined(NRF52_SERIES)
+    #define CODE_PAGE_SIZE            4096
+#else
+    #define CODE_PAGE_SIZE            4096
+#endif
+
+/** @brief  Maximum size of a data object.*/
+#if defined(NRF51)
+    #define DATA_OBJECT_MAX_SIZE           (CODE_PAGE_SIZE * 4)
+#elif defined(NRF52_SERIES) || defined (__SDK_DOXYGEN__)
+    #define DATA_OBJECT_MAX_SIZE           (CODE_PAGE_SIZE)
+#else
+    #define DATA_OBJECT_MAX_SIZE           (CODE_PAGE_SIZE)
+#endif
+
+/** @brief  Page location of the bootloader settings address.
+ */
+#if defined  (NRF51)
+    #define BOOTLOADER_SETTINGS_ADDRESS     (0x0003FC00UL)
+#elif defined( CONFIG_SOC_NRF52805 )
+    #define BOOTLOADER_SETTINGS_ADDRESS     (0x0002F000UL)    
+#elif defined( CONFIG_SOC_NRF52810 )
+    #define BOOTLOADER_SETTINGS_ADDRESS     (0x0002F000UL)
+#elif defined( CONFIG_SOC_NRF52811 )
+    #define BOOTLOADER_SETTINGS_ADDRESS     (0x0002F000UL)
+#elif defined( CONFIG_SOC_NRF52820 )
+    #define BOOTLOADER_SETTINGS_ADDRESS     (0x0003F000UL)
+#elif defined( CONFIG_SOC_NRF52832 )
+    #define BOOTLOADER_SETTINGS_ADDRESS     (0x0007F000UL)
+#elif defined( CONFIG_SOC_NRF52833 )
+    #define BOOTLOADER_SETTINGS_ADDRESS     (0x0007F000UL)
+#elif defined(CONFIG_SOC_NRF52840)
+    #define BOOTLOADER_SETTINGS_ADDRESS     (0x000FF000UL)
+#else
+    #warning No valid target set for BOOTLOADER_SETTINGS_ADDRESS.
+#endif
+
+
+#define NRF_DFU_CURRENT_BANK_0 0x00
+#define NRF_DFU_CURRENT_BANK_1 0x01
+
+#define NRF_DFU_BANK_LAYOUT_DUAL   0x00
+#define NRF_DFU_BANK_LAYOUT_SINGLE 0x01
+
+/** @brief DFU bank state codes.
+ *
+ * @details The DFU bank state indicates the content of a bank:
+ *          A valid image of a certain type or an invalid image.
+ */
+
+#define NRF_DFU_BANK_INVALID         0x00 /**< Invalid image. */
+#define NRF_DFU_BANK_VALID_APP       0x01 /**< Valid application. */
+#define NRF_DFU_BANK_VALID_SD        0xA5 /**< Valid SoftDevice. */
+#define NRF_DFU_BANK_VALID_BL        0xAA /**< Valid bootloader. */
+#define NRF_DFU_BANK_VALID_SD_BL     0xAC /**< Valid SoftDevice and bootloader. */
+#define NRF_DFU_BANK_VALID_EXT_APP   0xB1 /**< Valid application designated for a remote node. */
+
+/** @brief Description of a single bank. */
+#pragma pack(4)
+typedef struct
+{
+    uint32_t                image_size;         /**< Size of the image in the bank. */
+    uint32_t                image_crc;          /**< CRC of the image. If set to 0, the CRC is ignored. */
+    uint32_t                bank_code;          /**< Identifier code for the bank. */
+} nrf_dfu_bank_t;
+
+/**@brief DFU progress.
+ *
+ * Be aware of the difference between objects and firmware images. A firmware image consists of multiple objects, each of a maximum size @ref DATA_OBJECT_MAX_SIZE.
+ *
+ * @note The union inside this struct is cleared when CREATE_OBJECT of command type is executed, and when there is a valid post-validation.
+ *       In DFU activation (after reset) the @ref dfu_progress_t::update_start_address will be used in case of a SD/SD+BL update.
+ */
+//ANON_UNIONS_ENABLE;
+typedef struct
+{
+    uint32_t command_size;              /**< The size of the current init command stored in the DFU settings. */
+    uint32_t command_offset;            /**< The offset of the currently received init command data. The offset will increase as the init command is received. */
+    uint32_t command_crc;               /**< The calculated CRC of the init command (calculated after the transfer is completed). */
+    uint32_t data_object_size;          /**< The size of the last object created. Note that this size is not the size of the whole firmware image.*/
+    union
+    {
+        struct
+        {
+            uint32_t firmware_image_crc;        /**< CRC value of the current firmware (continuously calculated as data is received). */
+            uint32_t firmware_image_crc_last;   /**< The CRC of the last executed object. */
+            uint32_t firmware_image_offset;     /**< The offset of the current firmware image being transferred. Note that this offset is the offset in the entire firmware image and not only the current object. */
+            uint32_t firmware_image_offset_last;/**< The offset of the last executed object from the start of the firmware image. */
+        };
+        struct
+        {
+            uint32_t update_start_address;      /**< Value indicating the start address of the new firmware (before copy). It's always used, but it's most important for an SD/SD+BL update where the SD changes size or if the DFU process had a power loss when updating a SD with changed size. */
+        };
+    };
+} dfu_progress_t;
+//ANON_UNIONS_DISABLE;
+
+/** @brief Event types in the bootloader and DFU process. */
+typedef enum
+{
+    NRF_DFU_EVT_DFU_INITIALIZED,        /**< Starting DFU. */
+    NRF_DFU_EVT_TRANSPORT_ACTIVATED,    /**< Transport activated (e.g. BLE connected, USB plugged in). */
+    NRF_DFU_EVT_TRANSPORT_DEACTIVATED,  /**< Transport deactivated (e.g. BLE disconnected, USB plugged out). */
+    NRF_DFU_EVT_DFU_STARTED,            /**< DFU process started. */
+    NRF_DFU_EVT_OBJECT_RECEIVED,        /**< A DFU data object has been received. */
+    NRF_DFU_EVT_DFU_FAILED,             /**< DFU process has failed, been interrupted, or hung. */
+    NRF_DFU_EVT_DFU_COMPLETED,          /**< DFU process completed. */
+    NRF_DFU_EVT_DFU_ABORTED,            /**< DFU process aborted. */
+} nrf_dfu_evt_type_t;
+
+/**
+ * @brief Function for notifying DFU state.
+ */
+typedef void (*nrf_dfu_observer_t)(nrf_dfu_evt_type_t notification);
+
+#define NRF_DFU_PEER_DATA_LEN 64 /**< The length in bytes of nrf_dfu_peer_data_t expected by tools manipulating the settings page. Do not change without changing the settings page version. */
+#define NRF_DFU_ADV_NAME_LEN  28 /**< The length in bytes of nrf_dfu_adv_name_t expected by tools manipulating the settings page. Do not change without changing the settings page version. */
+
+#define SETTINGS_RESERVED_AREA_SIZE    16 /**< The number of words in the reserved area of the DFU settings. */
+#define SETTINGS_BOOT_VALIDATION_SIZE  64 /**< The number of bytes reserved for boot_validation value. */
+
+
+typedef enum
+{
+    NO_VALIDATION,
+    VALIDATE_CRC,
+    VALIDATE_SHA256,
+    VALIDATE_ECDSA_P256_SHA256,
+} boot_validation_type_t;
+
+typedef struct
+{
+    boot_validation_type_t type;
+    uint8_t                bytes[SETTINGS_BOOT_VALIDATION_SIZE];
+} boot_validation_t;
+
+/**@brief DFU settings for application and bank data.
+ */
+typedef struct
+{
+    uint32_t            crc;                /**< CRC for the stored DFU settings, not including the CRC itself. If 0xFFFFFFF, the CRC has never been calculated. */
+    uint32_t            settings_version;   /**< Version of the current DFU settings struct layout. */
+    uint32_t            app_version;        /**< Version of the last stored application. */
+    uint32_t            bootloader_version; /**< Version of the last stored bootloader. */
+
+    uint32_t            bank_layout;        /**< Bank layout: single bank or dual bank. This value can change. */
+    uint32_t            bank_current;       /**< The bank that is currently used. */
+
+    nrf_dfu_bank_t      bank_0;             /**< Bank 0. */
+    nrf_dfu_bank_t      bank_1;             /**< Bank 1. */
+
+    uint32_t            write_offset;       /**< Write offset for the current operation. */
+    uint32_t            sd_size;            /**< Size of the SoftDevice. */
+
+    dfu_progress_t      progress;           /**< Current DFU progress. */
+
+    uint32_t            enter_buttonless_dfu;
+    uint8_t             init_command[INIT_COMMAND_MAX_SIZE];  /**< Buffer for storing the init command. */
+
+    uint32_t            boot_validation_crc;
+    boot_validation_t   boot_validation_softdevice;
+    boot_validation_t   boot_validation_app;
+    boot_validation_t   boot_validation_bootloader;
+
+    //nrf_dfu_peer_data_t peer_data;          /**< Not included in calculated CRC. */
+    //nrf_dfu_adv_name_t  adv_name;           /**< Not included in calculated CRC. */
+} nrf_dfu_settings_t;
+
+#pragma pack() // revert pack settings
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // NRF_DFU_TYPES_H__
+
+/** @} */
diff --git a/subsys/nrf_dfu/inc/nrf_dfu_validation.h b/subsys/nrf_dfu/inc/nrf_dfu_validation.h
new file mode 100644
index 000000000..c4b4037b9
--- /dev/null
+++ b/subsys/nrf_dfu/inc/nrf_dfu_validation.h
@@ -0,0 +1,119 @@
+/**
+ * Copyright (c) 2017 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/**@file
+ *
+ * @defgroup nrf_dfu_validation Validation
+ * @{
+ * @ingroup  nrf_dfu
+ */
+
+#ifndef __NRF_DFU_VALIDATION_H
+#define __NRF_DFU_VALIDATION_H
+
+#include "stdint.h"
+#include "dfu-cc.pb.h"
+#include "nrf_dfu_handling_error.h"
+
+/**
+ * @brief Function for module initialization.
+ *
+ * Function checks if there is a valid init packet in DFU settings written in flash.
+ */
+void nrf_dfu_validation_init(void);
+
+/**
+ * @brief Function called on reception of init command creation request.
+ *
+ * @param[in] size Size of incoming init packet.
+ *
+ * @return       Operation result. See @ref nrf_dfu_result_t
+ */
+nrf_dfu_result_t nrf_dfu_validation_init_cmd_create(uint32_t size);
+
+/**
+ * @brief Function called on reception of fragment of init command.
+ *
+ * @param[in] p_data Init command fragment.
+ * @param[in] length Init command fragment size.
+ *
+ * @return       Operation result. See @ref nrf_dfu_result_t
+ */
+nrf_dfu_result_t nrf_dfu_validation_init_cmd_append(uint8_t const * p_data, uint32_t length);
+
+/**
+ * @brief Function for getting init command status.
+ *
+ * @param[out] p_offset   Current offset.
+ * @param[out] p_crc      Current CRC.
+ * @param[out] p_max_size Maximum size of init command.
+ */
+void nrf_dfu_validation_init_cmd_status_get(uint32_t * p_offset,
+                                            uint32_t * p_crc,
+                                            uint32_t * p_max_size);
+
+/**
+ * @brief Function for inquiring whether a valid init command has been received.
+ *
+ * @return true  if there is a valid init command. This can be true at boot time
+ *               if the device was reset during a DFU operation.
+ */
+bool nrf_dfu_validation_init_cmd_present(void);
+
+/**
+ * @brief Function for validating init command and retrieving the address and length of the firmware.
+ *
+ * If init command is successfully validated Bank 1 details are written to out parameters.
+ *
+ * Until @ref nrf_dfu_validation_init_cmd_create is called, this function can be called
+ * again after the first time without side effects to retrieve address and length.
+ *
+ * @param[out] p_dst_data_addr  Start address of received data, if validation is successful.
+ * @param[out] p_data_len       Expected length of received data, if validation is successful.
+ *
+ * @return       Operation result. See @ref nrf_dfu_result_t
+ */
+nrf_dfu_result_t nrf_dfu_validation_init_cmd_execute(uint32_t * p_dst_data_addr,
+                                                     uint32_t * p_data_len);
+
+
+
+#endif //__NRF_DFU_VALIDATION_H
+
+/** @} */
diff --git a/subsys/nrf_dfu/inc/nrf_error.h b/subsys/nrf_dfu/inc/nrf_error.h
new file mode 100644
index 000000000..6badee98e
--- /dev/null
+++ b/subsys/nrf_dfu/inc/nrf_error.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2014 - 2017, Nordic Semiconductor ASA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+ /**
+  @defgroup nrf_error SoftDevice Global Error Codes
+  @{
+
+  @brief Global Error definitions
+*/
+
+/* Header guard */
+#ifndef NRF_ERROR_H__
+#define NRF_ERROR_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup NRF_ERRORS_BASE Error Codes Base number definitions
+ * @{ */
+#define NRF_ERROR_BASE_NUM      (0x0)       ///< Global error base
+#define NRF_ERROR_SDM_BASE_NUM  (0x1000)    ///< SDM error base
+#define NRF_ERROR_SOC_BASE_NUM  (0x2000)    ///< SoC error base
+#define NRF_ERROR_STK_BASE_NUM  (0x3000)    ///< STK error base
+/** @} */
+
+#define NRF_SUCCESS                           (NRF_ERROR_BASE_NUM + 0)  ///< Successful command
+#define NRF_ERROR_SVC_HANDLER_MISSING         (NRF_ERROR_BASE_NUM + 1)  ///< SVC handler is missing
+#define NRF_ERROR_SOFTDEVICE_NOT_ENABLED      (NRF_ERROR_BASE_NUM + 2)  ///< SoftDevice has not been enabled
+#define NRF_ERROR_INTERNAL                    (NRF_ERROR_BASE_NUM + 3)  ///< Internal Error
+#define NRF_ERROR_NO_MEM                      (NRF_ERROR_BASE_NUM + 4)  ///< No Memory for operation
+#define NRF_ERROR_NOT_FOUND                   (NRF_ERROR_BASE_NUM + 5)  ///< Not found
+#define NRF_ERROR_NOT_SUPPORTED               (NRF_ERROR_BASE_NUM + 6)  ///< Not supported
+#define NRF_ERROR_INVALID_PARAM               (NRF_ERROR_BASE_NUM + 7)  ///< Invalid Parameter
+#define NRF_ERROR_INVALID_STATE               (NRF_ERROR_BASE_NUM + 8)  ///< Invalid state, operation disallowed in this state
+#define NRF_ERROR_INVALID_LENGTH              (NRF_ERROR_BASE_NUM + 9)  ///< Invalid Length
+#define NRF_ERROR_INVALID_FLAGS               (NRF_ERROR_BASE_NUM + 10) ///< Invalid Flags
+#define NRF_ERROR_INVALID_DATA                (NRF_ERROR_BASE_NUM + 11) ///< Invalid Data
+#define NRF_ERROR_DATA_SIZE                   (NRF_ERROR_BASE_NUM + 12) ///< Invalid Data size
+#define NRF_ERROR_TIMEOUT                     (NRF_ERROR_BASE_NUM + 13) ///< Operation timed out
+#define NRF_ERROR_NULL                        (NRF_ERROR_BASE_NUM + 14) ///< Null Pointer
+#define NRF_ERROR_FORBIDDEN                   (NRF_ERROR_BASE_NUM + 15) ///< Forbidden Operation
+#define NRF_ERROR_INVALID_ADDR                (NRF_ERROR_BASE_NUM + 16) ///< Bad Memory Address
+#define NRF_ERROR_BUSY                        (NRF_ERROR_BASE_NUM + 17) ///< Busy
+#define NRF_ERROR_CONN_COUNT                  (NRF_ERROR_BASE_NUM + 18) ///< Maximum connection count exceeded.
+#define NRF_ERROR_RESOURCES                   (NRF_ERROR_BASE_NUM + 19) ///< Not enough resources for operation
+
+#ifdef __cplusplus
+}
+#endif
+#endif // NRF_ERROR_H__
+
+/**
+  @}
+*/
diff --git a/subsys/nrf_dfu/inc/nrf_section.h b/subsys/nrf_dfu/inc/nrf_section.h
new file mode 100644
index 000000000..ecd092429
--- /dev/null
+++ b/subsys/nrf_dfu/inc/nrf_section.h
@@ -0,0 +1,191 @@
+/**
+ * Copyright (c) 2016 - 2019, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef NRF_SECTION_H__
+#define NRF_SECTION_H__
+
+#include "nordic_common.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @defgroup section_vars Section variables
+ * @ingroup app_common
+ * @{
+ *
+ * @brief Section variables.
+ */
+
+//lint -save -e27 -esym(526,*)
+
+#if defined(__ICCARM__)
+// Enable IAR language extensions
+#pragma language=extended
+#endif
+
+/**@brief   Macro for obtaining the address of the beginning of a section.
+ *
+ * param[in]    section_name    Name of the section.
+ * @hideinitializer
+ */
+#if defined(__CC_ARM)
+#define NRF_SECTION_START_ADDR(section_name)       &CONCAT_2(section_name, $$Base)
+
+#elif defined(__GNUC__)
+#define NRF_SECTION_START_ADDR(section_name)       &CONCAT_2(__start_, section_name)
+
+#elif defined(__ICCARM__)
+#define NRF_SECTION_START_ADDR(section_name)       __section_begin(STRINGIFY(section_name))
+#endif
+
+
+/**@brief    Macro for obtaining the address of the end of a section.
+ *
+ * @param[in]   section_name    Name of the section.
+ * @hideinitializer
+ */
+#if defined(__CC_ARM)
+#define NRF_SECTION_END_ADDR(section_name)         &CONCAT_2(section_name, $$Limit)
+
+#elif defined(__GNUC__)
+#define NRF_SECTION_END_ADDR(section_name)         &CONCAT_2(__stop_, section_name)
+
+#elif defined(__ICCARM__)
+#define NRF_SECTION_END_ADDR(section_name)         __section_end(STRINGIFY(section_name))
+#endif
+
+
+/**@brief   Macro for retrieving the length of a given section, in bytes.
+ *
+ * @param[in]   section_name    Name of the section.
+ * @hideinitializer
+ */
+#define NRF_SECTION_LENGTH(section_name)                        \
+    ((size_t)NRF_SECTION_END_ADDR(section_name) -               \
+     (size_t)NRF_SECTION_START_ADDR(section_name))
+
+
+/**@brief   Macro for creating a section.
+ *
+ * @param[in]   section_name    Name of the section.
+ * @param[in]   data_type       Data type of the variables to be registered in the section.
+ *
+ * @warning Data type must be word aligned to prevent padding.
+ * @hideinitializer
+ */
+#if defined(__CC_ARM)
+#define NRF_SECTION_DEF(section_name, data_type)                \
+    extern data_type * CONCAT_2(section_name, $$Base);          \
+    extern void      * CONCAT_2(section_name, $$Limit)
+
+#elif defined(__GNUC__)
+#define NRF_SECTION_DEF(section_name, data_type)                \
+    extern data_type * CONCAT_2(__start_, section_name);        \
+    extern void      * CONCAT_2(__stop_,  section_name)
+
+#elif defined(__ICCARM__)
+#define NRF_SECTION_DEF(section_name, data_type)                \
+    _Pragma(STRINGIFY(section = STRINGIFY(section_name)));
+
+#endif
+
+
+/**@brief   Macro for declaring a variable and registering it in a section.
+ *
+ * @details Declares a variable and registers it in a named section. This macro ensures that the
+ *          variable is not stripped away when using optimizations.
+ *
+ * @note The order in which variables are placed in a section is dependent on the order in
+ *       which the linker script encounters the variables during linking.
+ *
+ * @param[in]   section_name    Name of the section.
+ * @param[in]   section_var     Variable to register in the given section.
+ * @hideinitializer
+ */
+#if defined(__CC_ARM)
+#define NRF_SECTION_ITEM_REGISTER(section_name, section_var) \
+    section_var __attribute__ ((section(STRINGIFY(section_name)))) __attribute__((used))
+
+#elif defined(__GNUC__)
+#define NRF_SECTION_ITEM_REGISTER(section_name, section_var) \
+    section_var __attribute__((section("." STRINGIFY(section_name)))) __attribute__((used))
+
+#elif defined(__ICCARM__)
+#define NRF_SECTION_ITEM_REGISTER(section_name, section_var) \
+    __root section_var @ STRINGIFY(section_name)
+#endif
+
+
+/**@brief   Macro for retrieving a variable from a section.
+ *
+ * @warning     The stored symbol can only be resolved using this macro if the
+ *              type of the data is word aligned. The operation of acquiring
+ *              the stored symbol relies on the size of the stored type. No
+ *              padding can exist in the named section in between individual
+ *              stored items or this macro will fail.
+ *
+ * @param[in]   section_name    Name of the section.
+ * @param[in]   data_type       Data type of the variable.
+ * @param[in]   i               Index of the variable in section.
+ * @hideinitializer
+ */
+#define NRF_SECTION_ITEM_GET(section_name, data_type, i) \
+    ((data_type*)NRF_SECTION_START_ADDR(section_name) + (i))
+
+
+/**@brief   Macro for getting the number of variables in a section.
+ *
+ * @param[in]   section_name    Name of the section.
+ * @param[in]   data_type       Data type of the variables in the section.
+ * @hideinitializer
+ */
+#define NRF_SECTION_ITEM_COUNT(section_name, data_type) \
+    NRF_SECTION_LENGTH(section_name) / sizeof(data_type)
+
+/** @} */
+
+//lint -restore
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // NRF_SECTION_H__
diff --git a/subsys/nrf_dfu/inc/pb.h b/subsys/nrf_dfu/inc/pb.h
new file mode 100644
index 000000000..3fd2a4ec8
--- /dev/null
+++ b/subsys/nrf_dfu/inc/pb.h
@@ -0,0 +1,556 @@
+/* Common parts of the nanopb library. Most of these are quite low-level
+ * stuff. For the high-level interface, see pb_encode.h and pb_decode.h.
+ */
+
+#ifndef PB_H_INCLUDED
+#define PB_H_INCLUDED
+
+/*****************************************************************
+ * Nanopb compilation time options. You can change these here by *
+ * uncommenting the lines, or on the compiler command line.      *
+ *****************************************************************/
+
+/* Enable support for dynamically allocated fields */
+/* #define PB_ENABLE_MALLOC 1 */
+
+/* Define this if your CPU / compiler combination does not support
+ * unaligned memory access to packed structures. */
+#define PB_NO_PACKED_STRUCTS 1
+
+/* Increase the number of required fields that are tracked.
+ * A compiler warning will tell if you need this. */
+/* #define PB_MAX_REQUIRED_FIELDS 256 */
+
+/* Add support for tag numbers > 255 and fields larger than 255 bytes. */
+#define PB_FIELD_16BIT 1
+
+/* Add support for tag numbers > 65536 and fields larger than 65536 bytes. */
+/* #define PB_FIELD_32BIT 1 */
+
+/* Disable support for error messages in order to save some code space. */
+#define PB_NO_ERRMSG 1
+
+/* Disable support for custom streams (support only memory buffers). */
+/* #define PB_BUFFER_ONLY 1 */
+
+/* Switch back to the old-style callback function signature.
+ * This was the default until nanopb-0.2.1. */
+/* #define PB_OLD_CALLBACK_STYLE */
+
+
+/******************************************************************
+ * You usually don't need to change anything below this line.     *
+ * Feel free to look around and use the defined macros, though.   *
+ ******************************************************************/
+
+
+/* Version of the nanopb library. Just in case you want to check it in
+ * your own program. */
+#define NANOPB_VERSION nanopb-0.3.6-dev
+
+/* Include all the system headers needed by nanopb. You will need the
+ * definitions of the following:
+ * - strlen, memcpy, memset functions
+ * - [u]int_least8_t, uint_fast8_t, [u]int_least16_t, [u]int32_t, [u]int64_t
+ * - size_t
+ * - bool
+ *
+ * If you don't have the standard header files, you can instead provide
+ * a custom header that defines or includes all this. In that case,
+ * define PB_SYSTEM_HEADER to the path of this file.
+ */
+#ifdef PB_SYSTEM_HEADER
+#include PB_SYSTEM_HEADER
+#else
+#include <stdint.h>
+#include <stddef.h>
+#include <stdbool.h>
+#include <string.h>
+
+#ifdef PB_ENABLE_MALLOC
+#include <stdlib.h>
+#endif
+#endif
+
+/* Macro for defining packed structures (compiler dependent).
+ * This just reduces memory requirements, but is not required.
+ */
+#if defined(PB_NO_PACKED_STRUCTS)
+    /* Disable struct packing */
+#   define PB_PACKED_STRUCT_START
+#   define PB_PACKED_STRUCT_END
+#   define pb_packed
+#elif defined(__GNUC__) || defined(__clang__)
+    /* For GCC and clang */
+#   define PB_PACKED_STRUCT_START
+#   define PB_PACKED_STRUCT_END
+#   define pb_packed __attribute__((packed))
+#elif defined(__ICCARM__) || defined(__CC_ARM)
+    /* For IAR ARM and Keil MDK-ARM compilers */
+#   define PB_PACKED_STRUCT_START _Pragma("pack(push, 1)")
+#   define PB_PACKED_STRUCT_END _Pragma("pack(pop)")
+#   define pb_packed
+#elif defined(_MSC_VER) && (_MSC_VER >= 1500)
+    /* For Microsoft Visual C++ */
+#   define PB_PACKED_STRUCT_START __pragma(pack(push, 1))
+#   define PB_PACKED_STRUCT_END __pragma(pack(pop))
+#   define pb_packed
+#else
+    /* Unknown compiler */
+#   define PB_PACKED_STRUCT_START
+#   define PB_PACKED_STRUCT_END
+#   define pb_packed
+#endif
+
+/* Handly macro for suppressing unreferenced-parameter compiler warnings. */
+#ifndef PB_UNUSED
+#define PB_UNUSED(x) (void)(x)
+#endif
+
+/* Compile-time assertion, used for checking compatible compilation options.
+ * If this does not work properly on your compiler, use
+ * #define PB_NO_STATIC_ASSERT to disable it.
+ *
+ * But before doing that, check carefully the error message / place where it
+ * comes from to see if the error has a real cause. Unfortunately the error
+ * message is not always very clear to read, but you can see the reason better
+ * in the place where the PB_STATIC_ASSERT macro was called.
+ */
+#ifndef PB_NO_STATIC_ASSERT
+#ifndef PB_STATIC_ASSERT
+#define PB_STATIC_ASSERT(COND,MSG) typedef char PB_STATIC_ASSERT_MSG(MSG, __LINE__, __COUNTER__)[(COND)?1:-1];
+#define PB_STATIC_ASSERT_MSG(MSG, LINE, COUNTER) PB_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER)
+#define PB_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER) pb_static_assertion_##MSG##LINE##COUNTER
+#endif
+#else
+#define PB_STATIC_ASSERT(COND,MSG)
+#endif
+
+/* Number of required fields to keep track of. */
+#ifndef PB_MAX_REQUIRED_FIELDS
+#define PB_MAX_REQUIRED_FIELDS 64
+#endif
+
+#if PB_MAX_REQUIRED_FIELDS < 64
+#error You should not lower PB_MAX_REQUIRED_FIELDS from the default value (64).
+#endif
+
+/* List of possible field types. These are used in the autogenerated code.
+ * Least-significant 4 bits tell the scalar type
+ * Most-significant 4 bits specify repeated/required/packed etc.
+ */
+
+typedef uint_least8_t pb_type_t;
+
+/**** Field data types ****/
+
+/* Numeric types */
+#define PB_LTYPE_VARINT  0x00 /* int32, int64, enum, bool */
+#define PB_LTYPE_UVARINT 0x01 /* uint32, uint64 */
+#define PB_LTYPE_SVARINT 0x02 /* sint32, sint64 */
+#define PB_LTYPE_FIXED32 0x03 /* fixed32, sfixed32, float */
+#define PB_LTYPE_FIXED64 0x04 /* fixed64, sfixed64, double */
+
+/* Marker for last packable field type. */
+#define PB_LTYPE_LAST_PACKABLE 0x04
+
+/* Byte array with pre-allocated buffer.
+ * data_size is the length of the allocated PB_BYTES_ARRAY structure. */
+#define PB_LTYPE_BYTES 0x05
+
+/* String with pre-allocated buffer.
+ * data_size is the maximum length. */
+#define PB_LTYPE_STRING 0x06
+
+/* Submessage
+ * submsg_fields is pointer to field descriptions */
+#define PB_LTYPE_SUBMESSAGE 0x07
+
+/* Extension pseudo-field
+ * The field contains a pointer to pb_extension_t */
+#define PB_LTYPE_EXTENSION 0x08
+
+/* Number of declared LTYPES */
+#define PB_LTYPES_COUNT 9
+#define PB_LTYPE_MASK 0x0F
+
+/**** Field repetition rules ****/
+
+#define PB_HTYPE_REQUIRED 0x00
+#define PB_HTYPE_OPTIONAL 0x10
+#define PB_HTYPE_REPEATED 0x20
+#define PB_HTYPE_ONEOF    0x30
+#define PB_HTYPE_MASK     0x30
+
+/**** Field allocation types ****/
+ 
+#define PB_ATYPE_STATIC   0x00
+#define PB_ATYPE_POINTER  0x80
+#define PB_ATYPE_CALLBACK 0x40
+#define PB_ATYPE_MASK     0xC0
+
+#define PB_ATYPE(x) ((x) & PB_ATYPE_MASK)
+#define PB_HTYPE(x) ((x) & PB_HTYPE_MASK)
+#define PB_LTYPE(x) ((x) & PB_LTYPE_MASK)
+
+/* Data type used for storing sizes of struct fields
+ * and array counts.
+ */
+#if defined(PB_FIELD_32BIT)
+    typedef uint32_t pb_size_t;
+    typedef int32_t pb_ssize_t;
+#elif defined(PB_FIELD_16BIT)
+    typedef uint_least16_t pb_size_t;
+    typedef int_least16_t pb_ssize_t;
+#else
+    typedef uint_least8_t pb_size_t;
+    typedef int_least8_t pb_ssize_t;
+#endif
+#define PB_SIZE_MAX ((pb_size_t)-1)
+
+/* Data type for storing encoded data and other byte streams.
+ * This typedef exists to support platforms where uint8_t does not exist.
+ * You can regard it as equivalent on uint8_t on other platforms.
+ */
+typedef uint_least8_t pb_byte_t;
+
+/* This structure is used in auto-generated constants
+ * to specify struct fields.
+ * You can change field sizes if you need structures
+ * larger than 256 bytes or field tags larger than 256.
+ * The compiler should complain if your .proto has such
+ * structures. Fix that by defining PB_FIELD_16BIT or
+ * PB_FIELD_32BIT.
+ */
+PB_PACKED_STRUCT_START
+typedef struct pb_field_s pb_field_t;
+struct pb_field_s {
+    pb_size_t tag;
+    pb_type_t type;
+    pb_size_t data_offset; /* Offset of field data, relative to previous field. */
+    pb_ssize_t size_offset; /* Offset of array size or has-boolean, relative to data */
+    pb_size_t data_size; /* Data size in bytes for a single item */
+    pb_size_t array_size; /* Maximum number of entries in array */
+    
+    /* Field definitions for submessage
+     * OR default value for all other non-array, non-callback types
+     * If null, then field will zeroed. */
+    const void *ptr;
+} pb_packed;
+PB_PACKED_STRUCT_END
+
+/* Make sure that the standard integer types are of the expected sizes.
+ * Otherwise fixed32/fixed64 fields can break.
+ *
+ * If you get errors here, it probably means that your stdint.h is not
+ * correct for your platform.
+ */
+PB_STATIC_ASSERT(sizeof(int64_t) == 2 * sizeof(int32_t), INT64_T_WRONG_SIZE)
+PB_STATIC_ASSERT(sizeof(uint64_t) == 2 * sizeof(uint32_t), UINT64_T_WRONG_SIZE)
+
+/* This structure is used for 'bytes' arrays.
+ * It has the number of bytes in the beginning, and after that an array.
+ * Note that actual structs used will have a different length of bytes array.
+ */
+#define PB_BYTES_ARRAY_T(n) struct { pb_size_t size; pb_byte_t bytes[n]; }
+#define PB_BYTES_ARRAY_T_ALLOCSIZE(n) ((size_t)n + offsetof(pb_bytes_array_t, bytes))
+
+struct pb_bytes_array_s {
+    pb_size_t size;
+    pb_byte_t bytes[1];
+};
+typedef struct pb_bytes_array_s pb_bytes_array_t;
+
+/* This structure is used for giving the callback function.
+ * It is stored in the message structure and filled in by the method that
+ * calls pb_decode.
+ *
+ * The decoding callback will be given a limited-length stream
+ * If the wire type was string, the length is the length of the string.
+ * If the wire type was a varint/fixed32/fixed64, the length is the length
+ * of the actual value.
+ * The function may be called multiple times (especially for repeated types,
+ * but also otherwise if the message happens to contain the field multiple
+ * times.)
+ *
+ * The encoding callback will receive the actual output stream.
+ * It should write all the data in one call, including the field tag and
+ * wire type. It can write multiple fields.
+ *
+ * The callback can be null if you want to skip a field.
+ */
+typedef struct pb_istream_s pb_istream_t;
+typedef struct pb_ostream_s pb_ostream_t;
+typedef struct pb_callback_s pb_callback_t;
+struct pb_callback_s {
+#ifdef PB_OLD_CALLBACK_STYLE
+    /* Deprecated since nanopb-0.2.1 */
+    union {
+        bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void *arg);
+        bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, const void *arg);
+    } funcs;
+#else
+    /* New function signature, which allows modifying arg contents in callback. */
+    union {
+        bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void **arg);
+        bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, void * const *arg);
+    } funcs;
+#endif    
+    
+    /* Free arg for use by callback */
+    void *arg;
+};
+
+/* Wire types. Library user needs these only in encoder callbacks. */
+typedef enum {
+    PB_WT_VARINT = 0,
+    PB_WT_64BIT  = 1,
+    PB_WT_STRING = 2,
+    PB_WT_32BIT  = 5
+} pb_wire_type_t;
+
+/* Structure for defining the handling of unknown/extension fields.
+ * Usually the pb_extension_type_t structure is automatically generated,
+ * while the pb_extension_t structure is created by the user. However,
+ * if you want to catch all unknown fields, you can also create a custom
+ * pb_extension_type_t with your own callback.
+ */
+typedef struct pb_extension_type_s pb_extension_type_t;
+typedef struct pb_extension_s pb_extension_t;
+struct pb_extension_type_s {
+    /* Called for each unknown field in the message.
+     * If you handle the field, read off all of its data and return true.
+     * If you do not handle the field, do not read anything and return true.
+     * If you run into an error, return false.
+     * Set to NULL for default handler.
+     */
+    bool (*decode)(pb_istream_t *stream, pb_extension_t *extension,
+                   uint32_t tag, pb_wire_type_t wire_type);
+    
+    /* Called once after all regular fields have been encoded.
+     * If you have something to write, do so and return true.
+     * If you do not have anything to write, just return true.
+     * If you run into an error, return false.
+     * Set to NULL for default handler.
+     */
+    bool (*encode)(pb_ostream_t *stream, const pb_extension_t *extension);
+    
+    /* Free field for use by the callback. */
+    const void *arg;
+};
+
+struct pb_extension_s {
+    /* Type describing the extension field. Usually you'll initialize
+     * this to a pointer to the automatically generated structure. */
+    const pb_extension_type_t *type;
+    
+    /* Destination for the decoded data. This must match the datatype
+     * of the extension field. */
+    void *dest;
+    
+    /* Pointer to the next extension handler, or NULL.
+     * If this extension does not match a field, the next handler is
+     * automatically called. */
+    pb_extension_t *next;
+
+    /* The decoder sets this to true if the extension was found.
+     * Ignored for encoding. */
+    bool found;
+};
+
+/* Memory allocation functions to use. You can define pb_realloc and
+ * pb_free to custom functions if you want. */
+#ifdef PB_ENABLE_MALLOC
+#   ifndef pb_realloc
+#       define pb_realloc(ptr, size) realloc(ptr, size)
+#   endif
+#   ifndef pb_free
+#       define pb_free(ptr) free(ptr)
+#   endif
+#endif
+
+/* This is used to inform about need to regenerate .pb.h/.pb.c files. */
+#define PB_PROTO_HEADER_VERSION 30
+
+/* These macros are used to declare pb_field_t's in the constant array. */
+/* Size of a structure member, in bytes. */
+#define pb_membersize(st, m) (sizeof ((st*)0)->m)
+/* Number of entries in an array. */
+#define pb_arraysize(st, m) (pb_membersize(st, m) / pb_membersize(st, m[0]))
+/* Delta from start of one member to the start of another member. */
+#define pb_delta(st, m1, m2) ((int)offsetof(st, m1) - (int)offsetof(st, m2))
+/* Marks the end of the field list */
+#define PB_LAST_FIELD {0,(pb_type_t) 0,0,0,0,0,0}
+
+/* Macros for filling in the data_offset field */
+/* data_offset for first field in a message */
+#define PB_DATAOFFSET_FIRST(st, m1, m2) (offsetof(st, m1))
+/* data_offset for subsequent fields */
+#define PB_DATAOFFSET_OTHER(st, m1, m2) (offsetof(st, m1) - offsetof(st, m2) - pb_membersize(st, m2))
+/* Choose first/other based on m1 == m2 (deprecated, remains for backwards compatibility) */
+#define PB_DATAOFFSET_CHOOSE(st, m1, m2) (int)(offsetof(st, m1) == offsetof(st, m2) \
+                                  ? PB_DATAOFFSET_FIRST(st, m1, m2) \
+                                  : PB_DATAOFFSET_OTHER(st, m1, m2))
+
+/* Required fields are the simplest. They just have delta (padding) from
+ * previous field end, and the size of the field. Pointer is used for
+ * submessages and default values.
+ */
+#define PB_REQUIRED_STATIC(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_STATIC | PB_HTYPE_REQUIRED | ltype, \
+    fd, 0, pb_membersize(st, m), 0, ptr}
+
+/* Optional fields add the delta to the has_ variable. */
+#define PB_OPTIONAL_STATIC(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype, \
+    fd, \
+    pb_delta(st, has_ ## m, m), \
+    pb_membersize(st, m), 0, ptr}
+
+/* Repeated fields have a _count field and also the maximum number of entries. */
+#define PB_REPEATED_STATIC(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_STATIC | PB_HTYPE_REPEATED | ltype, \
+    fd, \
+    pb_delta(st, m ## _count, m), \
+    pb_membersize(st, m[0]), \
+    pb_arraysize(st, m), ptr}
+
+/* Allocated fields carry the size of the actual data, not the pointer */
+#define PB_REQUIRED_POINTER(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_POINTER | PB_HTYPE_REQUIRED | ltype, \
+    fd, 0, pb_membersize(st, m[0]), 0, ptr}
+
+/* Optional fields don't need a has_ variable, as information would be redundant */
+#define PB_OPTIONAL_POINTER(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_POINTER | PB_HTYPE_OPTIONAL | ltype, \
+    fd, 0, pb_membersize(st, m[0]), 0, ptr}
+
+/* Repeated fields have a _count field and a pointer to array of pointers */
+#define PB_REPEATED_POINTER(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_POINTER | PB_HTYPE_REPEATED | ltype, \
+    fd, pb_delta(st, m ## _count, m), \
+    pb_membersize(st, m[0]), 0, ptr}
+
+/* Callbacks are much like required fields except with special datatype. */
+#define PB_REQUIRED_CALLBACK(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_REQUIRED | ltype, \
+    fd, 0, pb_membersize(st, m), 0, ptr}
+
+#define PB_OPTIONAL_CALLBACK(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_OPTIONAL | ltype, \
+    fd, 0, pb_membersize(st, m), 0, ptr}
+    
+#define PB_REPEATED_CALLBACK(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_REPEATED | ltype, \
+    fd, 0, pb_membersize(st, m), 0, ptr}
+
+/* Optional extensions don't have the has_ field, as that would be redundant. */
+#define PB_OPTEXT_STATIC(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype, \
+    0, \
+    0, \
+    pb_membersize(st, m), 0, ptr}
+
+#define PB_OPTEXT_POINTER(tag, st, m, fd, ltype, ptr) \
+    PB_OPTIONAL_POINTER(tag, st, m, fd, ltype, ptr)
+
+#define PB_OPTEXT_CALLBACK(tag, st, m, fd, ltype, ptr) \
+    PB_OPTIONAL_CALLBACK(tag, st, m, fd, ltype, ptr)
+
+/* The mapping from protobuf types to LTYPEs is done using these macros. */
+#define PB_LTYPE_MAP_BOOL       PB_LTYPE_VARINT
+#define PB_LTYPE_MAP_BYTES      PB_LTYPE_BYTES
+#define PB_LTYPE_MAP_DOUBLE     PB_LTYPE_FIXED64
+#define PB_LTYPE_MAP_ENUM       PB_LTYPE_VARINT
+#define PB_LTYPE_MAP_UENUM      PB_LTYPE_UVARINT
+#define PB_LTYPE_MAP_FIXED32    PB_LTYPE_FIXED32
+#define PB_LTYPE_MAP_FIXED64    PB_LTYPE_FIXED64
+#define PB_LTYPE_MAP_FLOAT      PB_LTYPE_FIXED32
+#define PB_LTYPE_MAP_INT32      PB_LTYPE_VARINT
+#define PB_LTYPE_MAP_INT64      PB_LTYPE_VARINT
+#define PB_LTYPE_MAP_MESSAGE    PB_LTYPE_SUBMESSAGE
+#define PB_LTYPE_MAP_SFIXED32   PB_LTYPE_FIXED32
+#define PB_LTYPE_MAP_SFIXED64   PB_LTYPE_FIXED64
+#define PB_LTYPE_MAP_SINT32     PB_LTYPE_SVARINT
+#define PB_LTYPE_MAP_SINT64     PB_LTYPE_SVARINT
+#define PB_LTYPE_MAP_STRING     PB_LTYPE_STRING
+#define PB_LTYPE_MAP_UINT32     PB_LTYPE_UVARINT
+#define PB_LTYPE_MAP_UINT64     PB_LTYPE_UVARINT
+#define PB_LTYPE_MAP_EXTENSION  PB_LTYPE_EXTENSION
+
+/* This is the actual macro used in field descriptions.
+ * It takes these arguments:
+ * - Field tag number
+ * - Field type:   BOOL, BYTES, DOUBLE, ENUM, UENUM, FIXED32, FIXED64,
+ *                 FLOAT, INT32, INT64, MESSAGE, SFIXED32, SFIXED64
+ *                 SINT32, SINT64, STRING, UINT32, UINT64 or EXTENSION
+ * - Field rules:  REQUIRED, OPTIONAL or REPEATED
+ * - Allocation:   STATIC or CALLBACK
+ * - Placement: FIRST or OTHER, depending on if this is the first field in structure.
+ * - Message name
+ * - Field name
+ * - Previous field name (or field name again for first field)
+ * - Pointer to default value or submsg fields.
+ */
+
+#define PB_FIELD(tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
+        PB_ ## rules ## _ ## allocation(tag, message, field, \
+        PB_DATAOFFSET_ ## placement(message, field, prevfield), \
+        PB_LTYPE_MAP_ ## type, ptr)
+
+/* Field description for oneof fields. This requires taking into account the
+ * union name also, that's why a separate set of macros is needed.
+ */
+#define PB_ONEOF_STATIC(u, tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype, \
+    fd, pb_delta(st, which_ ## u, u.m), \
+    pb_membersize(st, u.m), 0, ptr}
+
+#define PB_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype, \
+    fd, pb_delta(st, which_ ## u, u.m), \
+    pb_membersize(st, u.m[0]), 0, ptr}
+
+#define PB_ONEOF_FIELD(union_name, tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
+        PB_ONEOF_ ## allocation(union_name, tag, message, field, \
+        PB_DATAOFFSET_ ## placement(message, union_name.field, prevfield), \
+        PB_LTYPE_MAP_ ## type, ptr)
+
+#define PB_ANONYMOUS_ONEOF_STATIC(u, tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype, \
+    fd, pb_delta(st, which_ ## u, m), \
+    pb_membersize(st, m), 0, ptr}
+
+#define PB_ANONYMOUS_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype, \
+    fd, pb_delta(st, which_ ## u, m), \
+    pb_membersize(st, m[0]), 0, ptr}
+
+#define PB_ANONYMOUS_ONEOF_FIELD(union_name, tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
+        PB_ANONYMOUS_ONEOF_ ## allocation(union_name, tag, message, field, \
+        PB_DATAOFFSET_ ## placement(message, field, prevfield), \
+        PB_LTYPE_MAP_ ## type, ptr)
+
+/* These macros are used for giving out error messages.
+ * They are mostly a debugging aid; the main error information
+ * is the true/false return value from functions.
+ * Some code space can be saved by disabling the error
+ * messages if not used.
+ *
+ * PB_SET_ERROR() sets the error message if none has been set yet.
+ *                msg must be a constant string literal.
+ * PB_GET_ERROR() always returns a pointer to a string.
+ * PB_RETURN_ERROR() sets the error and returns false from current
+ *                   function.
+ */
+#ifdef PB_NO_ERRMSG
+#define PB_SET_ERROR(stream, msg) PB_UNUSED(stream)
+#define PB_GET_ERROR(stream) "(errmsg disabled)"
+#else
+#define PB_SET_ERROR(stream, msg) (stream->errmsg = (stream)->errmsg ? (stream)->errmsg : (msg))
+#define PB_GET_ERROR(stream) ((stream)->errmsg ? (stream)->errmsg : "(none)")
+#endif
+
+#define PB_RETURN_ERROR(stream, msg) return PB_SET_ERROR(stream, msg), false
+
+#endif
diff --git a/subsys/nrf_dfu/inc/pb_common.h b/subsys/nrf_dfu/inc/pb_common.h
new file mode 100644
index 000000000..60b3d3749
--- /dev/null
+++ b/subsys/nrf_dfu/inc/pb_common.h
@@ -0,0 +1,42 @@
+/* pb_common.h: Common support functions for pb_encode.c and pb_decode.c.
+ * These functions are rarely needed by applications directly.
+ */
+
+#ifndef PB_COMMON_H_INCLUDED
+#define PB_COMMON_H_INCLUDED
+
+#include "pb.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Iterator for pb_field_t list */
+struct pb_field_iter_s {
+    const pb_field_t *start;       /* Start of the pb_field_t array */
+    const pb_field_t *pos;         /* Current position of the iterator */
+    unsigned required_field_index; /* Zero-based index that counts only the required fields */
+    void *dest_struct;             /* Pointer to start of the structure */
+    void *pData;                   /* Pointer to current field value */
+    void *pSize;                   /* Pointer to count/has field */
+};
+typedef struct pb_field_iter_s pb_field_iter_t;
+
+/* Initialize the field iterator structure to beginning.
+ * Returns false if the message type is empty. */
+bool pb_field_iter_begin(pb_field_iter_t *iter, const pb_field_t *fields, void *dest_struct);
+
+/* Advance the iterator to the next field.
+ * Returns false when the iterator wraps back to the first field. */
+bool pb_field_iter_next(pb_field_iter_t *iter);
+
+/* Advance the iterator until it points at a field with the given tag.
+ * Returns false if no such field exists. */
+bool pb_field_iter_find(pb_field_iter_t *iter, uint32_t tag);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif
+
diff --git a/subsys/nrf_dfu/inc/pb_decode.h b/subsys/nrf_dfu/inc/pb_decode.h
new file mode 100644
index 000000000..7ab8ce7c0
--- /dev/null
+++ b/subsys/nrf_dfu/inc/pb_decode.h
@@ -0,0 +1,152 @@
+/* pb_decode.h: Functions to decode protocol buffers. Depends on pb_decode.c.
+ * The main function is pb_decode. You also need an input stream, and the
+ * field descriptions created by nanopb_generator.py.
+ */
+
+#ifndef PB_DECODE_H_INCLUDED
+#define PB_DECODE_H_INCLUDED
+
+#include "pb.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Structure for defining custom input streams. You will need to provide
+ * a callback function to read the bytes from your storage, which can be
+ * for example a file or a network socket.
+ * 
+ * The callback must conform to these rules:
+ *
+ * 1) Return false on IO errors. This will cause decoding to abort.
+ * 2) You can use state to store your own data (e.g. buffer pointer),
+ *    and rely on pb_read to verify that no-body reads past bytes_left.
+ * 3) Your callback may be used with substreams, in which case bytes_left
+ *    is different than from the main stream. Don't use bytes_left to compute
+ *    any pointers.
+ */
+struct pb_istream_s
+{
+#ifdef PB_BUFFER_ONLY
+    /* Callback pointer is not used in buffer-only configuration.
+     * Having an int pointer here allows binary compatibility but
+     * gives an error if someone tries to assign callback function.
+     */
+    int *callback;
+#else
+    bool (*callback)(pb_istream_t *stream, pb_byte_t *buf, size_t count);
+#endif
+
+    void *state; /* Free field for use by callback implementation */
+    size_t bytes_left;
+    
+    /* Informative callback for field decoding */
+    void (* decoding_callback)(pb_istream_t *strem, uint32_t tag, pb_wire_type_t wire_type, void *iter);
+
+#ifndef PB_NO_ERRMSG
+    const char *errmsg;
+#endif
+};
+
+/***************************
+ * Main decoding functions *
+ ***************************/
+ 
+/* Decode a single protocol buffers message from input stream into a C structure.
+ * Returns true on success, false on any failure.
+ * The actual struct pointed to by dest must match the description in fields.
+ * Callback fields of the destination structure must be initialized by caller.
+ * All other fields will be initialized by this function.
+ *
+ * Example usage:
+ *    MyMessage msg = {};
+ *    uint8_t buffer[64];
+ *    pb_istream_t stream;
+ *    
+ *    // ... read some data into buffer ...
+ *
+ *    stream = pb_istream_from_buffer(buffer, count);
+ *    pb_decode(&stream, MyMessage_fields, &msg);
+ */
+bool pb_decode(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct);
+
+/* Same as pb_decode, except does not initialize the destination structure
+ * to default values. This is slightly faster if you need no default values
+ * and just do memset(struct, 0, sizeof(struct)) yourself.
+ *
+ * This can also be used for 'merging' two messages, i.e. update only the
+ * fields that exist in the new message.
+ *
+ * Note: If this function returns with an error, it will not release any
+ * dynamically allocated fields. You will need to call pb_release() yourself.
+ */
+bool pb_decode_noinit(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct);
+
+/* Same as pb_decode, except expects the stream to start with the message size
+ * encoded as varint. Corresponds to parseDelimitedFrom() in Google's
+ * protobuf API.
+ */
+bool pb_decode_delimited(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct);
+
+#ifdef PB_ENABLE_MALLOC
+/* Release any allocated pointer fields. If you use dynamic allocation, you should
+ * call this for any successfully decoded message when you are done with it. If
+ * pb_decode() returns with an error, the message is already released.
+ */
+void pb_release(const pb_field_t fields[], void *dest_struct);
+#endif
+
+
+/**************************************
+ * Functions for manipulating streams *
+ **************************************/
+
+/* Create an input stream for reading from a memory buffer.
+ *
+ * Alternatively, you can use a custom stream that reads directly from e.g.
+ * a file or a network socket.
+ */
+pb_istream_t pb_istream_from_buffer(const pb_byte_t *buf, size_t bufsize);
+
+/* Function to read from a pb_istream_t. You can use this if you need to
+ * read some custom header data, or to read data in field callbacks.
+ */
+bool pb_read(pb_istream_t *stream, pb_byte_t *buf, size_t count);
+
+
+/************************************************
+ * Helper functions for writing field callbacks *
+ ************************************************/
+
+/* Decode the tag for the next field in the stream. Gives the wire type and
+ * field tag. At end of the message, returns false and sets eof to true. */
+bool pb_decode_tag(pb_istream_t *stream, pb_wire_type_t *wire_type, uint32_t *tag, bool *eof);
+
+/* Skip the field payload data, given the wire type. */
+bool pb_skip_field(pb_istream_t *stream, pb_wire_type_t wire_type);
+
+/* Decode an integer in the varint format. This works for bool, enum, int32,
+ * int64, uint32 and uint64 field types. */
+bool pb_decode_varint(pb_istream_t *stream, uint64_t *dest);
+
+/* Decode an integer in the zig-zagged svarint format. This works for sint32
+ * and sint64. */
+bool pb_decode_svarint(pb_istream_t *stream, int64_t *dest);
+
+/* Decode a fixed32, sfixed32 or float value. You need to pass a pointer to
+ * a 4-byte wide C variable. */
+bool pb_decode_fixed32(pb_istream_t *stream, void *dest);
+
+/* Decode a fixed64, sfixed64 or double value. You need to pass a pointer to
+ * a 8-byte wide C variable. */
+bool pb_decode_fixed64(pb_istream_t *stream, void *dest);
+
+/* Make a limited-length substream for reading a PB_WT_STRING field. */
+bool pb_make_string_substream(pb_istream_t *stream, pb_istream_t *substream);
+void pb_close_string_substream(pb_istream_t *stream, pb_istream_t *substream);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif
diff --git a/subsys/nrf_dfu/inc/sdk_config.h b/subsys/nrf_dfu/inc/sdk_config.h
new file mode 100644
index 000000000..ee24c5b48
--- /dev/null
+++ b/subsys/nrf_dfu/inc/sdk_config.h
@@ -0,0 +1,398 @@
+/**
+ * Copyright (c) 2017 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+
+#ifndef SDK_CONFIG_H
+#define SDK_CONFIG_H
+
+// <h> nRF_DFU 
+
+//==========================================================
+// <h> DFU security - nrf_dfu_validation - DFU validation
+
+//==========================================================
+// <q> NRF_DFU_APP_ACCEPT_SAME_VERSION  - Whether to accept application upgrades with the same version as the current application.
+ 
+
+// <i> This applies to application updates, and possibly to SoftDevice updates.
+// <i> Bootloader upgrades always require higher versions. SoftDevice upgrades
+// <i> look at the sd_req field independently of this config.
+// <i> Disabling this protects against replay attacks wearing out the flash of the device.
+// <i> This config only has an effect when NRF_DFU_APP_DOWNGRADE_PREVENTION is enabled.
+
+#ifndef NRF_DFU_APP_ACCEPT_SAME_VERSION
+#define NRF_DFU_APP_ACCEPT_SAME_VERSION 1
+#endif
+
+// <q> NRF_DFU_APP_DOWNGRADE_PREVENTION  - Check the firmware version and SoftDevice requirements of application (and SoftDevice) updates.
+ 
+
+// <i> Whether to check the incoming version against the version of the existing app and/or
+// <i> the incoming SoftDevice requirements against the existing SoftDevice.
+// <i> This applies to application updates, and possibly to SoftDevice updates.
+// <i> Disabling this causes the checks to always ignore the incoming firmware version and
+// <i> to ignore the SoftDevice requirements if the first requirement is 0.
+// <i> This does not apply the bootloader updates. If the bootloader depends on the SoftDevice
+// <i> e.g. for BLE transport, this does not apply to SoftDevice updates.
+// <i> See @ref lib_bootloader_dfu_validation for more information.
+// <i> When signed updates are required, version checking should always be enabled.
+
+#ifndef NRF_DFU_APP_DOWNGRADE_PREVENTION
+#define NRF_DFU_APP_DOWNGRADE_PREVENTION 1
+#endif
+
+// <q> NRF_DFU_EXTERNAL_APP_VERSIONING  - Require versioning for external applications.
+ 
+
+// <i> This configuration is only used if NRF_DFU_SUPPORTS_EXTERNAL_APP is set to 1.
+// <i> Setting this will require that any FW images using the FW upgrade type 
+// <i> DFU_FW_TYPE_EXTERNAL_APPLICATION must follow a monotonic versioning scheme
+// <i> where the FW version of an upgrade must always be larger than the previously stored 
+// <i> FW version.
+
+#ifndef NRF_DFU_EXTERNAL_APP_VERSIONING
+#define NRF_DFU_EXTERNAL_APP_VERSIONING 1
+#endif
+
+// <q> NRF_DFU_FORCE_DUAL_BANK_APP_UPDATES  - Accept only dual-bank application updates.
+ 
+
+// <i> If not enabled then if there is not enough space to perform dual-bank update
+// <i> application is deleted and single-bank update is performed. In case it is considered
+// <i> security concern user can prefer to discard update request rather than overwrite
+// <i> current application.
+
+#ifndef NRF_DFU_FORCE_DUAL_BANK_APP_UPDATES
+#define NRF_DFU_FORCE_DUAL_BANK_APP_UPDATES 1
+#endif
+
+// <o> NRF_DFU_HW_VERSION - Device hardware version. 
+// <i> This is used to determine if given update is targeting the device.
+// <i> It is checked against the hw_version value in the init packet
+
+#ifndef NRF_DFU_HW_VERSION
+#define NRF_DFU_HW_VERSION 52
+#endif
+
+// <q> NRF_DFU_REQUIRE_SIGNED_APP_UPDATE  - Require a valid signature to update the application or SoftDevice.
+ 
+
+#ifndef NRF_DFU_REQUIRE_SIGNED_APP_UPDATE
+#define NRF_DFU_REQUIRE_SIGNED_APP_UPDATE 1
+#endif
+
+// <q> NRF_DFU_SINGLE_BANK_APP_UPDATES  - Place the application and the SoftDevice directly where they are supposed to be.
+ 
+
+// <i> Note that this creates security concerns when signing and  version checks
+// <i> are enabled. An attacker will be able to delete (but not replace)
+// <i> the current app or SoftDevice without knowing the signature key.
+
+#ifndef NRF_DFU_SINGLE_BANK_APP_UPDATES
+#define NRF_DFU_SINGLE_BANK_APP_UPDATES 0
+#endif
+
+// </h> 
+//==========================================================
+
+// <q> NRF_DFU_SETTINGS_COMPATIBILITY_MODE  - nrf_dfu_settings - DFU Settings
+ 
+
+#ifndef NRF_DFU_SETTINGS_COMPATIBILITY_MODE
+#define NRF_DFU_SETTINGS_COMPATIBILITY_MODE 1
+#endif
+
+// <h> nrf_dfu - Device Firmware Upgrade
+
+//==========================================================
+// <h> DFU transport 
+
+//==========================================================
+// <e> NRF_DFU_TRANSPORT_ANT - ANT transport settings
+//==========================================================
+#ifndef NRF_DFU_TRANSPORT_ANT
+#define NRF_DFU_TRANSPORT_ANT 0
+#endif
+// <o> NRF_DFU_ANT_MTU - MTU size used for firmware bursts. 
+// <i> Sets the maximum burst size used for DFU write commands.
+
+#ifndef NRF_DFU_ANT_MTU
+#define NRF_DFU_ANT_MTU 1024
+#endif
+
+// <h> ANT DFU buffers 
+
+//==========================================================
+// <e> NRF_DFU_ANT_BUFFERS_OVERRIDE 
+
+// <i> Check this option to override the default number of buffers.
+//==========================================================
+#ifndef NRF_DFU_ANT_BUFFERS_OVERRIDE
+#define NRF_DFU_ANT_BUFFERS_OVERRIDE 0
+#endif
+// <o> NRF_DFU_ANT_BUFFERS - Number of buffers in the ANT transport. 
+// <i> Number of buffers to store incoming data while it is being written to flash.
+// <i> Reduce this value to save RAM. If this value is too low, the DFU process will fail.
+
+#ifndef NRF_DFU_ANT_BUFFERS
+#define NRF_DFU_ANT_BUFFERS 8
+#endif
+
+// </e>
+
+// </h> 
+//==========================================================
+
+// <h> ANT DFU Channel Configuration 
+
+//==========================================================
+// <o> NRF_DFU_ANT_RF_FREQ - DFU RF channel. 
+#ifndef NRF_DFU_ANT_RF_FREQ
+#define NRF_DFU_ANT_RF_FREQ 66
+#endif
+
+// <o> NRF_DFU_ANT_DEV_TYPE - Device type field to use for DFU channel id. 
+#ifndef NRF_DFU_ANT_DEV_TYPE
+#define NRF_DFU_ANT_DEV_TYPE 10
+#endif
+
+// <o> NRF_DFU_ANT_CHANNEL_PERIOD - Channel period of DFU ANT channel. 
+#ifndef NRF_DFU_ANT_CHANNEL_PERIOD
+#define NRF_DFU_ANT_CHANNEL_PERIOD 2048
+#endif
+
+// </h> 
+//==========================================================
+
+// </e>
+
+// <e> NRF_DFU_TRANSPORT_BLE - BLE transport settings
+//==========================================================
+#ifndef NRF_DFU_TRANSPORT_BLE
+#define NRF_DFU_TRANSPORT_BLE 1
+#endif
+// <q> NRF_DFU_BLE_SKIP_SD_INIT  - Skip the SoftDevice and interrupt vector table initialization.
+ 
+
+#ifndef NRF_DFU_BLE_SKIP_SD_INIT
+#define NRF_DFU_BLE_SKIP_SD_INIT 0
+#endif
+
+// <s> NRF_DFU_BLE_ADV_NAME - Default advertising name.
+#ifndef NRF_DFU_BLE_ADV_NAME
+#define NRF_DFU_BLE_ADV_NAME "DfuTarg"
+#endif
+
+// <o> NRF_DFU_BLE_ADV_INTERVAL - Advertising interval (in units of 0.625 ms) 
+#ifndef NRF_DFU_BLE_ADV_INTERVAL
+#define NRF_DFU_BLE_ADV_INTERVAL 40
+#endif
+
+// <h> BLE DFU security 
+
+//==========================================================
+// <q> NRF_DFU_BLE_REQUIRES_BONDS  - Require bond with peer.
+ 
+
+#ifndef NRF_DFU_BLE_REQUIRES_BONDS
+#define NRF_DFU_BLE_REQUIRES_BONDS 0
+
+#endif
+
+// </h> 
+//==========================================================
+
+// <h> BLE DFU connection 
+
+//==========================================================
+// <o> NRF_DFU_BLE_MIN_CONN_INTERVAL - Minimum connection interval (units). 
+// <i> Minimum GAP connection interval, in 1.25 ms units.
+
+#ifndef NRF_DFU_BLE_MIN_CONN_INTERVAL
+#define NRF_DFU_BLE_MIN_CONN_INTERVAL 12
+#endif
+
+// <o> NRF_DFU_BLE_MAX_CONN_INTERVAL - Maximum connection interval (units). 
+// <i> Maximum GAP connection interval, in 1.25 ms units.
+
+#ifndef NRF_DFU_BLE_MAX_CONN_INTERVAL
+#define NRF_DFU_BLE_MAX_CONN_INTERVAL 12
+#endif
+
+// <o> NRF_DFU_BLE_CONN_SUP_TIMEOUT_MS - Supervision timeout (ms). 
+// <i> GAP connection supervision timeout, in milliseconds.
+
+#ifndef NRF_DFU_BLE_CONN_SUP_TIMEOUT_MS
+#define NRF_DFU_BLE_CONN_SUP_TIMEOUT_MS 6000
+#endif
+
+// </h> 
+//==========================================================
+
+// <h> BLE DFU buffers 
+
+//==========================================================
+// <e> NRF_DFU_BLE_BUFFERS_OVERRIDE 
+
+// <i> Check this option to override the default number of buffers.
+//==========================================================
+#ifndef NRF_DFU_BLE_BUFFERS_OVERRIDE
+#define NRF_DFU_BLE_BUFFERS_OVERRIDE 0
+#endif
+// <o> NRF_DFU_BLE_BUFFERS - Number of buffers in the BLE transport. 
+// <i> Number of buffers to store incoming data while it is being written to flash.
+// <i> Reduce this value to save RAM. If this value is too low, the DFU process will fail.
+
+#ifndef NRF_DFU_BLE_BUFFERS
+#define NRF_DFU_BLE_BUFFERS 8
+#endif
+
+// </e>
+
+// </h> 
+//==========================================================
+
+// </e>
+
+// </h> 
+//==========================================================
+
+// <h> DFU protocol 
+
+//==========================================================
+// <q> NRF_DFU_PROTOCOL_FW_VERSION_MSG  - Firmware version message support.
+ 
+
+// <i> Firmware version message support.
+// <i> If disabled, firmware version requests will return NRF_DFU_RES_CODE_OP_CODE_NOT_SUPPORTED.
+
+#ifndef NRF_DFU_PROTOCOL_FW_VERSION_MSG
+#define NRF_DFU_PROTOCOL_FW_VERSION_MSG 1
+#endif
+
+// <q> NRF_DFU_PROTOCOL_REDUCED  - Reduced protocol opcode selection.
+ 
+
+// <i> Only support a minimal set of opcodes; return NRF_DFU_RES_CODE_OP_CODE_NOT_SUPPORTED 
+// <i> for unsupported opcodes. The supported opcodes are:NRF_DFU_OP_OBJECT_CREATE, 
+// <i> NRF_DFU_OP_OBJECT_EXECUTE, NRF_DFU_OP_OBJECT_SELECT, NRF_DFU_OP_OBJECT_WRITE, 
+// <i> NRF_DFU_OP_CRC_GET, NRF_DFU_OP_RECEIPT_NOTIF_SET, and NRF_DFU_OP_ABORT. 
+// <i> This reduced feature set is used by the BLE transport to reduce flash usage.
+
+#ifndef NRF_DFU_PROTOCOL_REDUCED
+#define NRF_DFU_PROTOCOL_REDUCED 1
+#endif
+
+// <q> NRF_DFU_PROTOCOL_VERSION_MSG  - Protocol version message support.
+ 
+
+// <i> Protocol version message support.
+// <i> If disabled, protocol version requests will return NRF_DFU_RES_CODE_OP_CODE_NOT_SUPPORTED.
+
+#ifndef NRF_DFU_PROTOCOL_VERSION_MSG
+#define NRF_DFU_PROTOCOL_VERSION_MSG 1
+#endif
+
+// </h> 
+//==========================================================
+
+// <h> Misc DFU settings 
+
+//==========================================================
+// <o> NRF_DFU_APP_DATA_AREA_SIZE - The size (in bytes) of the flash area reserved for application data. 
+// <i> This area is found at the end of the application area, next to the start of
+// <i> the bootloader. This area will not be erased by the bootloader during a
+// <i> firmware upgrade. The size must be a multiple of the flash page size.
+
+#ifndef NRF_DFU_APP_DATA_AREA_SIZE
+#define NRF_DFU_APP_DATA_AREA_SIZE 12288
+#endif
+
+// <q> NRF_DFU_IN_APP  - Specifies that this code is in the app, not the bootloader, so some settings are off-limits.
+ 
+
+// <i> Enable this to disable writing to areas of the settings that are protected
+// <i> by the bootlader. If this is not enabled in the app, certain settings write
+// <i> operations will cause HardFaults or will be ignored. Enabling this option
+// <i> also causes postvalidation to be disabled since this is meant to be done
+// <i> in the bootloader. NRF_BL_DFU_ALLOW_UPDATE_FROM_APP must be enabled in the bootloader.
+
+#ifndef NRF_DFU_IN_APP
+#define NRF_DFU_IN_APP 1
+#endif
+
+// <q> NRF_DFU_SAVE_PROGRESS_IN_FLASH  - Save DFU progress in flash.
+ 
+
+// <i> Save DFU progress to flash so that it can be resumed if interrupted, instead of being restarted.
+// <i> Keep this setting disabled to maximize transfer speed and minimize flash wear.
+// <i> The init packet is always saved in flash, regardless of this setting.
+
+#ifndef NRF_DFU_SAVE_PROGRESS_IN_FLASH
+#define NRF_DFU_SAVE_PROGRESS_IN_FLASH 0
+#endif
+
+// <q> NRF_DFU_SUPPORTS_EXTERNAL_APP  - [Experimental] Support for external app.
+ 
+
+// <i> External apps are apps that will not be activated. They can 
+// <i> e.g. be apps to be sent to a third party. External app updates 
+// <i> are verified upon reception, but will remain in bank 1, and 
+// <i> will never be booted. An external app will be overwritten if 
+// <i> a new DFU procedure is performed. Note: This functionality is 
+// <i> experimental and not yet used in any examples.
+
+#ifndef NRF_DFU_SUPPORTS_EXTERNAL_APP
+#define NRF_DFU_SUPPORTS_EXTERNAL_APP 0
+#endif
+
+// </h> 
+//==========================================================
+
+// </h> 
+//==========================================================
+
+// </h> 
+//==========================================================
+
+// <<< end of configuration section >>>
+#endif //SDK_CONFIG_H
+
diff --git a/subsys/nrf_dfu/nrf_dfu_ble.c b/subsys/nrf_dfu/nrf_dfu_ble.c
new file mode 100644
index 000000000..65fa098ae
--- /dev/null
+++ b/subsys/nrf_dfu/nrf_dfu_ble.c
@@ -0,0 +1,428 @@
+/**
+ * Copyright (c) 2016 - 2020, Nordic Semiconductor ASA
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form, except as embedded into a Nordic
+ *    Semiconductor ASA integrated circuit in a product or a software update for
+ *    such product, must reproduce the above copyright notice, this list of
+ *    conditions and the following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
+ *    contributors may be used to endorse or promote products derived from this
+ *    software without specific prior written permission.
+ *
+ * 4. This software, with or without modification, must only be used with a
+ *    Nordic Semiconductor ASA integrated circuit.
+ *
+ * 5. Any software provided in binary form under this license must not be reverse
+ *    engineered, decompiled, modified and/or disassembled.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <errno.h>
+#include <zephyr.h>
+#include <init.h>
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/uuid.h>
+#include <bluetooth/gatt.h>
+#include <stddef.h>
+#include "nrf_dfu_transport.h"
+#include "nrf_dfu_req_handler.h"
+#include "nrf_dfu_handling_error.h"
+#include "app_util.h"
+#include <logging/log.h>
+
+#define MODULE dfu_ble
+LOG_MODULE_REGISTER(MODULE, CONFIG_NRF_DFU_LOG_LEVEL);
+
+#define CONN_INTERVAL_BLE_MIN 8
+#define CONN_INTERVAL_BLE_MAX 15
+
+#define GATT_HEADER_LEN                     3                                                       /**< GATT header length. */
+#define GATT_PAYLOAD(mtu)                   ((mtu) - GATT_HEADER_LEN)                               /**< Length of the ATT payload for a given ATT MTU. */
+#define MAX_DFU_PKT_LEN                     (NRF_SDH_BLE_GATT_MAX_MTU_SIZE - GATT_HEADER_LEN)       /**< Maximum length (in bytes) of the DFU Packet characteristic (3 bytes are used for the GATT opcode and handle). */
+#define MAX_RESPONSE_LEN                    17                                                      /**< Maximum length (in bytes) of the response to a Control Point command. */
+#define RESPONSE_HEADER_LEN                 3                                                       /**< The length of the header of a response. I.E. the index of the opcode-specific payload. */
+
+#define DFU_BLE_FLAG_INITIALIZED            (1 << 0)                                                /**< Flag to check if the DFU service was initialized by the application.*/
+ 
+uint32_t ble_dfu_transport_init(nrf_dfu_observer_t observer);
+uint32_t ble_dfu_transport_close(nrf_dfu_transport_t const * p_exception);
+
+#ifndef CONFIG_NRF_DFU_RPC_NET
+DFU_TRANSPORT_REGISTER(nrf_dfu_transport_t const ble_dfu_transport) =
+{
+    .init_func  = ble_dfu_transport_init,
+    .close_func = ble_dfu_transport_close,
+};
+#else
+// nrf_dfu_transport_t const ble_dfu_transport;
+#endif
+
+
+static uint32_t           m_flags;
+static uint16_t           m_pkt_notif_target;                                                       /**< Number of packets of firmware data to be received before transmitting the next Packet Receipt Notification to the DFU Controller. */
+static uint16_t           m_pkt_notif_target_cnt;                                                   /**< Number of packets of firmware data received after sending last Packet Receipt Notification or since the receipt of a @ref BLE_DFU_PKT_RCPT_NOTIF_ENABLED event from the DFU service, which ever occurs later.*/
+              /**< Advertising handle used to identify an advertising set. */
+static nrf_dfu_observer_t m_observer;                                                               /**< Observer function called on certain events. */
+
+static int response_send(uint8_t * data, uint16_t len);
+
+
+/**@brief Function for encoding the beginning of a response.
+ *
+ * @param[inout] p_buffer  The buffer to encode into.
+ * @param[in]    op_code   The opcode of the response.
+ * @param[in]    result    The result of the operation.
+ *
+ * @return The length added to the buffer.
+ */
+static uint32_t response_prepare(uint8_t * p_buffer, uint8_t op_code, uint8_t result)
+{
+    __ASSERT_NO_MSG(p_buffer);
+    p_buffer[0] = NRF_DFU_OP_RESPONSE;
+    p_buffer[1] = op_code;
+    p_buffer[2] = result;
+    return RESPONSE_HEADER_LEN;
+}
+
+
+/**@brief Function for encoding a select object response into a buffer.
+ *
+ * The select object response consists of a maximum object size, a firmware offset, and a CRC value.
+ *
+ * @param[inout] p_buffer   The buffer to encode the response into.
+ * @param[in]    max_size   The maximum object size value to encode.
+ * @param[in]    fw_offset  The firmware offset value to encode.
+ * @param[in]    crc        The CRC value to encode.
+ *
+ * @return The length added to the buffer.
+ */
+static uint32_t response_select_obj_add(uint8_t  * p_buffer,
+                                        uint32_t   max_size,
+                                        uint32_t   fw_offset,
+                                        uint32_t   crc)
+{
+    uint16_t offset = uint32_encode(max_size,  &p_buffer[RESPONSE_HEADER_LEN]);
+    offset         += uint32_encode(fw_offset, &p_buffer[RESPONSE_HEADER_LEN + offset]);
+    offset         += uint32_encode(crc,       &p_buffer[RESPONSE_HEADER_LEN + offset]);
+    return offset;
+}
+
+
+/**@brief Function for encoding a CRC response into a buffer.
+ *
+ * The CRC response consists of a firmware offset and a CRC value.
+ *
+ * @param[inout] p_buffer   The buffer to encode the response into.
+ * @param[in]    fw_offset  The firmware offset value to encode.
+ * @param[in]    crc        The CRC value to encode.
+ *
+ * @return The length added to the buffer.
+ */
+static uint32_t response_crc_add(uint8_t * p_buffer, uint32_t fw_offset, uint32_t crc)
+{
+    uint16_t offset = uint32_encode(fw_offset, &p_buffer[RESPONSE_HEADER_LEN]);
+    offset         += uint32_encode(crc,       &p_buffer[RESPONSE_HEADER_LEN + offset]);
+    return offset;
+}
+
+
+/**@brief Function for appending an extended error code to the response buffer.
+ *
+ * @param[inout] p_buffer    The buffer to append the extended error code to.
+ * @param[in]    result      The error code to append.
+ * @param[in]    buf_offset  The current length of the buffer.
+ *
+ * @return The length added to the buffer.
+ */
+static uint32_t response_ext_err_payload_add(uint8_t * p_buffer, uint8_t result, uint32_t buf_offset)
+{
+    p_buffer[buf_offset] = ext_error_get();
+    (void) ext_error_set(NRF_DFU_EXT_ERROR_NO_ERROR);
+    return 1;
+}
+
+
+void ble_dfu_req_handler_callback(nrf_dfu_response_t * p_res, void * p_context)
+{
+    __ASSERT_NO_MSG(p_res);
+    // __ASSERT_NO_MSG(p_context);
+
+    uint8_t len = 0;
+    uint8_t buffer[MAX_RESPONSE_LEN] = {0};
+
+    if (p_res->request == NRF_DFU_OP_OBJECT_WRITE)
+    {
+        --m_pkt_notif_target_cnt;
+        if ((m_pkt_notif_target == 0) || (m_pkt_notif_target_cnt && m_pkt_notif_target > 0))
+        {
+            return;
+        }
+
+        /* Reply with a CRC message and reset the packet counter. */
+        m_pkt_notif_target_cnt = m_pkt_notif_target;
+
+        p_res->request = NRF_DFU_OP_CRC_GET;
+    }
+
+    len += response_prepare(buffer, p_res->request, p_res->result);
+
+    if (p_res->result != NRF_DFU_RES_CODE_SUCCESS)
+    {
+        LOG_WRN("DFU request %d failed with error: 0x%x", p_res->request, p_res->result);
+
+        if (p_res->result == NRF_DFU_RES_CODE_EXT_ERROR)
+        {
+            len += response_ext_err_payload_add(buffer, p_res->result, len);
+        }
+
+        (void) response_send(buffer, len);
+        return;
+    }
+
+    switch (p_res->request)
+    {
+        case NRF_DFU_OP_OBJECT_CREATE:
+        case NRF_DFU_OP_OBJECT_EXECUTE:
+            break;
+
+        case NRF_DFU_OP_OBJECT_SELECT:
+        {
+            len += response_select_obj_add(buffer,
+                                           p_res->select.max_size,
+                                           p_res->select.offset,
+                                           p_res->select.crc);
+        } break;
+
+        case NRF_DFU_OP_OBJECT_WRITE:
+        {
+            len += response_crc_add(buffer, p_res->write.offset, p_res->write.crc);
+        } break;
+
+        case NRF_DFU_OP_CRC_GET:
+        {
+            len += response_crc_add(buffer, p_res->crc.offset, p_res->crc.crc);
+        } break;
+
+        default:
+        {
+            // No action.
+        } break;
+    }
+
+    (void) response_send(buffer, len);
+}
+
+
+/**@brief     Function for handling a Write event on the Control Point characteristic.
+
+ */
+static ssize_t on_ctrl_pt_write(struct bt_conn *conn,
+			  const struct bt_gatt_attr *attr,
+			  const void *buf,
+			  uint16_t len,
+			  uint16_t offset,
+			  uint8_t flags)
+{
+    static bool conn_updated = false;
+    uint8_t * data = (uint8_t *)buf;
+    //lint -save -e415 -e416 : Out-of-bounds access on p_ble_write_evt->data
+    nrf_dfu_request_t request =
+    {
+        .request           = (nrf_dfu_op_t)data[0],
+        .p_context         = conn,
+        .callback.response = ble_dfu_req_handler_callback,
+        .write.len         = 0,
+    };
+
+    if (!conn_updated)
+    {
+        conn_updated = true;
+		struct bt_le_conn_param param = {
+			.interval_min = CONN_INTERVAL_BLE_MIN,
+			.interval_max = CONN_INTERVAL_BLE_MAX,
+			.latency = 0,
+			.timeout = 400,
+		};
+        LOG_INF("Initiate conn update min=%d max=%d", param.interval_min, param.interval_max);
+		bt_conn_le_param_update(conn, &param);    
+    }
+
+    switch (request.request)
+    {
+        case NRF_DFU_OP_OBJECT_SELECT:
+        {
+            /* Set object type to read info about */
+            request.select.object_type = data[1];
+        } break;
+
+        case NRF_DFU_OP_OBJECT_CREATE:
+        {
+            /* Reset the packet receipt notification on create object */
+            m_pkt_notif_target_cnt = m_pkt_notif_target;
+
+            request.create.object_type = data[1];
+            request.create.object_size = uint32_decode(&(data[2]));
+#ifndef CONFIG_NRF_DFU_RPC_NET
+            if (request.create.object_type == NRF_DFU_OBJ_TYPE_COMMAND)
+            {                
+                /* Activity on the current transport. Close all except the current one. */
+                (void) nrf_dfu_transports_close(&ble_dfu_transport);
+            }
+#endif            
+        } break;
+
+        case NRF_DFU_OP_RECEIPT_NOTIF_SET:
+        {
+            LOG_DBG("Set receipt notif");
+
+            m_pkt_notif_target     = uint16_decode(&(data[1]));
+            m_pkt_notif_target_cnt = m_pkt_notif_target;
+        } break;
+
+        default:
+            break;
+    }
+    //lint -restore : Out-of-bounds access
+
+    nrf_dfu_req_handler_on_req(&request);
+
+	// uint8_t *value = attr->user_data;
+
+	// memcpy(value + offset, buf, len);
+
+	return len;    
+}
+
+
+static void flash_op_done(void * p_buf)
+{
+
+}
+
+
+/**@brief   Function for handling the @ref BLE_GATTS_EVT_WRITE event from the SoftDevice.
+ 
+ */
+static ssize_t on_pkt_write(struct bt_conn *conn,
+			  const struct bt_gatt_attr *attr,
+			  const void *buf,
+			  uint16_t len,
+			  uint16_t offset,
+			  uint8_t flags)
+{   
+    /* Set up the request. */
+    nrf_dfu_request_t request =
+    {
+        .request      = NRF_DFU_OP_OBJECT_WRITE,
+        .p_context    = conn,
+        .callback     =
+        {
+            .response = ble_dfu_req_handler_callback,
+            .write    = flash_op_done,
+        }
+    };
+
+    /* Set up the request buffer. */
+    request.write.p_data   = (uint8_t *) buf;
+    request.write.len      = len;
+    
+    /* Schedule handling of the request. */
+    ret_code_t rc = nrf_dfu_req_handler_on_req(&request);
+    if (rc != NRF_SUCCESS)
+    {
+        LOG_ERR("req handle err %d", rc);
+    }
+    return len;
+}
+
+uint32_t ble_dfu_transport_init(nrf_dfu_observer_t observer)
+{
+    uint32_t err_code = NRF_SUCCESS;
+
+    if (m_flags & DFU_BLE_FLAG_INITIALIZED)
+    {
+        return err_code;
+    }
+
+    m_observer = observer;
+
+    m_flags |= DFU_BLE_FLAG_INITIALIZED;
+
+    LOG_DBG("BLE DFU transport initialized.");
+
+    return NRF_SUCCESS;
+}
+
+
+uint32_t ble_dfu_transport_close(nrf_dfu_transport_t const * p_exception)
+{
+    uint32_t err_code = NRF_SUCCESS;
+
+    if (m_flags & DFU_BLE_FLAG_INITIALIZED)
+    {
+        m_flags = 0;
+    }
+    return err_code;
+}
+
+
+// This is a 16-bit UUID.
+#define BLE_DFU_SERVICE_UUID                 0xFE59                       //!< UUID of the DFU Service.
+
+#define BT_UUID_DFU_SERVICE \
+	BT_UUID_DECLARE_16(BLE_DFU_SERVICE_UUID)
+
+
+#define BT_UUID_CTRL_PT   BT_UUID_DECLARE_128(0x50, 0xEA, 0xDA, 0x30, 0x88, 0x83, 0xB8, 0x9F, 0x60, 0x4F, 0x15, 0xF3, 0x01, 0x00, 0xC9, 0x8E)
+
+
+#define BT_UUID_PKT   BT_UUID_DECLARE_128(0x50, 0xEA, 0xDA, 0x30, 0x88, 0x83, 0xB8, 0x9F, 0x60, 0x4F, 0x15, 0xF3, 0x02, 0x00, 0xC9, 0x8E)
+
+/* UART Service Declaration */
+BT_GATT_SERVICE_DEFINE(dfu_svc,
+BT_GATT_PRIMARY_SERVICE(BT_UUID_DFU_SERVICE),
+	BT_GATT_CHARACTERISTIC(BT_UUID_CTRL_PT,
+			       BT_GATT_CHRC_NOTIFY | BT_GATT_CHRC_WRITE,
+			       BT_GATT_PERM_READ | BT_GATT_PERM_WRITE,
+			       NULL, on_ctrl_pt_write, NULL),
+	BT_GATT_CCC(NULL, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE),
+	BT_GATT_CHARACTERISTIC(BT_UUID_PKT,
+			       BT_GATT_CHRC_WRITE_WITHOUT_RESP,
+			       BT_GATT_PERM_READ | BT_GATT_PERM_WRITE,
+			       NULL, on_pkt_write, NULL),
+);
+
+
+static int response_send(uint8_t * data, uint16_t len)
+{
+	struct bt_gatt_notify_params params = {0};
+	const struct bt_gatt_attr *attr = &dfu_svc.attrs[2];
+
+	params.attr = attr;
+	params.data = data;
+	params.len = len;
+	params.func = NULL;
+
+	return bt_gatt_notify_cb(NULL, &params);	
+}
diff --git a/subsys/nrf_rpc/rp_ll.c b/subsys/nrf_rpc/rp_ll.c
index 026d1a13e..619b4fec1 100644
--- a/subsys/nrf_rpc/rp_ll.c
+++ b/subsys/nrf_rpc/rp_ll.c
@@ -277,10 +277,10 @@ int rp_ll_init(void)
 	/* Get RPMsg device from RPMsg VirtIO device. */
 	rdev = rpmsg_virtio_get_rpmsg_device(&rvdev);
 
+	k_work_init(&work_item, work_callback);
 	k_work_queue_start(&my_work_q, rx_thread_stack,
 		K_THREAD_STACK_SIZEOF(rx_thread_stack),
-		CONFIG_NRF_RPC_TR_PRMSG_RX_PRIORITY, NULL);
-	k_work_init(&work_item, work_callback);
+		CONFIG_NRF_RPC_TR_PRMSG_RX_PRIORITY, NULL);	
 
 	LOG_DBG("initializing %s: SUCCESS", __func__);
 
diff --git a/subsys/partition_manager/flash_map_partition_manager.c b/subsys/partition_manager/flash_map_partition_manager.c
index 7513dd3e9..12088e724 100644
--- a/subsys/partition_manager/flash_map_partition_manager.c
+++ b/subsys/partition_manager/flash_map_partition_manager.c
@@ -9,7 +9,11 @@
 #include <pm_config.h>
 #include <sys/util.h>
 
+#ifndef CONFIG_SOC_NRF5340_CPUNET
 #define FLASH_MAP_OFFSET(i) UTIL_CAT(PM_, UTIL_CAT(PM_##i##_LABEL, _ADDRESS))
+#else
+#define FLASH_MAP_OFFSET(i) UTIL_CAT(PM_, UTIL_CAT(PM_##i##_LABEL, _ADDRESS)) >= 0x1000000 ? (UTIL_CAT(PM_, UTIL_CAT(PM_##i##_LABEL, _ADDRESS)) - 0x1000000) : UTIL_CAT(PM_, UTIL_CAT(PM_##i##_LABEL, _ADDRESS))
+#endif
 #define FLASH_MAP_DEV(i)    UTIL_CAT(PM_, UTIL_CAT(PM_##i##_LABEL, _DEV_NAME))
 #define FLASH_MAP_SIZE(i)   UTIL_CAT(PM_, UTIL_CAT(PM_##i##_LABEL, _SIZE))
 #define FLASH_MAP_NUM       PM_NUM
diff --git a/subsys/pcd/src/pcd.c b/subsys/pcd/src/pcd.c
index c0752c303..931c4c8e3 100644
--- a/subsys/pcd/src/pcd.c
+++ b/subsys/pcd/src/pcd.c
@@ -12,6 +12,16 @@
 
 LOG_MODULE_REGISTER(pcd, CONFIG_PCD_LOG_LEVEL);
 
+#ifndef CONFIG_NORDIC_QSPI_NOR_FLASH_LAYOUT_PAGE_SIZE
+#define CONFIG_NORDIC_QSPI_NOR_FLASH_LAYOUT_PAGE_SIZE 4096
+#endif
+
+/* Shared memory configuration */
+#define SHM_NODE            DT_CHOSEN(zephyr_ipc_shm)
+#define SHM_START_ADDR      (DT_REG_ADDR(SHM_NODE) + 0x400)
+#define SHM_SIZE            (DT_REG_SIZE(SHM_NODE) - 0x400)
+#define SHM_DEVICE_NAME     "sram0.shm"
+
 /** Magic value written to indicate that a copy should take place. */
 #define PCD_CMD_MAGIC_COPY 0xb5b4b3b6
 /** Magic value written to indicate that a something failed. */
@@ -32,6 +42,11 @@ struct pcd_cmd {
 	const void *data;     /* Data to copy*/
 	size_t len;           /* Number of bytes to copy */
 	off_t offset;         /* Offset to store the flash image in */
+	void * image_chunk;   //RAM address used to store a chunk of image from external flash
+	uint32_t chunk_len;		//the size of the image chunk
+	uint32_t bytes_moved;  //bytes already transfered to netcore
+	bool image_chunk_available;   //a image chunk is available
+	bool image_chunk_written; //the image chunk is done with programming
 } __aligned(4);
 
 static struct pcd_cmd *cmd = (struct pcd_cmd *)PCD_CMD_ADDRESS;
@@ -73,15 +88,41 @@ int pcd_fw_copy(const struct device *fdev)
 		LOG_ERR("stream_flash_init failed: %d", rc);
 		return rc;
 	}
-
-	rc = stream_flash_buffered_write(&stream, (uint8_t *)cmd->data,
-					 cmd->len, true);
-	if (rc != 0) {
-		LOG_ERR("stream_flash_buffered_write fail: %d", rc);
-		return rc;
+	if ((uint32_t)cmd->data < 0x10000000)
+	{
+		printk("Secondary internal Flash");
+		//internal flash
+		rc = stream_flash_buffered_write(&stream, (uint8_t *)cmd->data,
+						cmd->len, true);
+		if (rc != 0) {
+			printk("stream_flash_buffered_write fail: %d ", rc);
+			return rc;
+		}
 	}
-
-	LOG_INF("Transfer done");
+	else
+	{	
+		printk("Secondary external Flash");			
+		//external flash
+		while (cmd->bytes_moved < cmd->len)
+		{
+			if (cmd->image_chunk_available)
+			{
+				rc = stream_flash_buffered_write(&stream, (uint8_t *)cmd->image_chunk,
+								cmd->chunk_len, true);
+				if (rc != 0) {
+					printk("stream_flash_buffered_write fail: %d", rc);
+					memset((uint8_t *)cmd->image_chunk, 0, 4096);
+					return rc;
+				}				
+				printk("stream written bytes %x ", stream.bytes_written);		
+				cmd->image_chunk_available = false;
+				cmd->image_chunk_written = true;
+			}
+		}
+		memset((uint8_t *)cmd->image_chunk, 0, 4096);
+	}
+	
+	printk("Transfer done");
 
 	return 0;
 }
@@ -94,6 +135,32 @@ void pcd_fw_copy_done(void)
 
 #if defined(CONFIG_SOC_NRF5340_CPUAPP) && defined(CONFIG_MCUBOOT)
 
+
+static void pcd_cmd_update()
+{
+	if ((uint32_t)cmd->data >= 0x10000000)
+	{
+		uint32_t bytes_left;
+		cmd->image_chunk = (uint8_t *) SHM_START_ADDR;
+		bytes_left = cmd->len - cmd->bytes_moved;
+		if (bytes_left > CONFIG_NORDIC_QSPI_NOR_FLASH_LAYOUT_PAGE_SIZE)
+		{
+			cmd->chunk_len = CONFIG_NORDIC_QSPI_NOR_FLASH_LAYOUT_PAGE_SIZE;
+		}
+		else 
+		{
+			cmd->chunk_len = bytes_left;
+		}
+		
+		memcpy(cmd->image_chunk, (uint8_t *)cmd->data + cmd->bytes_moved, cmd->chunk_len);
+		cmd->bytes_moved += cmd->chunk_len;
+		//printk("bytes moved %x ", cmd->bytes_moved);
+		cmd->image_chunk_written = false;
+		cmd->image_chunk_available = true;
+	}
+}
+
+
 /** @brief Construct a PCD CMD for copying data/firmware.
  *
  * @param data   The data to copy.
@@ -113,7 +180,11 @@ static int pcd_cmd_write(const void *data, size_t len, off_t offset)
 	cmd->data = data;
 	cmd->len = len;
 	cmd->offset = offset;
+	cmd->bytes_moved = 0;
+	printk("new image addr %x len %x offset %x", (uint32_t)data, len, cmd->offset);
 
+	pcd_cmd_update();
+	
 	return 0;
 }
 
@@ -138,24 +209,35 @@ int pcd_network_core_update(const void *src_addr, size_t len)
 	}
 
 	nrf_reset_network_force_off(NRF_RESET, false);
-	LOG_INF("Turned on network core");
+	printk("Turned on network core");
+
+	k_busy_wait(1 * USEC_PER_SEC);
 
 	do {
 		/* Wait for 1 second to avoid issue where network core
 		 * is unable to write to shared RAM.
-		 */
-		k_busy_wait(1 * USEC_PER_SEC);
+		 */		
+		k_busy_wait(1 * USEC_PER_MSEC);
 
 		err = pcd_fw_copy_status_get();
+		if (err == PCD_STATUS_COPY)
+		{
+			if (cmd->image_chunk_written == true)
+			{
+				pcd_cmd_update();
+			}
+		}
 	} while (err == PCD_STATUS_COPY);
 
+	//workaround anomaly-43
+	NRF_QSPI->TASKS_ACTIVATE = 1;
 	if (err == PCD_STATUS_COPY_FAILED) {
-		LOG_ERR("Network core update failed");
+		printk("Network core update failed");
 		return err;
 	}
 
 	nrf_reset_network_force_off(NRF_RESET, true);
-	LOG_INF("Turned off network core");
+	printk("Network core update success");
 
 	return 0;
 }
